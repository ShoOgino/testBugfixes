{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","commits":[{"id":"8d2ebfffa7de566fcbacb528a536a81ac3d15168","date":1545939747,"type":0,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"/dev/null","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && table) {\n      throw new IOException(\"If the table parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad296b823241a7204dcaa288b06f3df339fb2ed6","date":1551795554,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        System.out.println(values);\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        System.out.print(\"Is list\");\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          System.out.print(\"Are tuples\");\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            System.out.println(\"Is hist\");\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            System.out.println(\"Is freq\");\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && table) {\n      throw new IOException(\"If the table parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d71c56b79fe459a7dc5a43987bb52a57c9ba149","date":1551898562,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        System.out.println(values);\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        System.out.println(values);\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        System.out.print(\"Is list\");\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          System.out.print(\"Are tuples\");\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            System.out.println(\"Is hist\");\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            System.out.println(\"Is freq\");\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        System.out.println(values);\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e20dc8a74764ae091d43344295c88e92031a5ca","date":1560548943,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if(outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for(Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a0046d48ba82dd982903a22d0d3768645bb8222","date":1562031585,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if(outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for(Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c469fe67f2da2a654eb8d709dfd239236f23a9a2","date":1570414680,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (String key : evaluated.keySet()) {\n          List l = (List) evaluated.get(key);\n          tuple.put(key, l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table){\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if(o instanceof List) {\n        List<Tuple> tuples = (List<Tuple>)o;\n        outTuples.addAll(tuples);\n      } else if(o instanceof Tuple) {\n        outTuples.add((Tuple)o);\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b8166000722392fae60bb7dedf546abf7da58de","date":1572719262,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      if(o instanceof  KmeansEvaluator.ClusterTuple) {\n        KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple) o;\n        List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n          for (KmeansEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof DbscanEvaluator.ClusterTuple) {\n        DbscanEvaluator.ClusterTuple ct = (DbscanEvaluator.ClusterTuple) o;\n        List<Cluster<DbscanEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (Cluster<DbscanEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<DbscanEvaluator.ClusterPoint> points = c.getPoints();\n          for (DbscanEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple)o;\n      List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n      int clusterNum = 0;\n      for(CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n        clusterNum++;\n        List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n        for(KmeansEvaluator.ClusterPoint p : points) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", p.getPoint()[0]);\n          tuple.put(\"y\", p.getPoint()[1]);\n          tuple.put(\"cluster\", \"cluster\"+clusterNum);\n          outTuples.add(tuple);\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple();\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).getFields().containsKey(\"y\") && !outTuples.get(0).getFields().containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      if(o instanceof  KmeansEvaluator.ClusterTuple) {\n        KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple) o;\n        List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n          for (KmeansEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof DbscanEvaluator.ClusterTuple) {\n        DbscanEvaluator.ClusterTuple ct = (DbscanEvaluator.ClusterTuple) o;\n        List<Cluster<DbscanEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (Cluster<DbscanEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<DbscanEvaluator.ClusterPoint> points = c.getPoints();\n          for (DbscanEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple();\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple();\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.getFields().containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple();\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.getFields().containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple();\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple();\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple(new HashMap());\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).fields.containsKey(\"y\") && !outTuples.get(0).fields.containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      if(o instanceof  KmeansEvaluator.ClusterTuple) {\n        KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple) o;\n        List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n          for (KmeansEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof DbscanEvaluator.ClusterTuple) {\n        DbscanEvaluator.ClusterTuple ct = (DbscanEvaluator.ClusterTuple) o;\n        List<Cluster<DbscanEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (Cluster<DbscanEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<DbscanEvaluator.ClusterPoint> points = c.getPoints();\n          for (DbscanEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.fields.containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.fields.containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple(new HashMap());\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple(new HashMap());\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple(new HashMap());\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75","date":1591744896,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/ZplotStream#open().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap<>();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList<>();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple();\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).getFields().containsKey(\"y\") && !outTuples.get(0).getFields().containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      if(o instanceof  KmeansEvaluator.ClusterTuple) {\n        KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple) o;\n        List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n          for (KmeansEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof DbscanEvaluator.ClusterTuple) {\n        DbscanEvaluator.ClusterTuple ct = (DbscanEvaluator.ClusterTuple) o;\n        List<Cluster<DbscanEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (Cluster<DbscanEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<DbscanEvaluator.ClusterPoint> points = c.getPoints();\n          for (DbscanEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple();\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList<>();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple();\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.getFields().containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple();\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.getFields().containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple();\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple();\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","sourceOld":"  public void open() throws IOException {\n    Map<String, Object> lets = streamContext.getLets();\n    Set<Map.Entry<String, Object>> entries = letParams.entrySet();\n    Map<String, Object> evaluated = new HashMap();\n\n    //Load up the StreamContext with the data created by the letParams.\n    int numTuples = -1;\n    int columns = 0;\n    boolean table = false;\n    boolean distribution = false;\n    boolean clusters = false;\n    boolean heat = false;\n    for(Map.Entry<String, Object> entry : entries) {\n      ++columns;\n\n      String name = entry.getKey();\n      if(name.equals(\"table\")) {\n        table = true;\n      } else if(name.equals(\"dist\")) {\n        distribution = true;\n      } else if(name.equals(\"clusters\")) {\n        clusters = true;\n      } else if(name.equals(\"heat\")) {\n        heat = true;\n\n      }\n\n      Object o = entry.getValue();\n      if(o instanceof StreamEvaluator) {\n        Tuple eTuple = new Tuple(lets);\n        StreamEvaluator evaluator = (StreamEvaluator)o;\n        evaluator.setStreamContext(streamContext);\n        Object eo = evaluator.evaluate(eTuple);\n        if(eo instanceof List) {\n          List l = (List)eo;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if (eo instanceof Tuple) {\n          evaluated.put(name, eo);\n        } else {\n          evaluated.put(name, eo);\n        }\n      } else {\n        Object eval = lets.get(o);\n        if(eval instanceof List) {\n          List l = (List)eval;\n          if(numTuples == -1) {\n            numTuples = l.size();\n          } else {\n            if(l.size() != numTuples) {\n              throw new IOException(\"All lists provided to the zplot function must be the same length.\");\n            }\n          }\n          evaluated.put(name, l);\n        } else if(eval instanceof Tuple) {\n          evaluated.put(name, eval);\n        } else if(eval instanceof Matrix) {\n          evaluated.put(name, eval);\n        }\n      }\n    }\n\n    if(columns > 1 && (table || distribution)) {\n      throw new IOException(\"If the table or dist parameter is set there can only be one parameter.\");\n    }\n    //Load the values into tuples\n\n    List<Tuple> outTuples = new ArrayList();\n    if(!table && !distribution && !clusters && !heat) {\n      //Handle the vectors\n      for (int i = 0; i < numTuples; i++) {\n        Tuple tuple = new Tuple();\n        for (Map.Entry<String, Object> entry : evaluated.entrySet()) {\n          List l = (List) entry.getValue();\n          tuple.put(entry.getKey(), l.get(i));\n        }\n\n        outTuples.add(tuple);\n      }\n\n      //Generate the x axis if the tuples contain y and not x\n      if (outTuples.get(0).getFields().containsKey(\"y\") && !outTuples.get(0).getFields().containsKey(\"x\")) {\n        int x = 0;\n        for (Tuple tuple : outTuples) {\n          tuple.put(\"x\", x++);\n        }\n      }\n    } else if(clusters) {\n      Object o = evaluated.get(\"clusters\");\n      if(o instanceof  KmeansEvaluator.ClusterTuple) {\n        KmeansEvaluator.ClusterTuple ct = (KmeansEvaluator.ClusterTuple) o;\n        List<CentroidCluster<KmeansEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (CentroidCluster<KmeansEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<KmeansEvaluator.ClusterPoint> points = c.getPoints();\n          for (KmeansEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof DbscanEvaluator.ClusterTuple) {\n        DbscanEvaluator.ClusterTuple ct = (DbscanEvaluator.ClusterTuple) o;\n        List<Cluster<DbscanEvaluator.ClusterPoint>> cs = ct.getClusters();\n        int clusterNum = 0;\n        for (Cluster<DbscanEvaluator.ClusterPoint> c : cs) {\n          clusterNum++;\n          List<DbscanEvaluator.ClusterPoint> points = c.getPoints();\n          for (DbscanEvaluator.ClusterPoint p : points) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"x\", p.getPoint()[0]);\n            tuple.put(\"y\", p.getPoint()[1]);\n            tuple.put(\"cluster\", \"cluster\" + clusterNum);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    } else if(distribution) {\n      Object o = evaluated.get(\"dist\");\n      if(o instanceof RealDistribution) {\n        RealDistribution realDistribution = (RealDistribution) o;\n        List<SummaryStatistics> binStats = null;\n        if(realDistribution instanceof  EmpiricalDistribution) {\n          EmpiricalDistribution empiricalDistribution = (EmpiricalDistribution)realDistribution;\n          binStats = empiricalDistribution.getBinStats();\n        } else {\n          double[] samples = realDistribution.sample(500000);\n          EmpiricalDistribution empiricalDistribution = new EmpiricalDistribution(32);\n          empiricalDistribution.load(samples);\n          binStats = empiricalDistribution.getBinStats();\n        }\n        double[] x = new double[binStats.size()];\n        double[] y = new double[binStats.size()];\n        for (int i = 0; i < binStats.size(); i++) {\n          x[i] = binStats.get(i).getMean();\n          y[i] = realDistribution.density(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple();\n          if(!Double.isNaN(x[i])) {\n            tuple.put(\"x\", Precision.round(x[i], 2));\n            if(y[i] == Double.NEGATIVE_INFINITY || y[i] == Double.POSITIVE_INFINITY) {\n              tuple.put(\"y\", 0);\n\n            } else {\n              tuple.put(\"y\", y[i]);\n            }\n            outTuples.add(tuple);\n          }\n        }\n      } else if(o instanceof IntegerDistribution) {\n        IntegerDistribution integerDistribution = (IntegerDistribution)o;\n        int[] samples = integerDistribution.sample(50000);\n        Frequency frequency = new Frequency();\n        for(int i : samples) {\n          frequency.addValue(i);\n        }\n\n        Iterator it = frequency.valuesIterator();\n        List<Long> values = new ArrayList();\n        while(it.hasNext()) {\n          values.add((Long)it.next());\n        }\n        int[] x = new int[values.size()];\n        double[] y = new double[values.size()];\n        for(int i=0; i<values.size(); i++) {\n          x[i] = values.get(i).intValue();\n          y[i] = integerDistribution.probability(x[i]);\n        }\n\n        for (int i = 0; i < x.length; i++) {\n          Tuple tuple = new Tuple();\n          tuple.put(\"x\", x[i]);\n          tuple.put(\"y\", y[i]);\n          outTuples.add(tuple);\n        }\n      } else if(o instanceof List) {\n        List list = (List)o;\n        if(list.get(0) instanceof Tuple) {\n          List<Tuple> tlist = (List<Tuple>)o;\n          Tuple tuple = tlist.get(0);\n          if(tuple.getFields().containsKey(\"N\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple();\n              outtuple.put(\"x\", Precision.round(((double)t.get(\"mean\")), 2));\n              outtuple.put(\"y\", t.get(\"prob\"));\n              outTuples.add(outtuple);\n            }\n          } else if(tuple.getFields().containsKey(\"count\")) {\n            for(Tuple t : tlist) {\n              Tuple outtuple = new Tuple();\n              outtuple.put(\"x\", t.get(\"value\"));\n              outtuple.put(\"y\", t.get(\"pct\"));\n              outTuples.add(outtuple);\n            }\n          }\n        }\n      }\n    } else if(table) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"table\");\n      if (o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = Integer.toString(i);\n          }\n          Tuple tuple = new Tuple();\n          tuple.put(\"rowLabel\", rowLabel);\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + Integer.toString(j);\n            }\n\n            tuple.put(colLabel, data[i][j]);\n          }\n          outTuples.add(tuple);\n        }\n      }\n    } else if (heat) {\n      //Handle the Tuple and List of Tuples\n      Object o = evaluated.get(\"heat\");\n      if(o instanceof Matrix) {\n        Matrix m = (Matrix) o;\n        List<String> rowLabels = m.getRowLabels();\n        List<String> colLabels = m.getColumnLabels();\n        double[][] data = m.getData();\n        for (int i = 0; i < data.length; i++) {\n          String rowLabel = null;\n          if (rowLabels != null) {\n            rowLabel = rowLabels.get(i);\n          } else {\n            rowLabel = \"row\"+pad(Integer.toString(i), data.length);\n          }\n\n          double[] row = data[i];\n          for (int j = 0; j < row.length; j++) {\n            Tuple tuple = new Tuple();\n            tuple.put(\"y\", rowLabel);\n            String colLabel = null;\n            if (colLabels != null) {\n              colLabel = colLabels.get(j);\n            } else {\n              colLabel = \"col\" + pad(Integer.toString(j), row.length);\n            }\n            tuple.put(\"x\", colLabel);\n            tuple.put(\"z\", data[i][j]);\n            outTuples.add(tuple);\n          }\n        }\n      }\n    }\n\n    this.out = outTuples.iterator();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c469fe67f2da2a654eb8d709dfd239236f23a9a2":["8a0046d48ba82dd982903a22d0d3768645bb8222"],"3e20dc8a74764ae091d43344295c88e92031a5ca":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"8a0046d48ba82dd982903a22d0d3768645bb8222":["3e20dc8a74764ae091d43344295c88e92031a5ca"],"8d2ebfffa7de566fcbacb528a536a81ac3d15168":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["c469fe67f2da2a654eb8d709dfd239236f23a9a2"],"4d71c56b79fe459a7dc5a43987bb52a57c9ba149":["ad296b823241a7204dcaa288b06f3df339fb2ed6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"ad296b823241a7204dcaa288b06f3df339fb2ed6":["8d2ebfffa7de566fcbacb528a536a81ac3d15168"],"4b8166000722392fae60bb7dedf546abf7da58de":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["4d71c56b79fe459a7dc5a43987bb52a57c9ba149"],"804a8d5358fe7b7563b85ee7838714d720b89272":["4b8166000722392fae60bb7dedf546abf7da58de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"b0b597c65628ca9e73913a07e81691f8229bae35":["8a0046d48ba82dd982903a22d0d3768645bb8222","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"c469fe67f2da2a654eb8d709dfd239236f23a9a2":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"3e20dc8a74764ae091d43344295c88e92031a5ca":["8a0046d48ba82dd982903a22d0d3768645bb8222"],"8a0046d48ba82dd982903a22d0d3768645bb8222":["c469fe67f2da2a654eb8d709dfd239236f23a9a2","b0b597c65628ca9e73913a07e81691f8229bae35"],"8d2ebfffa7de566fcbacb528a536a81ac3d15168":["ad296b823241a7204dcaa288b06f3df339fb2ed6"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["4b8166000722392fae60bb7dedf546abf7da58de","b0b597c65628ca9e73913a07e81691f8229bae35"],"4d71c56b79fe459a7dc5a43987bb52a57c9ba149":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8d2ebfffa7de566fcbacb528a536a81ac3d15168"],"ad296b823241a7204dcaa288b06f3df339fb2ed6":["4d71c56b79fe459a7dc5a43987bb52a57c9ba149"],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["3e20dc8a74764ae091d43344295c88e92031a5ca"],"4b8166000722392fae60bb7dedf546abf7da58de":["804a8d5358fe7b7563b85ee7838714d720b89272"],"804a8d5358fe7b7563b85ee7838714d720b89272":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}