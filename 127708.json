{"path":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPointField#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPointField(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b516a692d03225c8f0e81a13ceed2dc32bb457d","date":1453411951,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w, true);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestBKDTree\")));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf8357a0b6e20da8f78592ec8e53dbd375b1026b","date":1456330381,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e79a60784094f4a1d4e4b03b3e8086bf55d3eeed","date":1456346320,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = new PointInGeo3DShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"171684e0272517c4ed0b7e61af869397e512d8e5","date":1457346184,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    PlanetModel planetModel = getPlanetModel();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", planetModel, lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(planetModel);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(planetModel, \"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(planetModel, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(planetModel.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4e444678504caf66a8060b1d514383aa4feac0c","date":1457399659,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"lucene/spatial3d/src/test/org/apache/lucene/spatial3d/TestGeo3DPoint#verify(double[],double[]).mjava","pathOld":"lucene/spatial3d/src/test/org/apache/lucene/geo3d/TestGeo3DPoint#verify(double[],double[]).mjava","sourceNew":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  private static void verify(double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    iwc.setCodec(getCodec());\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestBKDTree\"));\n    } else {\n      dir = getDirectory();\n    }\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        doc.add(new Geo3DPoint(\"point\", lats[id], lons[id]));\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.err.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the geo3d query must see the Geo3DDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              GeoShape shape = randomShape(PlanetModel.WGS84);\n\n              if (VERBOSE) {\n                System.err.println(\"\\n\" + Thread.currentThread() + \": TEST: iter=\" + iter + \" shape=\"+shape);\n              }\n              \n              Query query = Geo3DPoint.newShapeQuery(\"point\", shape);\n\n              if (VERBOSE) {\n                System.err.println(\"  using query: \" + query);\n              }\n\n              final FixedBitSet hits = new FixedBitSet(r.maxDoc());\n\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.err.println(\"  hitCount: \" + hits.cardinality());\n              }\n      \n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (Double.isNaN(lats[id]) == false) {\n\n                  // Accurate point:\n                  GeoPoint point1 = new GeoPoint(PlanetModel.WGS84, lats[id], lons[id]);\n\n                  // Quantized point (32 bits per dim):\n                  GeoPoint point2 = quantize(PlanetModel.WGS84.getMaximumMagnitude(), point1);\n\n                  if (shape.isWithin(point1) != shape.isWithin(point2)) {\n                    if (VERBOSE) {\n                      System.out.println(\"  skip checking docID=\" + docID + \" quantization changed the expected result from \" + shape.isWithin(point1) + \" to \" + shape.isWithin(point2));\n                    }\n                    continue;\n                  }\n\n                  boolean expected = ((deleted.contains(id) == false) && shape.isWithin(point2));\n                  if (hits.get(docID) != expected) {\n                    fail(Thread.currentThread().getName() + \": iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" lat=\" + lats[id] + \" lon=\" + lons[id] + \" expected \" + expected + \" but got: \" + hits.get(docID) + \" deleted?=\" + deleted.contains(id) + \"\\n  point1=\" + point1 + \", iswithin=\"+shape.isWithin(point1)+\"\\n  point2=\" + point2 + \", iswithin=\"+shape.isWithin(point2) + \"\\n  query=\" + query);\n                  }\n                } else {\n                  assertFalse(hits.get(docID));\n                }\n\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cf8357a0b6e20da8f78592ec8e53dbd375b1026b":["5a207d19eac354d649c3f0e2cce070017c78125e"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e79a60784094f4a1d4e4b03b3e8086bf55d3eeed":["5a207d19eac354d649c3f0e2cce070017c78125e","cf8357a0b6e20da8f78592ec8e53dbd375b1026b"],"171684e0272517c4ed0b7e61af869397e512d8e5":["cf8357a0b6e20da8f78592ec8e53dbd375b1026b"],"5a207d19eac354d649c3f0e2cce070017c78125e":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","b470f36a9372c97283360b1304eacbde22df6c0d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["7b516a692d03225c8f0e81a13ceed2dc32bb457d","b470f36a9372c97283360b1304eacbde22df6c0d"],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"b4e444678504caf66a8060b1d514383aa4feac0c":["171684e0272517c4ed0b7e61af869397e512d8e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b4e444678504caf66a8060b1d514383aa4feac0c"]},"commit2Childs":{"cf8357a0b6e20da8f78592ec8e53dbd375b1026b":["e79a60784094f4a1d4e4b03b3e8086bf55d3eeed","171684e0272517c4ed0b7e61af869397e512d8e5"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["7b516a692d03225c8f0e81a13ceed2dc32bb457d"],"e79a60784094f4a1d4e4b03b3e8086bf55d3eeed":[],"171684e0272517c4ed0b7e61af869397e512d8e5":["b4e444678504caf66a8060b1d514383aa4feac0c"],"5a207d19eac354d649c3f0e2cce070017c78125e":["cf8357a0b6e20da8f78592ec8e53dbd375b1026b","e79a60784094f4a1d4e4b03b3e8086bf55d3eeed"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"7b516a692d03225c8f0e81a13ceed2dc32bb457d":["5a207d19eac354d649c3f0e2cce070017c78125e","b470f36a9372c97283360b1304eacbde22df6c0d","1e6acbaae7af722f17204ceccf0f7db5753eccf3","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"b4e444678504caf66a8060b1d514383aa4feac0c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e79a60784094f4a1d4e4b03b3e8086bf55d3eeed","1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}