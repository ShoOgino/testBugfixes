{"path":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","commits":[{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"/dev/null","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["45cb1a93c8314086fa3e14744fbc4eec36006057"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"45cb1a93c8314086fa3e14744fbc4eec36006057","date":1496192068,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      if (random().nextBoolean()) {\n        CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n        .setMaxShardsPerNode(100)\n        .process(cluster.getSolrClient());\n      } else {\n        // Sometimes don't use SolrJ.\n        String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\", \n            cluster.getRandomJetty(random()).getBaseUrl(), \n            collectionName,\n            2,    // numShards\n            3,    // pullReplicas \n            100); // maxShardsPerNode\n        url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n        HttpGet createCollectionRequest = new HttpGet(url);\n        cluster.getSolrClient().getHttpClient().execute(createCollectionRequest);\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      if (random().nextBoolean()) {\n        CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n        .setMaxShardsPerNode(100)\n        .process(cluster.getSolrClient());\n      } else {\n        // Sometimes don't use SolrJ.\n        String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\", \n            cluster.getRandomJetty(random()).getBaseUrl(), \n            collectionName,\n            2,    // numShards\n            3,    // pullReplicas \n            100); // maxShardsPerNode\n        url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n        HttpGet createCollectionRequest = new HttpGet(url);\n        cluster.getSolrClient().getHttpClient().execute(createCollectionRequest);\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44b289ba5434fa10782118c697fa706d6cf231df","date":1496249545,"type":3,"author":"Chris Hostetter","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      if (random().nextBoolean()) {\n        CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n        .setMaxShardsPerNode(100)\n        .process(cluster.getSolrClient());\n      } else {\n        // Sometimes don't use SolrJ.\n        String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\", \n            cluster.getRandomJetty(random()).getBaseUrl(), \n            collectionName,\n            2,    // numShards\n            3,    // pullReplicas \n            100); // maxShardsPerNode\n        url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n        HttpGet createCollectionRequest = new HttpGet(url);\n        cluster.getSolrClient().getHttpClient().execute(createCollectionRequest);\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c538b3eeebd03c2067a2fa5be92f073a08b6f41","date":1496264014,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      if (random().nextBoolean()) {\n        CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n        .setMaxShardsPerNode(100)\n        .process(cluster.getSolrClient());\n      } else {\n        // Sometimes don't use SolrJ.\n        String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\", \n            cluster.getRandomJetty(random()).getBaseUrl(), \n            collectionName,\n            2,    // numShards\n            3,    // pullReplicas \n            100); // maxShardsPerNode\n        url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n        HttpGet createCollectionRequest = new HttpGet(url);\n        cluster.getSolrClient().getHttpClient().execute(createCollectionRequest);\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      if (random().nextBoolean()) {\n        CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n        .setMaxShardsPerNode(100)\n        .process(cluster.getSolrClient());\n      } else {\n        // Sometimes don't use SolrJ.\n        String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\", \n            cluster.getRandomJetty(random()).getBaseUrl(), \n            collectionName,\n            2,    // numShards\n            3,    // pullReplicas \n            100); // maxShardsPerNode\n        url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n        HttpGet createCollectionRequest = new HttpGet(url);\n        cluster.getSolrClient().getHttpClient().execute(createCollectionRequest);\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"/dev/null","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"197bbedf08450ade98a11f4a0001448059666bec","date":1498534625,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","date":1498540685,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName,\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      if (random().nextBoolean()) {\n        CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n        .setMaxShardsPerNode(100)\n        .process(cluster.getSolrClient());\n      } else {\n        // Sometimes don't use SolrJ.\n        String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\", \n            cluster.getRandomJetty(random()).getBaseUrl(), \n            collectionName,\n            2,    // numShards\n            3,    // pullReplicas \n            100); // maxShardsPerNode\n        url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n        HttpGet createCollectionRequest = new HttpGet(url);\n        cluster.getSolrClient().getHttpClient().execute(createCollectionRequest);\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5c929d2716fa79d443b93a82adb1da5b578ebd8","date":1550428858,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()),\n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStream(System.out);\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()), \n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStdOut();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#testCreateDelete().mjava","sourceNew":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3);   // pullReplicas\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()),\n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStream(System.out);\n    }\n  }\n\n","sourceOld":"  @Repeat(iterations=2) // 2 times to make sure cleanup is complete and we can create the same collection\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testCreateDelete() throws Exception {\n    try {\n      switch (random().nextInt(3)) {\n        case 0:\n          // Sometimes use SolrJ\n          CollectionAdminRequest.createCollection(collectionName, \"conf\", 2, 1, 0, 3)\n          .setMaxShardsPerNode(100)\n          .process(cluster.getSolrClient());\n          break;\n        case 1:\n          // Sometimes use v1 API\n          String url = String.format(Locale.ROOT, \"%s/admin/collections?action=CREATE&name=%s&collection.configName=%s&numShards=%s&pullReplicas=%s&maxShardsPerNode=%s\",\n              cluster.getRandomJetty(random()).getBaseUrl(),\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100); // maxShardsPerNode\n          url = url + pickRandom(\"\", \"&nrtReplicas=1\", \"&replicationFactor=1\"); // These options should all mean the same\n          HttpGet createCollectionGet = new HttpGet(url);\n          cluster.getSolrClient().getHttpClient().execute(createCollectionGet);\n          break;\n        case 2:\n          // Sometimes use V2 API\n          url = cluster.getRandomJetty(random()).getBaseUrl().toString() + \"/____v2/c\";\n          String requestBody = String.format(Locale.ROOT, \"{create:{name:%s, config:%s, numShards:%s, pullReplicas:%s, maxShardsPerNode:%s %s}}\",\n              collectionName, \"conf\",\n              2,    // numShards\n              3,    // pullReplicas\n              100, // maxShardsPerNode\n              pickRandom(\"\", \", nrtReplicas:1\", \", replicationFactor:1\")); // These options should all mean the same\n          HttpPost createCollectionPost = new HttpPost(url);\n          createCollectionPost.setHeader(\"Content-type\", \"application/json\");\n          createCollectionPost.setEntity(new StringEntity(requestBody));\n          HttpResponse httpResponse = cluster.getSolrClient().getHttpClient().execute(createCollectionPost);\n          assertEquals(200, httpResponse.getStatusLine().getStatusCode());\n          break;\n      }\n      boolean reloaded = false;\n      while (true) {\n        DocCollection docCollection = getCollectionState(collectionName);\n        assertNotNull(docCollection);\n        assertEquals(\"Expecting 4 relpicas per shard\",\n            8, docCollection.getReplicas().size());\n        assertEquals(\"Expecting 6 pull replicas, 3 per shard\",\n            6, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).size());\n        assertEquals(\"Expecting 2 writer replicas, one per shard\",\n            2, docCollection.getReplicas(EnumSet.of(Replica.Type.NRT)).size());\n        for (Slice s:docCollection.getSlices()) {\n          // read-only replicas can never become leaders\n          assertFalse(s.getLeader().getType() == Replica.Type.PULL);\n          List<String> shardElectionNodes = cluster.getZkClient().getChildren(ZkStateReader.getShardLeadersElectPath(collectionName, s.getName()), null, true);\n          assertEquals(\"Unexpected election nodes for Shard: \" + s.getName() + \": \" + Arrays.toString(shardElectionNodes.toArray()),\n              1, shardElectionNodes.size());\n        }\n        assertUlogPresence(docCollection);\n        if (reloaded) {\n          break;\n        } else {\n          // reload\n          CollectionAdminResponse response = CollectionAdminRequest.reloadCollection(collectionName)\n          .process(cluster.getSolrClient());\n          assertEquals(0, response.getStatus());\n          reloaded = true;\n        }\n      }\n    } finally {\n      zkClient().printLayoutToStream(System.out);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c538b3eeebd03c2067a2fa5be92f073a08b6f41":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"61c45e99cf6676da48f19d7511c73712ad39402b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"197bbedf08450ade98a11f4a0001448059666bec":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["43ad790248d7f7daee5d9cced548c546f37c7218"],"43ad790248d7f7daee5d9cced548c546f37c7218":["28288370235ed02234a64753cdbf0c6ec096304a"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"28288370235ed02234a64753cdbf0c6ec096304a":["d1f5728f32a4a256b36cfabd7a2636452f599bb9","197bbedf08450ade98a11f4a0001448059666bec"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["45cb1a93c8314086fa3e14744fbc4eec36006057","4c538b3eeebd03c2067a2fa5be92f073a08b6f41"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"45cb1a93c8314086fa3e14744fbc4eec36006057":["61c45e99cf6676da48f19d7511c73712ad39402b"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["e9017cf144952056066919f1ebc7897ff9bd71b1","197bbedf08450ade98a11f4a0001448059666bec"],"44b289ba5434fa10782118c697fa706d6cf231df":["61c45e99cf6676da48f19d7511c73712ad39402b","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["61c45e99cf6676da48f19d7511c73712ad39402b","45cb1a93c8314086fa3e14744fbc4eec36006057"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"4c538b3eeebd03c2067a2fa5be92f073a08b6f41":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"61c45e99cf6676da48f19d7511c73712ad39402b":["45cb1a93c8314086fa3e14744fbc4eec36006057","44b289ba5434fa10782118c697fa706d6cf231df","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"197bbedf08450ade98a11f4a0001448059666bec":["28288370235ed02234a64753cdbf0c6ec096304a","fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"43ad790248d7f7daee5d9cced548c546f37c7218":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["197bbedf08450ade98a11f4a0001448059666bec","e9017cf144952056066919f1ebc7897ff9bd71b1"],"28288370235ed02234a64753cdbf0c6ec096304a":["43ad790248d7f7daee5d9cced548c546f37c7218"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["61c45e99cf6676da48f19d7511c73712ad39402b","e9017cf144952056066919f1ebc7897ff9bd71b1"],"45cb1a93c8314086fa3e14744fbc4eec36006057":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":[],"44b289ba5434fa10782118c697fa706d6cf231df":[],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["4c538b3eeebd03c2067a2fa5be92f073a08b6f41","28288370235ed02234a64753cdbf0c6ec096304a","44b289ba5434fa10782118c697fa706d6cf231df"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","44b289ba5434fa10782118c697fa706d6cf231df","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}