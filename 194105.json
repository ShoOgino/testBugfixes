{"path":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map).mjava","commits":[{"id":"d3ab91f3bb602daf6393fa7f78b11afd3400d669","date":1243282044,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,String).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, String commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8","date":1255049357,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      if (sizeInBytes > 0)\n        syncPause(sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // sizeInBytes > 0 means this is an autoCommit at\n        // the end of a merge.  If at this point stopMerges\n        // is true (which means a rollback() or\n        // rollbackTransaction() is waiting for us to\n        // finish), we skip the commit to avoid deadlock\n        if (sizeInBytes > 0 && stopMerges)\n          return;\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef82ff03e4016c705811b2658e81471a645c0e49","date":1255900293,"type":5,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map[String,String]).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#startCommit(long,Map).mjava","sourceNew":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map<String,String> commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Collection<String> files = toSync.files(directory, false);\n          for(final String fileName: files) {\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection<String> pending = new ArrayList<String>();\n\n          Iterator<String> it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","sourceOld":"  /** Walk through all files referenced by the current\n   *  segmentInfos and ask the Directory to sync each file,\n   *  if it wasn't already.  If that succeeds, then we\n   *  prepare a new segments_N file but do not fully commit\n   *  it. */\n  private void startCommit(long sizeInBytes, Map commitUserData) throws IOException {\n\n    assert testPoint(\"startStartCommit\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot commit\");\n    }\n\n    try {\n\n      if (infoStream != null)\n        message(\"startCommit(): start sizeInBytes=\" + sizeInBytes);\n\n      SegmentInfos toSync = null;\n      final long myChangeCount;\n\n      synchronized(this) {\n\n        // Wait for any running addIndexes to complete\n        // first, then block any from running until we've\n        // copied the segmentInfos we intend to sync:\n        blockAddIndexes(false);\n\n        // On commit the segmentInfos must never\n        // reference a segment in another directory:\n        assert !hasExternalSegments();\n\n        try {\n\n          assert lastCommitChangeCount <= changeCount;\n\n          if (changeCount == lastCommitChangeCount) {\n            if (infoStream != null)\n              message(\"  skip startCommit(): no changes pending\");\n            return;\n          }\n\n          // First, we clone & incref the segmentInfos we intend\n          // to sync, then, without locking, we sync() each file\n          // referenced by toSync, in the background.  Multiple\n          // threads can be doing this at once, if say a large\n          // merge and a small merge finish at the same time:\n\n          if (infoStream != null)\n            message(\"startCommit index=\" + segString(segmentInfos) + \" changeCount=\" + changeCount);\n          \n          readerPool.commit();\n          \n          toSync = (SegmentInfos) segmentInfos.clone();\n\n          if (commitUserData != null)\n            toSync.setUserData(commitUserData);\n\n          deleter.incRef(toSync, false);\n          myChangeCount = changeCount;\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            String fileName = (String) it.next();\n            assert directory.fileExists(fileName): \"file \" + fileName + \" does not exist\";\n          }\n\n        } finally {\n          resumeAddIndexes();\n        }\n      }\n\n      assert testPoint(\"midStartCommit\");\n\n      boolean setPending = false;\n\n      try {\n\n        // Loop until all files toSync references are sync'd:\n        while(true) {\n\n          final Collection pending = new ArrayList();\n\n          Iterator it = toSync.files(directory, false).iterator();\n          while(it.hasNext()) {\n            final String fileName = (String) it.next();\n            if (startSync(fileName, pending)) {\n              boolean success = false;\n              try {\n                // Because we incRef'd this commit point, above,\n                // the file had better exist:\n                assert directory.fileExists(fileName): \"file '\" + fileName + \"' does not exist dir=\" + directory;\n                if (infoStream != null)\n                  message(\"now sync \" + fileName);\n                directory.sync(fileName);\n                success = true;\n              } finally {\n                finishSync(fileName, success);\n              }\n            }\n          }\n\n          // All files that I require are either synced or being\n          // synced by other threads.  If they are being synced,\n          // we must at this point block until they are done.\n          // If this returns false, that means an error in\n          // another thread resulted in failing to actually\n          // sync one of our files, so we repeat:\n          if (waitForAllSynced(pending))\n            break;\n        }\n\n        assert testPoint(\"midStartCommit2\");\n\n        synchronized(this) {\n          // If someone saved a newer version of segments file\n          // since I first started syncing my version, I can\n          // safely skip saving myself since I've been\n          // superseded:\n\n          while(true) {\n            if (myChangeCount <= lastCommitChangeCount) {\n              if (infoStream != null) {\n                message(\"sync superseded by newer infos\");\n              }\n              break;\n            } else if (pendingCommit == null) {\n              // My turn to commit\n\n              if (segmentInfos.getGeneration() > toSync.getGeneration())\n                toSync.updateGeneration(segmentInfos);\n\n              boolean success = false;\n              try {\n\n                // Exception here means nothing is prepared\n                // (this method unwinds everything it did on\n                // an exception)\n                try {\n                  toSync.prepareCommit(directory);\n                } finally {\n                  // Have our master segmentInfos record the\n                  // generations we just prepared.  We do this\n                  // on error or success so we don't\n                  // double-write a segments_N file.\n                  segmentInfos.updateGeneration(toSync);\n                }\n\n                assert pendingCommit == null;\n                setPending = true;\n                pendingCommit = toSync;\n                pendingCommitChangeCount = myChangeCount;\n                success = true;\n              } finally {\n                if (!success && infoStream != null)\n                  message(\"hit exception committing segments file\");\n              }\n              break;\n            } else {\n              // Must wait for other commit to complete\n              doWait();\n            }\n          }\n        }\n\n        if (infoStream != null)\n          message(\"done all syncs\");\n\n        assert testPoint(\"midStartCommitSuccess\");\n\n      } finally {\n        synchronized(this) {\n          if (!setPending)\n            deleter.decRef(toSync);\n        }\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"startCommit\");\n    }\n    assert testPoint(\"finishStartCommit\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ef82ff03e4016c705811b2658e81471a645c0e49":["ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ef82ff03e4016c705811b2658e81471a645c0e49"]},"commit2Childs":{"ef82ff03e4016c705811b2658e81471a645c0e49":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3ab91f3bb602daf6393fa7f78b11afd3400d669":["ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3ab91f3bb602daf6393fa7f78b11afd3400d669"],"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8":["ef82ff03e4016c705811b2658e81471a645c0e49"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}