{"path":"lucene/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","pathOld":"lucene/src/java/org/apache/lucene/store/LockStressTest#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n\n    if (args.length != 6) {\n      System.out.println(\"\\nUsage: java org.apache.lucene.store.LockStressTest myID verifierHostOrIP verifierPort lockFactoryClassName lockDirName sleepTime\\n\" +\n                         \"\\n\" +\n                         \"  myID = int from 0 .. 255 (should be unique for test process)\\n\" +\n                         \"  verifierHostOrIP = host name or IP address where LockVerifyServer is running\\n\" +\n                         \"  verifierPort = port that LockVerifyServer is listening on\\n\" +\n                         \"  lockFactoryClassName = primary LockFactory class that we will use\\n\" +\n                         \"  lockDirName = path to the lock directory (only set for Simple/NativeFSLockFactory\\n\" +\n                         \"  sleepTimeMS = milliseconds to pause betweeen each lock obtain/release\\n\" +\n                         \"\\n\" +\n                         \"You should run multiple instances of this process, each with its own\\n\" +\n                         \"unique ID, and each pointing to the same lock directory, to verify\\n\" +\n                         \"that locking is working correctly.\\n\" +\n                         \"\\n\" +\n                         \"Make sure you are first running LockVerifyServer.\\n\" + \n                         \"\\n\");\n      System.exit(1);\n    }\n\n    final int myID = Integer.parseInt(args[0]);\n\n    if (myID < 0 || myID > 255) {\n      System.out.println(\"myID must be a unique int 0..255\");\n      System.exit(1);\n    }\n\n    final String verifierHost = args[1];\n    final int verifierPort = Integer.parseInt(args[2]);\n    final String lockFactoryClassName = args[3];\n    final String lockDirName = args[4];\n    final int sleepTimeMS = Integer.parseInt(args[5]);\n\n    LockFactory lockFactory;\n    try {\n      lockFactory = Class.forName(lockFactoryClassName).asSubclass(LockFactory.class).newInstance();          \n    } catch (IllegalAccessException e) {\n      throw new IOException(\"IllegalAccessException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (InstantiationException e) {\n      throw new IOException(\"InstantiationException when instantiating LockClass \" + lockFactoryClassName);\n    } catch (ClassCastException e) {\n      throw new IOException(\"unable to cast LockClass \" + lockFactoryClassName + \" instance to a LockFactory\");\n    } catch (ClassNotFoundException e) {\n      throw new IOException(\"unable to find LockClass \" + lockFactoryClassName);\n    }\n\n    File lockDir = new File(lockDirName);\n\n    if (lockFactory instanceof FSLockFactory) {\n      ((FSLockFactory) lockFactory).setLockDir(lockDir);\n    }\n\n    lockFactory.setLockPrefix(\"test\");\n    \n    LockFactory verifyLF = new VerifyingLockFactory((byte) myID, lockFactory, verifierHost, verifierPort);\n\n    Lock l = verifyLF.makeLock(\"test.lock\");\n\n    while(true) {\n\n      boolean obtained = false;\n\n      try {\n        obtained = l.obtain(10);\n      } catch (LockObtainFailedException e) {\n        System.out.print(\"x\");\n      }\n\n      if (obtained) {\n        System.out.print(\"l\");\n        l.release();\n      }\n      Thread.sleep(sleepTimeMS);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}