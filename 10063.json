{"path":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","commits":[{"id":"8a08695eb0e2c01d06dd662674e3136641f093be","date":1450145331,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89205ca052ebf6aadc59a88698d262c718c616ed","date":1465540166,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","sourceNew":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n\n    // SOLR-9174\n    assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n        req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"1<-1\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n  }\n\n","sourceOld":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","sourceNew":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n\n    // SOLR-9174\n    assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n        req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"1<-1\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n  }\n\n","sourceOld":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","sourceNew":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    for (String sow : Arrays.asList(\"true\", \"false\")) {\n      assertQ(\"test minShouldMatch (top level optional terms only)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional terms only and sow=false)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n          req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n          req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level required terms only)\",\n          req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level optional and required terms)\",\n          req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n          req(\"q\", \"(snake OR stocks) oil\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=2]\");\n\n      // The results for these two appear odd, but are correct as per BooleanQuery processing.\n      // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n      // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n      //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"OR\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"AND\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n\n      // SOLR-9174\n      assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n          req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"1<-1\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n\n    // SOLR-9174\n    assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n        req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"1<-1\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n  }\n\n","bugFix":null,"bugIntro":["f78578dc643ac34ccf47f0bc6fa8e97a1704a084"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","sourceNew":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    for (String sow : Arrays.asList(\"true\", \"false\")) {\n      assertQ(\"test minShouldMatch (top level optional terms only)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional terms only and sow=false)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n          req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n          req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level required terms only)\",\n          req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level optional and required terms)\",\n          req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n          req(\"q\", \"(snake OR stocks) oil\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=2]\");\n\n      // The results for these two appear odd, but are correct as per BooleanQuery processing.\n      // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n      // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n      //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"OR\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"AND\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n\n      // SOLR-9174\n      assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n          req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"1<-1\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    assertQ(\"test minShouldMatch (top level optional terms only)\",\n        req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=4]\");\n    \n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n        req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n        req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level required terms only)\",\n        req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=1]\");\n\n    assertQ(\"test minShouldMatch (top level optional and required terms)\",\n        req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n            \"qf\", \"text_sw\",\n            \"mm\", \"50%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n\n    assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n        req(\"q\", \"(snake OR stocks) oil\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=2]\");\n\n    // The results for these two appear odd, but are correct as per BooleanQuery processing.\n    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n    //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"OR\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n    assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n        req(\"q\", \"snake OR stocks oil\",\n            \"qf\", \"text_sw\",\n            \"q.op\", \"AND\",\n            \"mm\", \"100%\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=0]\");\n\n    // SOLR-9174\n    assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n        req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n            \"qf\", \"text_sw\",\n            \"mm\", \"1<-1\",\n            \"defType\", \"edismax\")\n        , \"*[count(//doc)=3]\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f78578dc643ac34ccf47f0bc6fa8e97a1704a084","date":1591013591,"type":3,"author":"Yuriy Koval","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestExtendedDismaxParser#testMinShouldMatchOptional().mjava","sourceNew":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    for (String sow : Arrays.asList(\"true\", \"false\")) {\n      assertQ(\"test minShouldMatch (top level optional terms only)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional terms only) local mm=50%\",\n          req(\"q\", \"{!edismax qf=text_sw mm=50% sow=\" + sow + \" v='stocks oil gold'}\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n          req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms local mm=50%)\",\n          req(\"q\", \"{!edismax qf=text_sw mm=50% sow=\" + sow + \" v='stocks oil gold -stockade'}\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n          req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms local mm=100%)\",\n          req(\"q\", \"{!edismax qf=text_sw mm=100% sow=\" + sow + \" v='stocks gold -stockade'}\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level required terms only)\",\n          req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level required terms only) local mm=50%)\",\n          req(\"q\", \"{!edismax qf=text_sw mm=50% sow=\" + sow + \" v='stocks AND oil'}\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level optional and required terms)\",\n          req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional and required terms) local mm=50%)\",\n          req(\"q\", \"{!edismax qf=text_sw mm=50% sow=\" + sow + \" v='oil gold +stocks'}\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n          req(\"q\", \"(snake OR stocks) oil\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=2]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR and parens) local mm=100%)\",\n          req(\"q\", \"{!edismax qf=text_sw mm=100% sow=\" + sow + \" v='(snake OR stocks) oil'}\")\n          , \"*[count(//doc)=2]\");\n\n      // The results for these two appear odd, but are correct as per BooleanQuery processing.\n      // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n      // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n      //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"OR\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens) local mm=100%)\",\n          req(\"q\", \"{!edismax qf=text_sw q.op=OR mm=100% sow=\" + sow + \" v='snake OR stocks oil'}\")\n          , \"*[count(//doc)=0]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"AND\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens) local mm=100%)\",\n          req(\"q\", \"{!edismax qf=text_sw q.op=AND mm=100% sow=\" + sow + \" v='snake OR stocks oil'}\")\n          , \"*[count(//doc)=0]\");\n\n      // SOLR-9174\n      assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n          req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"1<-1\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test local minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n          req(\"q\", \"{!edismax qf=text_sw mm=1<-1 sow=\" + sow + \" v='barbie OR (hair AND nonexistentword)'}\")\n          , \"*[count(//doc)=3]\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Test that minShouldMatch applies to Optional terms only\n   */\n  public void testMinShouldMatchOptional() throws Exception {\n    for (String sow : Arrays.asList(\"true\", \"false\")) {\n      assertQ(\"test minShouldMatch (top level optional terms only)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional terms only and sow=false)\",\n          req(\"q\", \"stocks oil gold\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=4]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=50%)\",\n          req(\"q\", \"stocks oil gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional and negative terms mm=100%)\",\n          req(\"q\", \"stocks gold -stockade\", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level required terms only)\",\n          req(\"q\", \"stocks AND oil\", // +(+(text_sw:stock) +(text_sw:oil))\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=1]\");\n\n      assertQ(\"test minShouldMatch (top level optional and required terms)\",\n          req(\"q\", \"oil gold +stocks\", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)\n              \"qf\", \"text_sw\",\n              \"mm\", \"50%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n\n      assertQ(\"test minShouldMatch (top level optional with explicit OR and parens)\",\n          req(\"q\", \"(snake OR stocks) oil\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=2]\");\n\n      // The results for these two appear odd, but are correct as per BooleanQuery processing.\n      // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/\n      // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND\n      //   and when q.op = OR all three clauses are top-level and optional so mm takes over\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"OR\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n      assertQ(\"test minShouldMatch (top level optional with explicit OR without parens)\",\n          req(\"q\", \"snake OR stocks oil\",\n              \"qf\", \"text_sw\",\n              \"q.op\", \"AND\",\n              \"mm\", \"100%\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=0]\");\n\n      // SOLR-9174\n      assertQ(\"test minShouldMatch=1<-1 with explicit OR, one impossible clause, and no explicit q.op\",\n          req(\"q\", \"barbie OR (hair AND nonexistentword)\",\n              \"qf\", \"text_sw\",\n              \"mm\", \"1<-1\",\n              \"sow\", sow,\n              \"defType\", \"edismax\")\n          , \"*[count(//doc)=3]\");\n    }\n  }\n\n","bugFix":["e55782fb51a6e9789542818eb2161a3247f39ace"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"89205ca052ebf6aadc59a88698d262c718c616ed":["8a08695eb0e2c01d06dd662674e3136641f093be"],"f78578dc643ac34ccf47f0bc6fa8e97a1704a084":["e55782fb51a6e9789542818eb2161a3247f39ace"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a08695eb0e2c01d06dd662674e3136641f093be":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c03778630c4604270d88c148afb8c7de35b51d3c":["89205ca052ebf6aadc59a88698d262c718c616ed"],"e55782fb51a6e9789542818eb2161a3247f39ace":["89205ca052ebf6aadc59a88698d262c718c616ed"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["8a08695eb0e2c01d06dd662674e3136641f093be","89205ca052ebf6aadc59a88698d262c718c616ed"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f78578dc643ac34ccf47f0bc6fa8e97a1704a084"]},"commit2Childs":{"89205ca052ebf6aadc59a88698d262c718c616ed":["c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f78578dc643ac34ccf47f0bc6fa8e97a1704a084":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8a08695eb0e2c01d06dd662674e3136641f093be"],"8a08695eb0e2c01d06dd662674e3136641f093be":["89205ca052ebf6aadc59a88698d262c718c616ed","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"c03778630c4604270d88c148afb8c7de35b51d3c":[],"e55782fb51a6e9789542818eb2161a3247f39ace":["f78578dc643ac34ccf47f0bc6fa8e97a1704a084"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c03778630c4604270d88c148afb8c7de35b51d3c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}