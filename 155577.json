{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","commits":[{"id":"110125c995236a7f61057dd04b039ed2d267f3a1","date":1521014987,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,Term).mjava","sourceNew":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n      final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException, AbortingException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delNode);\n      } catch (AbortingException ae) {\n        flushControl.doOnAbort(perThread);\n        dwpt.abort();\n        throw ae;\n      } finally {\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n      final Term delTerm) throws IOException, AbortingException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delTerm); \n      } catch (AbortingException ae) {\n        flushControl.doOnAbort(perThread);\n        dwpt.abort();\n        throw ae;\n      } finally {\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delTerm != null;\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n      final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delNode);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n      final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException, AbortingException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delNode);\n      } catch (AbortingException ae) {\n        flushControl.doOnAbort(perThread);\n        dwpt.abort();\n        throw ae;\n      } finally {\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n                      final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","sourceOld":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n      final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delNode);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"142f99d1da3d720b5094f5b47b0e57f8ef6ab03c","date":1584127995,"type":4,"author":"Simon Willnauer","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#updateDocument(Iterable[#-extends-IndexableField],Analyzer,DocumentsWriterDeleteQueue.Node[#]).mjava","sourceNew":null,"sourceOld":"  long updateDocument(final Iterable<? extends IndexableField> doc, final Analyzer analyzer,\n                      final DocumentsWriterDeleteQueue.Node<?> delNode) throws IOException {\n\n    boolean hasEvents = preUpdate();\n\n    final ThreadState perThread = flushControl.obtainAndLock();\n\n    final DocumentsWriterPerThread flushingDWPT;\n    long seqNo;\n    try {\n      // This must happen after we've pulled the ThreadState because IW.close\n      // waits for all ThreadStates to be released:\n      ensureOpen();\n      ensureInitialized(perThread);\n      assert perThread.isInitialized();\n      final DocumentsWriterPerThread dwpt = perThread.dwpt;\n      final int dwptNumDocs = dwpt.getNumDocsInRAM();\n      try {\n        seqNo = dwpt.updateDocument(doc, analyzer, delNode, flushNotifications);\n      } finally {\n        if (dwpt.isAborted()) {\n          flushControl.doOnAbort(perThread);\n        }\n        // We don't know whether the document actually\n        // counted as being indexed, so we must subtract here to\n        // accumulate our separate counter:\n        numDocsInRAM.addAndGet(dwpt.getNumDocsInRAM() - dwptNumDocs);\n      }\n      final boolean isUpdate = delNode != null && delNode.isDelete();\n      flushingDWPT = flushControl.doAfterDocument(perThread, isUpdate);\n\n      assert seqNo > perThread.lastSeqNo: \"seqNo=\" + seqNo + \" lastSeqNo=\" + perThread.lastSeqNo;\n      perThread.lastSeqNo = seqNo;\n\n    } finally {\n      perThreadPool.release(perThread);\n    }\n\n    if (postUpdate(flushingDWPT, hasEvents)) {\n      seqNo = -seqNo;\n    }\n    \n    return seqNo;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["110125c995236a7f61057dd04b039ed2d267f3a1"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"142f99d1da3d720b5094f5b47b0e57f8ef6ab03c":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"110125c995236a7f61057dd04b039ed2d267f3a1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["142f99d1da3d720b5094f5b47b0e57f8ef6ab03c"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["142f99d1da3d720b5094f5b47b0e57f8ef6ab03c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["110125c995236a7f61057dd04b039ed2d267f3a1"],"142f99d1da3d720b5094f5b47b0e57f8ef6ab03c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"110125c995236a7f61057dd04b039ed2d267f3a1":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}