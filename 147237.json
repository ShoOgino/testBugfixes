{"path":"src/java/org/apache/lucene/queryParser/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","commits":[{"id":"0107b7f49bcfde8f333685f53b37608815ca889b","date":1246908774,"type":0,"author":"Mark Harwood","isMerge":false,"pathNew":"src/java/org/apache/lucene/queryParser/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList sc = new ArrayList();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = (SpanQuery) sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList positiveClauses = new ArrayList();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = (SpanQuery[]) positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e2eb9920ac302f8d2a4cd14e42eba6935f84fe0d","de299b6017d29ce89b72c3ef9cfb99ca50d433cf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ee777f940c2d15973e2ef162012a94e09648ffa","date":1249272382,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"contrib/miscellaneous/src/java/org/apache/lucene/queryParser/complexPhrase/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/queryParser/ComplexPhraseQueryParser.ComplexPhraseQuery#rewrite(IndexReader).mjava","sourceNew":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList sc = new ArrayList();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = (SpanQuery) sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList positiveClauses = new ArrayList();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = (SpanQuery[]) positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","sourceOld":"    public Query rewrite(IndexReader reader) throws IOException {\n      // ArrayList spanClauses = new ArrayList();\n      if (contents instanceof TermQuery) {\n        return contents;\n      }\n      // Build a sequence of Span clauses arranged in a SpanNear - child\n      // clauses can be complex\n      // Booleans e.g. nots and ors etc\n      int numNegatives = 0;\n      if (!(contents instanceof BooleanQuery)) {\n        throw new IllegalArgumentException(\"Unknown query type \\\"\"\n            + contents.getClass().getName()\n            + \"\\\" found in phrase query string \\\"\" + phrasedQueryStringContents\n            + \"\\\"\");\n      }\n      BooleanQuery bq = (BooleanQuery) contents;\n      BooleanClause[] bclauses = bq.getClauses();\n      SpanQuery[] allSpanClauses = new SpanQuery[bclauses.length];\n      // For all clauses e.g. one* two~\n      for (int i = 0; i < bclauses.length; i++) {\n        // HashSet bclauseterms=new HashSet();\n        Query qc = bclauses[i].getQuery();\n        // Rewrite this clause e.g one* becomes (one OR onerous)\n        qc = qc.rewrite(reader);\n        if (bclauses[i].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          numNegatives++;\n        }\n\n        if (qc instanceof BooleanQuery) {\n          ArrayList sc = new ArrayList();\n          addComplexPhraseClause(sc, (BooleanQuery) qc);\n          if (sc.size() > 0) {\n            allSpanClauses[i] = (SpanQuery) sc.get(0);\n          } else {\n            // Insert fake term e.g. phrase query was for \"Fred Smithe*\" and\n            // there were no \"Smithe*\" terms - need to\n            // prevent match on just \"Fred\".\n            allSpanClauses[i] = new SpanTermQuery(new Term(field,\n                \"Dummy clause because no terms found - must match nothing\"));\n          }\n        } else {\n          if (qc instanceof TermQuery) {\n            TermQuery tq = (TermQuery) qc;\n            allSpanClauses[i] = new SpanTermQuery(tq.getTerm());\n          } else {\n            throw new IllegalArgumentException(\"Unknown query type \\\"\"\n                + qc.getClass().getName()\n                + \"\\\" found in phrase query string \\\"\"\n                + phrasedQueryStringContents + \"\\\"\");\n          }\n\n        }\n      }\n      if (numNegatives == 0) {\n        // The simple case - no negative elements in phrase\n        return new SpanNearQuery(allSpanClauses, slopFactor, true);\n      }\n      // Complex case - we have mixed positives and negatives in the\n      // sequence.\n      // Need to return a SpanNotQuery\n      ArrayList positiveClauses = new ArrayList();\n      for (int j = 0; j < allSpanClauses.length; j++) {\n        if (!bclauses[j].getOccur().equals(BooleanClause.Occur.MUST_NOT)) {\n          positiveClauses.add(allSpanClauses[j]);\n        }\n      }\n\n      SpanQuery[] includeClauses = (SpanQuery[]) positiveClauses\n          .toArray(new SpanQuery[positiveClauses.size()]);\n\n      SpanQuery include = null;\n      if (includeClauses.length == 1) {\n        include = includeClauses[0]; // only one positive clause\n      } else {\n        // need to increase slop factor based on gaps introduced by\n        // negatives\n        include = new SpanNearQuery(includeClauses, slopFactor + numNegatives,\n            true);\n      }\n      // Use sequence of positive and negative values as the exclude.\n      SpanNearQuery exclude = new SpanNearQuery(allSpanClauses, slopFactor,\n          true);\n      SpanNotQuery snot = new SpanNotQuery(include, exclude);\n      return snot;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0ee777f940c2d15973e2ef162012a94e09648ffa":["0107b7f49bcfde8f333685f53b37608815ca889b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0107b7f49bcfde8f333685f53b37608815ca889b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0ee777f940c2d15973e2ef162012a94e09648ffa"]},"commit2Childs":{"0ee777f940c2d15973e2ef162012a94e09648ffa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0107b7f49bcfde8f333685f53b37608815ca889b"],"0107b7f49bcfde8f333685f53b37608815ca889b":["0ee777f940c2d15973e2ef162012a94e09648ffa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}