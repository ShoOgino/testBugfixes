{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6620df8541b174097b1133a4fc370adb2e570524","date":1319544675,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      Bits liveDocs = reader.getLiveDocs();\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"96d207426bd26fa5c1014e26d21d87603aea68b7","date":1327944562,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final IndexReader reader = leaf.reader;\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    final AtomicReaderContext[] leaves = leafContexts;\n\n\n    for (int i=0; i<leaves.length; i++) {\n      final AtomicReaderContext leaf = leaves[i];\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195","date":1373388895,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceae51e37bbff02dcdeaa12303fec10d3eaaa004","date":1387382773,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":["d30c75558ec9c248a36d6e6768872ee9bed928a4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      collector.setNextReader(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          collector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          collector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final AtomicReaderContext leaf : leafContexts) {\n      final AtomicReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0","date":1442027674,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs(); // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries.\n   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.\n   * If the answer was not cached, it may have been inserted into the cache as a result of this call.\n   * This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if(queries != null) {\n      for(Query q : queries) {\n        if(q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid<max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if(collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":["d30c75558ec9c248a36d6e6768872ee9bed928a4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d30c75558ec9c248a36d6e6768872ee9bed928a4","date":1452963398,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      final Bits liveDocs = reader.getLiveDocs(); // TODO: the filter may already only have liveDocs...\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n          leafCollector.collect(docid);\n        }\n      }\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":["ae73da626f97850c922c42736f808d0378e165f0","ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3","date":1485881524,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return DocSetUtil.getDocSet(setCollector, this);\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return DocSetUtil.getDocSet(setCollector, this);\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return setCollector.getDocSet();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65bb42906a110f043122b3338eb5393db03e3706","date":1586291109,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * A null/empty list results in {@link #getLiveDocSet()}.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n\n    if (pf.postFilter == null) {\n      if (pf.answer != null) {\n        return pf.answer;\n      } else if (pf.filter == null) {\n        return getLiveDocSet(); // note: this is what happens when queries is an empty list\n      }\n    }\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return DocSetUtil.getDocSet(setCollector, this);\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n    if (pf.answer != null) return pf.answer;\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return DocSetUtil.getDocSet(setCollector, this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49731339ba07ef57ca4823faf0252a8b31dc33e2","date":1587256137,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(List[Query]).mjava","sourceNew":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * A null/empty list results in {@link #getLiveDocSet()}.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n\n    if (pf.postFilter == null) {\n      if (pf.answer != null) {\n        return pf.answer;\n      } else if (pf.filter == null) {\n        return getLiveDocSet(); // note: this is what happens when queries is an empty list\n      }\n    }\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    Query query = pf.filter != null ? pf.filter : matchAllDocsQuery;\n\n    search(query, collector);\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return DocSetUtil.getDocSet(setCollector, this);\n  }\n\n","sourceOld":"  /**\n   * Returns the set of document ids matching all queries. This method is cache-aware and attempts to retrieve the\n   * answer from the cache if possible. If the answer was not cached, it may have been inserted into the cache as a\n   * result of this call. This method can handle negative queries.\n   * A null/empty list results in {@link #getLiveDocSet()}.\n   * <p>\n   * The DocSet returned should <b>not</b> be modified.\n   */\n  public DocSet getDocSet(List<Query> queries) throws IOException {\n\n    if (queries != null) {\n      for (Query q : queries) {\n        if (q instanceof ScoreFilter) {\n          return getDocSetScore(queries);\n        }\n      }\n    }\n\n    ProcessedFilter pf = getProcessedFilter(null, queries);\n\n    if (pf.postFilter == null) {\n      if (pf.answer != null) {\n        return pf.answer;\n      } else if (pf.filter == null) {\n        return getLiveDocSet(); // note: this is what happens when queries is an empty list\n      }\n    }\n\n    DocSetCollector setCollector = new DocSetCollector(maxDoc());\n    Collector collector = setCollector;\n    if (pf.postFilter != null) {\n      pf.postFilter.setLastDelegate(collector);\n      collector = pf.postFilter;\n    }\n\n    for (final LeafReaderContext leaf : leafContexts) {\n      final LeafReader reader = leaf.reader();\n      Bits liveDocs = reader.getLiveDocs();\n      DocIdSet idSet = null;\n      if (pf.filter != null) {\n        idSet = pf.filter.getDocIdSet(leaf, liveDocs);\n        if (idSet == null) continue;\n      }\n      DocIdSetIterator idIter = null;\n      if (idSet != null) {\n        idIter = idSet.iterator();\n        if (idIter == null) continue;\n        if (!pf.hasDeletedDocs) liveDocs = null; // no need to check liveDocs\n      }\n\n      final LeafCollector leafCollector = collector.getLeafCollector(leaf);\n      int max = reader.maxDoc();\n\n      if (idIter == null) {\n        for (int docid = 0; docid < max; docid++) {\n          if (liveDocs != null && !liveDocs.get(docid)) continue;\n          leafCollector.collect(docid);\n        }\n      } else {\n        if (liveDocs != null) {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max; ) {\n            if (liveDocs.get(docid))\n              leafCollector.collect(docid);\n          }\n        } else {\n          for (int docid = -1; (docid = idIter.advance(docid + 1)) < max;) {\n            leafCollector.collect(docid);\n          }\n        }\n      }\n\n    }\n\n    if (collector instanceof DelegatingCollector) {\n      ((DelegatingCollector) collector).finish();\n    }\n\n    return DocSetUtil.getDocSet(setCollector, this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6620df8541b174097b1133a4fc370adb2e570524":["c26f00b574427b55127e869b935845554afde1fa"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"65bb42906a110f043122b3338eb5393db03e3706":["0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["6620df8541b174097b1133a4fc370adb2e570524"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["d30c75558ec9c248a36d6e6768872ee9bed928a4","0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3"],"d30c75558ec9c248a36d6e6768872ee9bed928a4":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3":["d30c75558ec9c248a36d6e6768872ee9bed928a4"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["ae73da626f97850c922c42736f808d0378e165f0"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["6620df8541b174097b1133a4fc370adb2e570524","96d207426bd26fa5c1014e26d21d87603aea68b7"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["ceae51e37bbff02dcdeaa12303fec10d3eaaa004","ae73da626f97850c922c42736f808d0378e165f0"],"49731339ba07ef57ca4823faf0252a8b31dc33e2":["65bb42906a110f043122b3338eb5393db03e3706"],"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ae73da626f97850c922c42736f808d0378e165f0":["ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["c75ea0343a1ac7ea10bf4790c190f96b2c7b1195","ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ceae51e37bbff02dcdeaa12303fec10d3eaaa004":["c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["49731339ba07ef57ca4823faf0252a8b31dc33e2"]},"commit2Childs":{"6620df8541b174097b1133a4fc370adb2e570524":["96d207426bd26fa5c1014e26d21d87603aea68b7","5cab9a86bd67202d20b6adc463008c8e982b070a"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"c26f00b574427b55127e869b935845554afde1fa":["6620df8541b174097b1133a4fc370adb2e570524"],"65bb42906a110f043122b3338eb5393db03e3706":["49731339ba07ef57ca4823faf0252a8b31dc33e2"],"96d207426bd26fa5c1014e26d21d87603aea68b7":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"d30c75558ec9c248a36d6e6768872ee9bed928a4":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"0cb5245d4a5c7ba59bbfdedb7ace8a9fbd36ada3":["65bb42906a110f043122b3338eb5393db03e3706","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["d30c75558ec9c248a36d6e6768872ee9bed928a4"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195":["37a0f60745e53927c4c876cfe5b5a58170f0646c","74f45af4339b0daf7a95c820ab88c1aea74fbce0","ceae51e37bbff02dcdeaa12303fec10d3eaaa004"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"49731339ba07ef57ca4823faf0252a8b31dc33e2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ae73da626f97850c922c42736f808d0378e165f0":["c9fb5f46e264daf5ba3860defe623a89d202dd87","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ceae51e37bbff02dcdeaa12303fec10d3eaaa004":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","15e323346eac5e4685c0a9f2df85eb96b4239bbb","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}