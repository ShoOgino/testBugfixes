{"path":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","commits":[{"id":"77cae179618908dcb534af567cdf3019505ada6c","date":1449365361,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(SolrIndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? NumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(SolrIndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      Terms versionTerms = searcher.getLeafReader().terms(versionFieldName);\n      Long max = (versionTerms != null) ? NumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? NumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":["1248476067f7f652e875bd77a9a3faeecde50430"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d62172dd2fc1195c7e475550ac394a9948a18ae","date":1474974102,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":["1248476067f7f652e875bd77a9a3faeecde50430"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.info(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.info(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.info(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1248476067f7f652e875bd77a9a3faeecde50430","date":1497567228,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":["7049ad12744e132ed475c4ad0e547cecc4ef0053","773a737806859660d4756f710adc0ad53e05f9d5","77cae179618908dcb534af567cdf3019505ada6c","770342641f7b505eaa8dccdc666158bff2419109","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    long maxVersionInIndex = 0L;\n\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      LeafReader leafReader = SlowCompositeReaderWrapper.wrap(searcher.getIndexReader());\n      Terms versionTerms = leafReader.terms(versionFieldName);\n      Long max = (versionTerms != null) ? LegacyNumericUtils.getMaxLong(versionTerms) : null;\n      if (max != null) {\n        maxVersionInIndex = max.longValue();\n        log.debug(\"Found MAX value {} from Terms for {} in index\", maxVersionInIndex, versionFieldName);\n      } else {\n        log.debug(\"No terms found for {}, cannot seed version bucket highest value from index\", versionFieldName);\n      }\n    } else {\n      ValueSource vs = versionField.getType().getValueSource(versionField, null);\n      Map funcContext = ValueSource.newContext(searcher);\n      vs.createWeight(funcContext, searcher);\n      // TODO: multi-thread this\n      for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n        int maxDoc = ctx.reader().maxDoc();\n        FunctionValues fv = vs.getValues(funcContext, ctx);\n        for (int doc = 0; doc < maxDoc; doc++) {\n          long v = fv.longVal(doc);\n          maxVersionInIndex = Math.max(v, maxVersionInIndex);\n        }\n      }\n    }\n\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    @SuppressWarnings({\"rawtypes\"})\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/VersionInfo#getMaxVersionFromIndex(IndexSearcher).mjava","sourceNew":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    @SuppressWarnings({\"rawtypes\"})\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","sourceOld":"  /**\n   * Returns the highest version from the index, or 0L if no versions can be found in the index.\n   */\n  public Long getMaxVersionFromIndex(IndexSearcher searcher) throws IOException {\n\n    final String versionFieldName = versionField.getName();\n\n    log.debug(\"Refreshing highest value of {} for {} version buckets from index\", versionFieldName, buckets.length);\n    // if indexed, then we have terms to get the max from\n    if (versionField.indexed()) {\n      if (versionField.getType().isPointField()) {\n        return getMaxVersionFromIndexedPoints(searcher);\n      } else {\n        return getMaxVersionFromIndexedTerms(searcher);\n      }\n    }\n    // else: not indexed, use docvalues via value source ...\n    \n    long maxVersionInIndex = 0L;\n    ValueSource vs = versionField.getType().getValueSource(versionField, null);\n    @SuppressWarnings({\"rawtypes\"})\n    Map funcContext = ValueSource.newContext(searcher);\n    vs.createWeight(funcContext, searcher);\n    // TODO: multi-thread this\n    for (LeafReaderContext ctx : searcher.getTopReaderContext().leaves()) {\n      int maxDoc = ctx.reader().maxDoc();\n      FunctionValues fv = vs.getValues(funcContext, ctx);\n      for (int doc = 0; doc < maxDoc; doc++) {\n        long v = fv.longVal(doc);\n        maxVersionInIndex = Math.max(v, maxVersionInIndex);\n      }\n    }\n    return maxVersionInIndex;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"77cae179618908dcb534af567cdf3019505ada6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","415bbbe7da8065dd3c477bdc3c703c6425622998"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["28288370235ed02234a64753cdbf0c6ec096304a"],"1248476067f7f652e875bd77a9a3faeecde50430":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["770342641f7b505eaa8dccdc666158bff2419109"],"770342641f7b505eaa8dccdc666158bff2419109":["77cae179618908dcb534af567cdf3019505ada6c"],"28288370235ed02234a64753cdbf0c6ec096304a":["415bbbe7da8065dd3c477bdc3c703c6425622998","1248476067f7f652e875bd77a9a3faeecde50430"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["770342641f7b505eaa8dccdc666158bff2419109","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["770342641f7b505eaa8dccdc666158bff2419109","0d62172dd2fc1195c7e475550ac394a9948a18ae"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["415bbbe7da8065dd3c477bdc3c703c6425622998","1248476067f7f652e875bd77a9a3faeecde50430"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","1248476067f7f652e875bd77a9a3faeecde50430","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"77cae179618908dcb534af567cdf3019505ada6c":["770342641f7b505eaa8dccdc666158bff2419109"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"1248476067f7f652e875bd77a9a3faeecde50430":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"0d62172dd2fc1195c7e475550ac394a9948a18ae":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["598b5d23aa7c9732bf473c21a9cd309c44599394"],"28288370235ed02234a64753cdbf0c6ec096304a":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"770342641f7b505eaa8dccdc666158bff2419109":["0d62172dd2fc1195c7e475550ac394a9948a18ae","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["415bbbe7da8065dd3c477bdc3c703c6425622998","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["77cae179618908dcb534af567cdf3019505ada6c"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}