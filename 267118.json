{"path":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","commits":[{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","pathOld":"/dev/null","sourceNew":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  public void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eeefd99c477417e5c7c574228461ebafe92469d4","date":1166460329,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","sourceNew":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  public void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            } else if (\"cfs\".equals(extension) && !info.getUseCompoundFile()) {\n              // This is a partially written\n              // _segmentName.cfs:\n              doDelete = true;\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  public void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65fde38a949fadb9cf6008bc632c72c2ada2393d","date":1170531935,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","sourceNew":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            } else if (\"cfs\".equals(extension) && !info.getUseCompoundFile()) {\n              // This is a partially written\n              // _segmentName.cfs:\n              doDelete = true;\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  public void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            } else if (\"cfs\".equals(extension) && !info.getUseCompoundFile()) {\n              // This is a partially written\n              // _segmentName.cfs:\n              doDelete = true;\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051","date":1173376751,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","sourceNew":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            } else if (\"cfs\".equals(extension) && !info.getUseCompoundFile()) {\n              // This is a partially written\n              // _segmentName.cfs:\n              doDelete = true;\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            } else if (\"cfs\".equals(extension) && !info.getUseCompoundFile()) {\n              // This is a partially written\n              // _segmentName.cfs:\n              doDelete = true;\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexFileDeleter#findDeletableFiles().mjava","sourceNew":null,"sourceOld":"  /** Determine index files that are no longer referenced\n   * and therefore should be deleted.  This is called once\n   * (by the writer), and then subsequently we add onto\n   * deletable any files that are no longer needed at the\n   * point that we create the unused file (eg when merging\n   * segments), and we only remove from deletable when a\n   * file is successfully deleted.\n   */\n\n  void findDeletableFiles() throws IOException {\n\n    // Gather all \"current\" segments:\n    HashMap current = new HashMap();\n    for(int j=0;j<segmentInfos.size();j++) {\n      SegmentInfo segmentInfo = (SegmentInfo) segmentInfos.elementAt(j);\n      current.put(segmentInfo.name, segmentInfo);\n    }\n\n    // Then go through all files in the Directory that are\n    // Lucene index files, and add to deletable if they are\n    // not referenced by the current segments info:\n\n    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();\n    IndexFileNameFilter filter = IndexFileNameFilter.getFilter();\n\n    String[] files = directory.list();\n    if (files == null)\n      throw new IOException(\"cannot read directory \" + directory + \": list() returned null\");\n\n    for (int i = 0; i < files.length; i++) {\n\n      if (filter.accept(null, files[i]) && !files[i].equals(segmentsInfosFileName) && !files[i].equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        String segmentName;\n        String extension;\n\n        // First remove any extension:\n        int loc = files[i].indexOf('.');\n        if (loc != -1) {\n          extension = files[i].substring(1+loc);\n          segmentName = files[i].substring(0, loc);\n        } else {\n          extension = null;\n          segmentName = files[i];\n        }\n\n        // Then, remove any generation count:\n        loc = segmentName.indexOf('_', 1);\n        if (loc != -1) {\n          segmentName = segmentName.substring(0, loc);\n        }\n\n        // Delete this file if it's not a \"current\" segment,\n        // or, it is a single index file but there is now a\n        // corresponding compound file:\n        boolean doDelete = false;\n\n        if (!current.containsKey(segmentName)) {\n          // Delete if segment is not referenced:\n          doDelete = true;\n        } else {\n          // OK, segment is referenced, but file may still\n          // be orphan'd:\n          SegmentInfo info = (SegmentInfo) current.get(segmentName);\n\n          if (filter.isCFSFile(files[i]) && info.getUseCompoundFile()) {\n            // This file is in fact stored in a CFS file for\n            // this segment:\n            doDelete = true;\n          } else {\n            \n            if (\"del\".equals(extension)) {\n              // This is a _segmentName_N.del file:\n              if (!files[i].equals(info.getDelFileName())) {\n                // If this is a seperate .del file, but it\n                // doesn't match the current del filename for\n                // this segment, then delete it:\n                doDelete = true;\n              }\n            } else if (extension != null && extension.startsWith(\"s\") && extension.matches(\"s\\\\d+\")) {\n              int field = Integer.parseInt(extension.substring(1));\n              // This is a _segmentName_N.sX file:\n              if (!files[i].equals(info.getNormFileName(field))) {\n                // This is an orphan'd separate norms file:\n                doDelete = true;\n              }\n            } else if (\"cfs\".equals(extension) && !info.getUseCompoundFile()) {\n              // This is a partially written\n              // _segmentName.cfs:\n              doDelete = true;\n            }\n          }\n        }\n\n        if (doDelete) {\n          addDeletableFile(files[i]);\n          if (infoStream != null) {\n            infoStream.println(\"IndexFileDeleter: file \\\"\" + files[i] + \"\\\" is unreferenced in index and will be deleted on next commit\");\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"eeefd99c477417e5c7c574228461ebafe92469d4":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051":["65fde38a949fadb9cf6008bc632c72c2ada2393d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"65fde38a949fadb9cf6008bc632c72c2ada2393d":["eeefd99c477417e5c7c574228461ebafe92469d4"],"8b6187898fc4413ccd18229711786550a280383c":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b6187898fc4413ccd18229711786550a280383c"]},"commit2Childs":{"eeefd99c477417e5c7c574228461ebafe92469d4":["65fde38a949fadb9cf6008bc632c72c2ada2393d"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["eeefd99c477417e5c7c574228461ebafe92469d4"],"daaba12f8cbc8a402310a4c4d0ee3fe71f67b051":["8b6187898fc4413ccd18229711786550a280383c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"65fde38a949fadb9cf6008bc632c72c2ada2393d":["daaba12f8cbc8a402310a4c4d0ee3fe71f67b051"],"8b6187898fc4413ccd18229711786550a280383c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}