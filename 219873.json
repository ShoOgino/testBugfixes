{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","commits":[{"id":"f6b1e64caa933f6fb3c0494afd6ca2597f55cc91","date":1470238980,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(\"id\", featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(\"id\", featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(\"id\", featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(ID, featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(\"id\", featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(ID, featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(\"id\", featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Tuple tuple = new Tuple();\n          tuple.put(ID, featureSet + \"_\" + index);\n          tuple.put(\"index_i\", index);\n          tuple.put(\"term_s\", termScore.getKey());\n          tuple.put(\"score_f\", termScore.getValue());\n          tuple.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          tuple.put(\"idf_d\", d);\n          tuples.add(tuple);\n        }\n\n        tuples.add(Tuple.EOF());\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Map map = new HashMap();\n          map.put(ID, featureSet + \"_\" + index);\n          map.put(\"index_i\", index);\n          map.put(\"term_s\", termScore.getKey());\n          map.put(\"score_f\", termScore.getValue());\n          map.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          map.put(\"idf_d\", d);\n          tuples.add(new Tuple(map));\n        }\n\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        tuples.add(new Tuple(map));\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75","date":1591744896,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/FeaturesSelectionStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (@SuppressWarnings({\"rawtypes\"})Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          @SuppressWarnings({\"rawtypes\"})\n          NamedList resp = getTopTermsCall.get();\n\n          @SuppressWarnings({\"unchecked\"})\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          @SuppressWarnings({\"unchecked\"})\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Tuple tuple = new Tuple();\n          tuple.put(ID, featureSet + \"_\" + index);\n          tuple.put(\"index_i\", index);\n          tuple.put(\"term_s\", termScore.getKey());\n          tuple.put(\"score_f\", termScore.getValue());\n          tuple.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          tuple.put(\"idf_d\", d);\n          tuples.add(tuple);\n        }\n\n        tuples.add(Tuple.EOF());\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n      if (tupleIterator == null) {\n        Map<String, Double> termScores = new HashMap<>();\n        Map<String, Long> docFreqs = new HashMap<>();\n\n\n        long numDocs = 0;\n        for (Future<NamedList> getTopTermsCall : callShards(getShardUrls())) {\n          NamedList resp = getTopTermsCall.get();\n\n          NamedList<Double> shardTopTerms = (NamedList<Double>)resp.get(\"featuredTerms\");\n          NamedList<Integer> shardDocFreqs = (NamedList<Integer>)resp.get(\"docFreq\");\n\n          numDocs += (Integer)resp.get(\"numDocs\");\n\n          for (int i = 0; i < shardTopTerms.size(); i++) {\n            String term = shardTopTerms.getName(i);\n            double score = shardTopTerms.getVal(i);\n            int docFreq = shardDocFreqs.get(term);\n            double prevScore = termScores.containsKey(term) ? termScores.get(term) : 0;\n            long prevDocFreq = docFreqs.containsKey(term) ? docFreqs.get(term) : 0;\n            termScores.put(term, prevScore + score);\n            docFreqs.put(term, prevDocFreq + docFreq);\n\n          }\n        }\n\n        List<Tuple> tuples = new ArrayList<>(numTerms);\n        termScores = sortByValue(termScores);\n        int index = 0;\n        for (Map.Entry<String, Double> termScore : termScores.entrySet()) {\n          if (tuples.size() == numTerms) break;\n          index++;\n          Tuple tuple = new Tuple();\n          tuple.put(ID, featureSet + \"_\" + index);\n          tuple.put(\"index_i\", index);\n          tuple.put(\"term_s\", termScore.getKey());\n          tuple.put(\"score_f\", termScore.getValue());\n          tuple.put(\"featureSet_s\", featureSet);\n          long docFreq = docFreqs.get(termScore.getKey());\n          double d = Math.log(((double)numDocs / (double)(docFreq + 1)));\n          tuple.put(\"idf_d\", d);\n          tuples.add(tuple);\n        }\n\n        tuples.add(Tuple.EOF());\n\n        tupleIterator = tuples.iterator();\n      }\n\n      return tupleIterator.next();\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e5fa6615014cd2288fe930f8c8bb726f9504961d":["f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"f6b1e64caa933f6fb3c0494afd6ca2597f55cc91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"804a8d5358fe7b7563b85ee7838714d720b89272":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"]},"commit2Childs":{"e5fa6615014cd2288fe930f8c8bb726f9504961d":[],"f6b1e64caa933f6fb3c0494afd6ca2597f55cc91":["e5fa6615014cd2288fe930f8c8bb726f9504961d","6d2dadc1f5ca8703d8659f4964961f9967935d75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f6b1e64caa933f6fb3c0494afd6ca2597f55cc91","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"804a8d5358fe7b7563b85ee7838714d720b89272":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e5fa6615014cd2288fe930f8c8bb726f9504961d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}