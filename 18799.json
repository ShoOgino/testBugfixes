{"path":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,String).mjava","commits":[{"id":"b11b097f011a298f1a54676482032c2b261e26f3","date":1411698138,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeString String}.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  // nocommit: fix javadocs, add segmentLength()\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, String segmentID) throws IOException {\n    writeHeader(out, codec, version);\n    // nocommit: improve encoding of this ID\n    out.writeString(segmentID);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/CodecUtil#writeSegmentHeader(DataOutput,String,int,String).mjava","sourceNew":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or \n   *         is more than 127 characters in length, or if segmentID is invalid.\n   */\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {\n    if (segmentID.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"Invalid id: \" + StringHelper.idToString(segmentID));\n    }\n    writeHeader(out, codec, version);\n    out.writeBytes(segmentID, 0, segmentID.length);\n  }\n\n","sourceOld":"  /**\n   * Writes a codec header for a per-segment, which records both a string to\n   * identify the file, a version number, and the unique ID of the segment. \n   * This header can be parsed and validated with \n   * {@link #checkSegmentHeader(DataInput, String, int, int, String) checkSegmentHeader()}.\n   * <p>\n   * CodecSegmentHeader --&gt; CodecHeader,SegmentID\n   * <ul>\n   *    <li>CodecHeader --&gt; {@link #writeHeader}\n   *    <li>SegmentID   --&gt; {@link DataOutput#writeString String}.\n   *        Unique identifier for the segment.\n   * </ul>\n   * <p>\n   * Note that the length of a segment header depends only upon the\n   * name of the codec, so this length can be computed at any time\n   * with {@link #headerLength(String)}.\n   * \n   * @param out Output stream\n   * @param codec String to identify this file. It should be simple ASCII, \n   *              less than 128 characters in length.\n   * @param segmentID Unique identifier for the segment\n   * @param version Version number\n   * @throws IOException If there is an I/O error writing to the underlying medium.\n   * @throws IllegalArgumentException If the codec name is not simple ASCII, or is more than 127 characters in length\n   */\n  // nocommit: fix javadocs, add segmentLength()\n  public static void writeSegmentHeader(DataOutput out, String codec, int version, String segmentID) throws IOException {\n    writeHeader(out, codec, version);\n    // nocommit: improve encoding of this ID\n    out.writeString(segmentID);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["b11b097f011a298f1a54676482032c2b261e26f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b11b097f011a298f1a54676482032c2b261e26f3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b11b097f011a298f1a54676482032c2b261e26f3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b11b097f011a298f1a54676482032c2b261e26f3":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}