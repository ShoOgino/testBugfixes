{"path":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#readLine().mjava","commits":[{"id":"80931fa1f3b04650bde7b20e61b02063a7093ced","date":1333130683,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#readLine().mjava","pathOld":"/dev/null","sourceNew":" /**\n  * @return A String containing the contents of the line, not \n  *         including any line-termination characters, or null \n  *         if the end of the stream has been reached\n  */\n  public String readLine() throws IOException {\n    \n    if (lookaheadChar == UNDEFINED) {\n      lookaheadChar = super.read(); \n    }\n    \n    line.clear(); //reuse\n    \n    // return null if end of stream has been reached\n    if (lookaheadChar == END_OF_STREAM) {\n      return null;\n    }\n    // do we have a line termination already\n    char laChar = (char) lookaheadChar;\n    if (laChar == '\\n' || laChar == '\\r') {\n      lastChar = lookaheadChar;\n      lookaheadChar = super.read();\n      // ignore '\\r\\n' as well\n      if ((char) lookaheadChar == '\\n') {\n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n      }\n      lineCounter++;\n      return line.toString();\n    }\n    \n    // create the rest-of-line return and update the lookahead\n    line.append(laChar);\n    String restOfLine = super.readLine(); // TODO involves copying\n    lastChar = lookaheadChar;\n    lookaheadChar = super.read();\n    if (restOfLine != null) {\n      line.append(restOfLine);\n    }\n    lineCounter++;\n    return line.toString();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#readLine().mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#readLine().mjava","sourceNew":" /**\n  * @return A String containing the contents of the line, not \n  *         including any line-termination characters, or null \n  *         if the end of the stream has been reached\n  */\n  @Override\n  public String readLine() throws IOException {\n    \n    if (lookaheadChar == UNDEFINED) {\n      lookaheadChar = super.read(); \n    }\n    \n    line.clear(); //reuse\n    \n    // return null if end of stream has been reached\n    if (lookaheadChar == END_OF_STREAM) {\n      return null;\n    }\n    // do we have a line termination already\n    char laChar = (char) lookaheadChar;\n    if (laChar == '\\n' || laChar == '\\r') {\n      lastChar = lookaheadChar;\n      lookaheadChar = super.read();\n      // ignore '\\r\\n' as well\n      if ((char) lookaheadChar == '\\n') {\n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n      }\n      lineCounter++;\n      return line.toString();\n    }\n    \n    // create the rest-of-line return and update the lookahead\n    line.append(laChar);\n    String restOfLine = super.readLine(); // TODO involves copying\n    lastChar = lookaheadChar;\n    lookaheadChar = super.read();\n    if (restOfLine != null) {\n      line.append(restOfLine);\n    }\n    lineCounter++;\n    return line.toString();\n  }\n\n","sourceOld":" /**\n  * @return A String containing the contents of the line, not \n  *         including any line-termination characters, or null \n  *         if the end of the stream has been reached\n  */\n  public String readLine() throws IOException {\n    \n    if (lookaheadChar == UNDEFINED) {\n      lookaheadChar = super.read(); \n    }\n    \n    line.clear(); //reuse\n    \n    // return null if end of stream has been reached\n    if (lookaheadChar == END_OF_STREAM) {\n      return null;\n    }\n    // do we have a line termination already\n    char laChar = (char) lookaheadChar;\n    if (laChar == '\\n' || laChar == '\\r') {\n      lastChar = lookaheadChar;\n      lookaheadChar = super.read();\n      // ignore '\\r\\n' as well\n      if ((char) lookaheadChar == '\\n') {\n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n      }\n      lineCounter++;\n      return line.toString();\n    }\n    \n    // create the rest-of-line return and update the lookahead\n    line.append(laChar);\n    String restOfLine = super.readLine(); // TODO involves copying\n    lastChar = lookaheadChar;\n    lookaheadChar = super.read();\n    if (restOfLine != null) {\n      line.append(restOfLine);\n    }\n    lineCounter++;\n    return line.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#readLine().mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#readLine().mjava","sourceNew":" /**\n  * @return A String containing the contents of the line, not \n  *         including any line-termination characters, or null \n  *         if the end of the stream has been reached\n  */\n  @Override\n  public String readLine() throws IOException {\n    \n    if (lookaheadChar == UNDEFINED) {\n      lookaheadChar = super.read(); \n    }\n    \n    line.clear(); //reuse\n    \n    // return null if end of stream has been reached\n    if (lookaheadChar == END_OF_STREAM) {\n      return null;\n    }\n    // do we have a line termination already\n    char laChar = (char) lookaheadChar;\n    if (laChar == '\\n' || laChar == '\\r') {\n      lastChar = lookaheadChar;\n      lookaheadChar = super.read();\n      // ignore '\\r\\n' as well\n      if ((char) lookaheadChar == '\\n') {\n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n      }\n      lineCounter++;\n      return line.toString();\n    }\n    \n    // create the rest-of-line return and update the lookahead\n    line.append(laChar);\n    String restOfLine = super.readLine(); // TODO involves copying\n    lastChar = lookaheadChar;\n    lookaheadChar = super.read();\n    if (restOfLine != null) {\n      line.append(restOfLine);\n    }\n    lineCounter++;\n    return line.toString();\n  }\n\n","sourceOld":" /**\n  * @return A String containing the contents of the line, not \n  *         including any line-termination characters, or null \n  *         if the end of the stream has been reached\n  */\n  public String readLine() throws IOException {\n    \n    if (lookaheadChar == UNDEFINED) {\n      lookaheadChar = super.read(); \n    }\n    \n    line.clear(); //reuse\n    \n    // return null if end of stream has been reached\n    if (lookaheadChar == END_OF_STREAM) {\n      return null;\n    }\n    // do we have a line termination already\n    char laChar = (char) lookaheadChar;\n    if (laChar == '\\n' || laChar == '\\r') {\n      lastChar = lookaheadChar;\n      lookaheadChar = super.read();\n      // ignore '\\r\\n' as well\n      if ((char) lookaheadChar == '\\n') {\n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n      }\n      lineCounter++;\n      return line.toString();\n    }\n    \n    // create the rest-of-line return and update the lookahead\n    line.append(laChar);\n    String restOfLine = super.readLine(); // TODO involves copying\n    lastChar = lookaheadChar;\n    lookaheadChar = super.read();\n    if (restOfLine != null) {\n      line.append(restOfLine);\n    }\n    lineCounter++;\n    return line.toString();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["80931fa1f3b04650bde7b20e61b02063a7093ced","7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80931fa1f3b04650bde7b20e61b02063a7093ced":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["80931fa1f3b04650bde7b20e61b02063a7093ced"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80931fa1f3b04650bde7b20e61b02063a7093ced"],"80931fa1f3b04650bde7b20e61b02063a7093ced":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}