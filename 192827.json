{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiSessionsCache().mjava","commits":[{"id":"e17627eb9673daf01d17fdfb583c621c55c34208","date":1593028963,"type":0,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiSessionsCache().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testMultiSessionsCache() throws IOException, InterruptedException {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Map<String, Map> nodeValues = (Map<String, Map>) Utils.fromJSONString(\" {\" +\n        \"    'node1':{ 'node':'10.0.0.4:8987_solr', 'cores':1 },\" +\n        \"    'node2':{ 'node':'10.0.0.4:8989_solr', 'cores':1 },\" +\n        \"    'node3':{ 'node':'10.0.0.4:7574_solr', 'cores':1 }\" +\n        \"}\");\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map policies = (Map) Utils.fromJSONString(\"{ 'cluster-preferences': [{ 'minimize': 'cores', 'precision': 1}]}\");\n\n    @SuppressWarnings({\"unchecked\"})\n    AutoScalingConfig config = new AutoScalingConfig(policies);\n    final SolrCloudManager solrCloudManager = new DelegatingCloudManager(getSolrCloudManager(nodeValues, clusterState)) {\n      @Override\n      public DistribStateManager getDistribStateManager() {\n        return delegatingDistribStateManager(config);\n      }\n    };\n\n    PolicyHelper.SessionWrapper s1 = PolicyHelper.getSession(solrCloudManager);\n    // Must skip the wait time otherwise test takes a few seconds to run (and s1 is not returned now anyway so no point waiting).\n    PolicyHelper.SessionWrapper s2 = PolicyHelper.getSession(solrCloudManager, false);\n    // Got two sessions, they are different\n    assertNotSame(s1, s2);\n\n    // Done COMPUTING with first session, it can be reused\n    s1.returnSession(s1.get());\n\n    PolicyHelper.SessionWrapper s3 = PolicyHelper.getSession(solrCloudManager);\n    // First session indeed reused when a new session is requested\n    assertSame(s3, s1);\n\n    // Done COMPUTING with second session, it can be reused\n    s2.returnSession(s2.get());\n\n    PolicyHelper.SessionWrapper s4 = PolicyHelper.getSession(solrCloudManager);\n    // Second session indeed reused when a new session is requested\n    assertSame(s4, s2);\n\n    s4.returnSession(s4.get());\n    s4.release();\n\n    s2.release();\n\n    s3.returnSession(s3.get());\n    s3.release();\n\n    PolicyHelper.SessionRef sessionRef = (PolicyHelper.SessionRef) solrCloudManager.getObjectCache().get(PolicyHelper.SessionRef.class.getName());\n\n    // First session not yet released so is still in the cache\n    assertFalse(sessionRef.isEmpty());\n\n    s1.release();\n\n    assertTrue(sessionRef.isEmpty());\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/cloud/autoscaling/TestPolicy#testMultiSessionsCache().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testMultiSessionsCache() throws IOException, InterruptedException {\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    Map<String, Map> nodeValues = (Map<String, Map>) Utils.fromJSONString(\" {\" +\n        \"    'node1':{ 'node':'10.0.0.4:8987_solr', 'cores':1 },\" +\n        \"    'node2':{ 'node':'10.0.0.4:8989_solr', 'cores':1 },\" +\n        \"    'node3':{ 'node':'10.0.0.4:7574_solr', 'cores':1 }\" +\n        \"}\");\n\n    @SuppressWarnings({\"rawtypes\"})\n    Map policies = (Map) Utils.fromJSONString(\"{ 'cluster-preferences': [{ 'minimize': 'cores', 'precision': 1}]}\");\n\n    @SuppressWarnings({\"unchecked\"})\n    AutoScalingConfig config = new AutoScalingConfig(policies);\n    final SolrCloudManager solrCloudManager = new DelegatingCloudManager(getSolrCloudManager(nodeValues, clusterState)) {\n      @Override\n      public DistribStateManager getDistribStateManager() {\n        return delegatingDistribStateManager(config);\n      }\n    };\n\n    PolicyHelper.SessionWrapper s1 = PolicyHelper.getSession(solrCloudManager);\n    // Must skip the wait time otherwise test takes a few seconds to run (and s1 is not returned now anyway so no point waiting).\n    PolicyHelper.SessionWrapper s2 = PolicyHelper.getSession(solrCloudManager, false);\n    // Got two sessions, they are different\n    assertNotSame(s1, s2);\n\n    // Done COMPUTING with first session, it can be reused\n    s1.returnSession(s1.get());\n\n    PolicyHelper.SessionWrapper s3 = PolicyHelper.getSession(solrCloudManager);\n    // First session indeed reused when a new session is requested\n    assertSame(s3, s1);\n\n    // Done COMPUTING with second session, it can be reused\n    s2.returnSession(s2.get());\n\n    PolicyHelper.SessionWrapper s4 = PolicyHelper.getSession(solrCloudManager);\n    // Second session indeed reused when a new session is requested\n    assertSame(s4, s2);\n\n    s4.returnSession(s4.get());\n    s4.release();\n\n    s2.release();\n\n    s3.returnSession(s3.get());\n    s3.release();\n\n    PolicyHelper.SessionRef sessionRef = (PolicyHelper.SessionRef) solrCloudManager.getObjectCache().get(PolicyHelper.SessionRef.class.getName());\n\n    // First session not yet released so is still in the cache\n    assertFalse(sessionRef.isEmpty());\n\n    s1.release();\n\n    assertTrue(sessionRef.isEmpty());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e17627eb9673daf01d17fdfb583c621c55c34208":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3f504512a03d978990cbff30db0522b354e846db":["e17627eb9673daf01d17fdfb583c621c55c34208"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"]},"commit2Childs":{"e17627eb9673daf01d17fdfb583c621c55c34208":["3f504512a03d978990cbff30db0522b354e846db"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e17627eb9673daf01d17fdfb583c621c55c34208"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}