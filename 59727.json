{"path":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","commits":[{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    cluster.getSolrClient().getZkStateReader().registerCore(collectionName); //TODO: Why is this needed? see SOLR-9440 \n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    cluster.getSolrClient().getZkStateReader().registerCore(collectionName); //TODO: Why is this needed? see SOLR-9440 \n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4","date":1509452916,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    cluster.getSolrClient().getZkStateReader().registerCore(collectionName); //TODO: Why is this needed? see SOLR-9440 \n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94","date":1520143025,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.stop();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      ChaosMonkey.kill(leaderJetty);\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      ChaosMonkey.start(leaderJetty);\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":["61c45e99cf6676da48f19d7511c73712ad39402b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4dcbadb1ffa7882d470040d12698396c35abbf5a","date":1550726129,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.stop();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n\n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n\n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName,\n          \"shard1\",\n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\",\n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n\n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () ->\n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () ->\n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n\n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n    \n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    \n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    \n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName, \n          \"shard1\", \n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\", \n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n    \n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n    \n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () -> \n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () -> \n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n    \n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n    \n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  @SuppressWarnings({\"try\"})\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n\n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n\n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName,\n          \"shard1\",\n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\",\n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n\n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () ->\n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () ->\n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n\n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n\n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n\n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName,\n          \"shard1\",\n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\",\n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n\n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () ->\n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () ->\n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n\n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestPullReplica#doTestNoLeader(boolean).mjava","sourceNew":"  /*\n   * validate that replication still happens on a new leader\n   */\n  @SuppressWarnings({\"try\"})\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n\n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n\n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName,\n          \"shard1\",\n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\",\n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n\n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () ->\n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () ->\n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n\n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","sourceOld":"  /*\n   * validate that replication still happens on a new leader\n   */\n  @SuppressWarnings({\"try\"})\n  private void doTestNoLeader(boolean removeReplica) throws Exception {\n    CollectionAdminRequest.createCollection(collectionName, \"conf\", 1, 1, 0, 1)\n      .setMaxShardsPerNode(100)\n      .process(cluster.getSolrClient());\n    waitForState(\"Expected collection to be created with 1 shard and 2 replicas\", collectionName, clusterShape(1, 2));\n    DocCollection docCollection = assertNumberOfReplicas(1, 0, 1, false, true);\n\n    // Add a document and commit\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"1\", \"foo\", \"bar\"));\n    cluster.getSolrClient().commit(collectionName);\n    Slice s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n\n    // Delete leader replica from shard1\n    ignoreException(\"No registered leader was found\"); //These are expected\n    JettySolrRunner leaderJetty = null;\n    if (removeReplica) {\n      CollectionAdminRequest.deleteReplica(\n          collectionName,\n          \"shard1\",\n          s.getLeader().getName())\n      .process(cluster.getSolrClient());\n    } else {\n      leaderJetty = cluster.getReplicaJetty(s.getLeader());\n      leaderJetty.stop();\n      waitForState(\"Leader replica not removed\", collectionName, clusterShape(1, 1));\n      // Wait for cluster state to be updated\n      waitForState(\"Replica state not updated in cluster state\",\n          collectionName, clusterStateReflectsActiveAndDownReplicas());\n    }\n    docCollection = assertNumberOfReplicas(0, 0, 1, true, true);\n\n    // Check that there is no leader for the shard\n    Replica leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader == null || !leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // Pull replica on the other hand should be active\n    Replica pullReplica = docCollection.getSlice(\"shard1\").getReplicas(EnumSet.of(Replica.Type.PULL)).get(0);\n    assertTrue(pullReplica.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    long highestTerm = 0L;\n    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n      highestTerm = zkShardTerms.getHighestTerm();\n    }\n    // add document, this should fail since there is no leader. Pull replica should not accept the update\n    expectThrows(SolrException.class, () ->\n      cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n    );\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Also fails if I send the update to the pull replica explicitly\n    try (HttpSolrClient pullReplicaClient = getHttpSolrClient(docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)).get(0).getCoreUrl())) {\n      expectThrows(SolrException.class, () ->\n        cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"))\n      );\n    }\n    if (removeReplica) {\n      try(ZkShardTerms zkShardTerms = new ZkShardTerms(collectionName, \"shard1\", zkClient())) {\n        assertEquals(highestTerm, zkShardTerms.getHighestTerm());\n      }\n    }\n\n    // Queries should still work\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    // Add nrt replica back. Since there is no nrt now, new nrt will have no docs. There will be data loss, since the it will become the leader\n    // and pull replicas will replicate from it. Maybe we want to change this. Replicate from pull replicas is not a good idea, since they\n    // are by definition out of date.\n    if (removeReplica) {\n      CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\", Replica.Type.NRT).process(cluster.getSolrClient());\n    } else {\n      leaderJetty.start();\n    }\n    waitForState(\"Expected collection to be 1x2\", collectionName, clusterShape(1, 2));\n    unIgnoreException(\"No registered leader was found\"); // Should have a leader from now on\n\n    // Validate that the new nrt replica is the leader now\n    cluster.getSolrClient().getZkStateReader().forceUpdateCollection(collectionName);\n    docCollection = getCollectionState(collectionName);\n    leader = docCollection.getSlice(\"shard1\").getLeader();\n    assertTrue(leader != null && leader.isActive(cluster.getSolrClient().getZkStateReader().getClusterState().getLiveNodes()));\n\n    // If jetty is restarted, the replication is not forced, and replica doesn't replicate from leader until new docs are added. Is this the correct behavior? Why should these two cases be different?\n    if (removeReplica) {\n      // Pull replicas will replicate the empty index if a new replica was added and becomes leader\n      waitForNumDocsInAllReplicas(0, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n    }\n\n    // add docs agin\n    cluster.getSolrClient().add(collectionName, new SolrInputDocument(\"id\", \"2\", \"foo\", \"zoo\"));\n    s = docCollection.getSlices().iterator().next();\n    try (HttpSolrClient leaderClient = getHttpSolrClient(s.getLeader().getCoreUrl())) {\n      leaderClient.commit();\n      assertEquals(1, leaderClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    }\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)), \"id:2\");\n    waitForNumDocsInAllReplicas(1, docCollection.getReplicas(EnumSet.of(Replica.Type.PULL)));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","61c45e99cf6676da48f19d7511c73712ad39402b"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"61c45e99cf6676da48f19d7511c73712ad39402b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4":["61c45e99cf6676da48f19d7511c73712ad39402b"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["4dcbadb1ffa7882d470040d12698396c35abbf5a"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"4dcbadb1ffa7882d470040d12698396c35abbf5a":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["4dcbadb1ffa7882d470040d12698396c35abbf5a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","61c45e99cf6676da48f19d7511c73712ad39402b"],"06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4":["8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"8c30d22eaf1287a88a402fba9d8b7b9d20d6ef94":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"4dcbadb1ffa7882d470040d12698396c35abbf5a":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}