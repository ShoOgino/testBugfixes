{"path":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94b4f4bf8892e6006d66f4231d6d1873bbe56e73","date":1352661595,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":["9ce667c6d3400b22523701c549c0d35e26da8b46","b1405362241b561f5590ff4a87d5d6e173bcd9cf","660be90ac3e6be139532015fd7a2bfd2d4037f18","c5df35ab57c223ea11aec64b53bf611904f3dced","60679157c78fc286ee35471398529a1e5749621c","0ebc2085cdebd1e698f670bed4679ec7306f8a57","ba7fd1181f778e9954547e8e6a47587ebf08e3fb","abba363b04df5f50b5ec36177b5cd17c3fe73d6b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      synchronized(this) {\n        long startStallTime = 0;\n        while (mergeThreadCount() >= 1+maxMergeCount) {\n          startStallTime = System.currentTimeMillis();\n          if (verbose()) {\n            message(\"    too many merges; stalling...\");\n          }\n          try {\n            wait();\n          } catch (InterruptedException ie) {\n            throw new ThreadInterruptedException(ie);\n          }\n        }\n\n        if (verbose()) {\n          if (startStallTime != 0) {\n            message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n          }\n        }\n      }\n\n\n      // TODO: we could be careful about which merges to do in\n      // the BG (eg maybe the \"biggest\" ones) vs FG, which\n      // merges to do first (the easiest ones?), etc.\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      // We do this w/ the primary thread to keep\n      // deterministic assignment of segment names\n      writer.mergeInit(merge);\n\n      boolean success = false;\n      try {\n        synchronized(this) {\n          if (verbose()) {\n            message(\"  consider merge \" + writer.segString(merge.segments));\n          }\n\n          // OK to spawn a new merge thread to handle this\n          // merge:\n          final MergeThread merger = getMergeThread(writer, merge);\n          mergeThreads.add(merger);\n          if (verbose()) {\n            message(\"    launch new thread [\" + merger.getName() + \"]\");\n          }\n\n          merger.start();\n\n          // Must call this after starting the thread else\n          // the new thread is removed from mergeThreads\n          // (since it's not alive yet):\n          updateMergeThreads();\n\n          success = true;\n        }\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4853751884e55469b8cc1abab8fa0788eab240c9","date":1394565067,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter,MergeTrigger,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/ConcurrentMergeScheduler#merge(IndexWriter).mjava","sourceNew":"  @Override\n  public synchronized void merge(IndexWriter writer, MergeTrigger trigger, boolean newMergesFound) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized void merge(IndexWriter writer) throws IOException {\n\n    assert !Thread.holdsLock(writer);\n\n    this.writer = writer;\n\n    initMergeThreadPriority();\n\n    dir = writer.getDirectory();\n\n    // First, quickly run through the newly proposed merges\n    // and add any orthogonal merges (ie a merge not\n    // involving segments already pending to be merged) to\n    // the queue.  If we are way behind on merging, many of\n    // these newly proposed merges will likely already be\n    // registered.\n\n    if (verbose()) {\n      message(\"now merge\");\n      message(\"  index: \" + writer.segString());\n    }\n    \n    // Iterate, pulling from the IndexWriter's queue of\n    // pending merges, until it's empty:\n    while (true) {\n\n      long startStallTime = 0;\n      while (writer.hasPendingMerges() && mergeThreadCount() >= maxMergeCount) {\n        // This means merging has fallen too far behind: we\n        // have already created maxMergeCount threads, and\n        // now there's at least one more merge pending.\n        // Note that only maxThreadCount of\n        // those created merge threads will actually be\n        // running; the rest will be paused (see\n        // updateMergeThreads).  We stall this producer\n        // thread to prevent creation of new segments,\n        // until merging has caught up:\n        startStallTime = System.currentTimeMillis();\n        if (verbose()) {\n          message(\"    too many merges; stalling...\");\n        }\n        try {\n          wait();\n        } catch (InterruptedException ie) {\n          throw new ThreadInterruptedException(ie);\n        }\n      }\n\n      if (verbose()) {\n        if (startStallTime != 0) {\n          message(\"  stalled for \" + (System.currentTimeMillis()-startStallTime) + \" msec\");\n        }\n      }\n\n      MergePolicy.OneMerge merge = writer.getNextMerge();\n      if (merge == null) {\n        if (verbose()) {\n          message(\"  no more merges pending; now return\");\n        }\n        return;\n      }\n\n      boolean success = false;\n      try {\n        if (verbose()) {\n          message(\"  consider merge \" + writer.segString(merge.segments));\n        }\n\n        // OK to spawn a new merge thread to handle this\n        // merge:\n        final MergeThread merger = getMergeThread(writer, merge);\n        mergeThreads.add(merger);\n        if (verbose()) {\n          message(\"    launch new thread [\" + merger.getName() + \"]\");\n        }\n\n        merger.start();\n\n        // Must call this after starting the thread else\n        // the new thread is removed from mergeThreads\n        // (since it's not alive yet):\n        updateMergeThreads();\n\n        success = true;\n      } finally {\n        if (!success) {\n          writer.mergeFinish(merge);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4853751884e55469b8cc1abab8fa0788eab240c9":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"94b4f4bf8892e6006d66f4231d6d1873bbe56e73":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","94b4f4bf8892e6006d66f4231d6d1873bbe56e73"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4853751884e55469b8cc1abab8fa0788eab240c9"]},"commit2Childs":{"4853751884e55469b8cc1abab8fa0788eab240c9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"94b4f4bf8892e6006d66f4231d6d1873bbe56e73":["4853751884e55469b8cc1abab8fa0788eab240c9","407687e67faf6e1f02a211ca078d8e3eed631027"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["94b4f4bf8892e6006d66f4231d6d1873bbe56e73","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}