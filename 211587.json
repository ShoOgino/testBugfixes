{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23550189554f52bad1625fceab84a71d20a4df3f","date":1321064526,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":["ac3e6437547a34cce2b5405ce0cf9e3af578401e"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50eb25774a5690a93352e49e7732b8008c5e681e","date":1328112094,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        topCollector = TopScoreDocCollector.create(len, true);\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":["ac3e6437547a34cce2b5405ce0cf9e3af578401e","323f871ffe96b871d8c534a614be60751bb023c2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n        \ttopCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","date":1367858986,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195","date":1373388895,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5bc8e25f59990525f5beb14afe9c96240dcf4a2","date":1389042945,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n    } else {\n      TopDocsCollector topCollector;\n      if (cmd.getSort() == null) {\n        if(cmd.getScoreDoc() != null) {\n          topCollector = TopScoreDocCollector.create(len, cmd.getScoreDoc(), true); //create the Collector with InOrderPagingCollector\n        } else {\n          topCollector = TopScoreDocCollector.create(len, true);\n        }\n\n      } else {\n        topCollector = TopFieldCollector.create(weightSort(cmd.getSort()), len, false, needScores, needScores, true);\n      }\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new Collector () {\n          @Override\n          public void setScorer(Scorer scorer) {\n          }\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new Collector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public void setNextReader(AtomicReaderContext context) {\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3219e7215437030592c42ca55b29e3f77e0d6808","date":1402349186,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    final long timeAllowed = cmd.getTimeAllowed();\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    boolean terminateEarly = (cmd.getFlags() & TERMINATE_EARLY) == TERMINATE_EARLY;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      if (terminateEarly) {\n        collector = new EarlyTerminatingCollector(collector, cmd.len);\n      }\n      if( timeAllowed > 0 ) {\n        collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);\n      }\n      if (pf.postFilter != null) {\n        pf.postFilter.setLastDelegate(collector);\n        collector = pf.postFilter;\n      }\n      try {\n        super.search(query, luceneFilter, collector);\n        if(collector instanceof DelegatingCollector) {\n          ((DelegatingCollector)collector).finish();\n        }\n      }\n      catch( TimeLimitingCollector.TimeExceededException x ) {\n        log.warn( \"Query: \" + query + \"; \" + x.getMessage() );\n        qr.setPartialResults(true);\n      }\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc","date":1424799790,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Filter luceneFilter = pf.filter;\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, luceneFilter, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1db68e96dd908fcd79ef809095822736aa601d08","date":1434630596,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new FilteredQuery(query, pf.filter);\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr,QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last=maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n    \n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder()\n          .add(query, Occur.MUST)\n          .add(pf.filter, Occur.FILTER)\n          .build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested<=0) {\n      final float[] topscore = new float[] { Float.NEGATIVE_INFINITY };\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector () {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n          \n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0]=score;            \n          }\n          \n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n      \n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned=0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits>0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits>0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags()&GET_SCORES)!=0 ? new float[nDocsReturned] : null;\n      for (int i=0; i<nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested,nDocsReturned);\n    if (sliceLen < 0) sliceLen=0;\n    qr.setDocList(new DocSlice(0,sliceLen,ids,scores,totalHits,maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return false;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      Collector collector = topCollector;\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? topDocs.getMaxScore() : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorer scorer;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c4d4ec3bca82c8eac712592ab518cd082026f34","date":1585956055,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    query = QueryUtils.combineQueryAndFilter(query, pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    if (pf.filter != null) {\n      query = new BooleanQuery.Builder().add(query, Occur.MUST).add(pf.filter, Occur.FILTER).build();\n    }\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d8a0350513120be3cf48c0eafd6b8787fcd3ec","date":1586897159,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    Query query = QueryUtils.makeQueryable(cmd.getQuery());\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    query = QueryUtils.combineQueryAndFilter(query, pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"640ded7811e1b7d29236a5e2934ec3cd266a8199","date":1588973147,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      hitsRelation = topDocs.totalHits.relation;\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n    } else {\n      final TopDocsCollector topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e6e3d7e1e6a8eeca8c0d3e14e2ce425bae839b","date":1590101317,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      hitsRelation = topDocs.totalHits.relation;\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72afa881b0b5c361ebd0b6d37927fe072151fbe0","date":1590107364,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocListNC(QueryResult,QueryCommand).mjava","sourceNew":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      ScoreMode scoreModeUsed = buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter).scoreMode();\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      if (scoreModeUsed == ScoreMode.COMPLETE || scoreModeUsed == ScoreMode.COMPLETE_NO_SCORES) {\n        hitsRelation = TotalHits.Relation.EQUAL_TO;\n      } else {\n        hitsRelation = topDocs.totalHits.relation;\n      }\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n\n","sourceOld":"  private void getDocListNC(QueryResult qr, QueryCommand cmd) throws IOException {\n    int len = cmd.getSupersetMaxDoc();\n    int last = len;\n    if (last < 0 || last > maxDoc()) last = maxDoc();\n    final int lastDocRequested = last;\n    int nDocsReturned;\n    int totalHits;\n    float maxScore;\n    int[] ids;\n    float[] scores;\n\n    boolean needScores = (cmd.getFlags() & GET_SCORES) != 0;\n\n    ProcessedFilter pf = getProcessedFilter(cmd.getFilter(), cmd.getFilterList());\n    final Query query = QueryUtils.combineQueryAndFilter(QueryUtils.makeQueryable(cmd.getQuery()), pf.filter);\n    Relation hitsRelation;\n\n    // handle zero case...\n    if (lastDocRequested <= 0) {\n      final float[] topscore = new float[] {Float.NEGATIVE_INFINITY};\n      final int[] numHits = new int[1];\n\n      Collector collector;\n\n      if (!needScores) {\n        collector = new SimpleCollector() {\n          @Override\n          public void collect(int doc) {\n            numHits[0]++;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE_NO_SCORES;\n          }\n        };\n      } else {\n        collector = new SimpleCollector() {\n          Scorable scorer;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.scorer = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            numHits[0]++;\n            float score = scorer.score();\n            if (score > topscore[0]) topscore[0] = score;\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n        };\n      }\n\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      nDocsReturned = 0;\n      ids = new int[nDocsReturned];\n      scores = new float[nDocsReturned];\n      totalHits = numHits[0];\n      maxScore = totalHits > 0 ? topscore[0] : 0.0f;\n      // no docs on this page, so cursor doesn't change\n      qr.setNextCursorMark(cmd.getCursorMark());\n      hitsRelation = Relation.EQUAL_TO;\n    } else {\n      final TopDocsCollector<?> topCollector = buildTopDocsCollector(len, cmd);\n      MaxScoreCollector maxScoreCollector = null;\n      Collector collector = topCollector;\n      if ((cmd.getFlags() & GET_SCORES) != 0) {\n        maxScoreCollector = new MaxScoreCollector();\n        collector = MultiCollector.wrap(topCollector, maxScoreCollector);\n      }\n      buildAndRunCollectorChain(qr, query, collector, cmd, pf.postFilter);\n\n      totalHits = topCollector.getTotalHits();\n      TopDocs topDocs = topCollector.topDocs(0, len);\n      hitsRelation = topDocs.totalHits.relation;\n      if (cmd.getSort() != null && query instanceof RankQuery == false && (cmd.getFlags() & GET_SCORES) != 0) {\n        TopFieldCollector.populateScores(topDocs.scoreDocs, this, query);\n      }\n      populateNextCursorMarkFromTopDocs(qr, cmd, topDocs);\n\n      maxScore = totalHits > 0 ? (maxScoreCollector == null ? Float.NaN : maxScoreCollector.getMaxScore()) : 0.0f;\n      nDocsReturned = topDocs.scoreDocs.length;\n      ids = new int[nDocsReturned];\n      scores = (cmd.getFlags() & GET_SCORES) != 0 ? new float[nDocsReturned] : null;\n      for (int i = 0; i < nDocsReturned; i++) {\n        ScoreDoc scoreDoc = topDocs.scoreDocs[i];\n        ids[i] = scoreDoc.doc;\n        if (scores != null) scores[i] = scoreDoc.score;\n      }\n    }\n\n    int sliceLen = Math.min(lastDocRequested, nDocsReturned);\n    if (sliceLen < 0) sliceLen = 0;\n    qr.setDocList(new DocSlice(0, sliceLen, ids, scores, totalHits, maxScore, hitsRelation));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"640ded7811e1b7d29236a5e2934ec3cd266a8199":["d4d8a0350513120be3cf48c0eafd6b8787fcd3ec"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0","c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"72afa881b0b5c361ebd0b6d37927fe072151fbe0":["640ded7811e1b7d29236a5e2934ec3cd266a8199","b3e6e3d7e1e6a8eeca8c0d3e14e2ce425bae839b"],"1db68e96dd908fcd79ef809095822736aa601d08":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["417142ff08fda9cf0b72d5133e63097a166c6458","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2","ae73da626f97850c922c42736f808d0378e165f0"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"50eb25774a5690a93352e49e7732b8008c5e681e":["23550189554f52bad1625fceab84a71d20a4df3f"],"5c4d4ec3bca82c8eac712592ab518cd082026f34":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["50eb25774a5690a93352e49e7732b8008c5e681e"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"3219e7215437030592c42ca55b29e3f77e0d6808":["ae73da626f97850c922c42736f808d0378e165f0"],"d4d8a0350513120be3cf48c0eafd6b8787fcd3ec":["5c4d4ec3bca82c8eac712592ab518cd082026f34"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["1db68e96dd908fcd79ef809095822736aa601d08"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"417142ff08fda9cf0b72d5133e63097a166c6458":["ac9de183adbc9483681f275ac1e2d92ed19f52e1","9fc47cb7b4346802411bb432f501ed0673d7119e"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"b3e6e3d7e1e6a8eeca8c0d3e14e2ce425bae839b":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["3219e7215437030592c42ca55b29e3f77e0d6808"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["50eb25774a5690a93352e49e7732b8008c5e681e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"ae73da626f97850c922c42736f808d0378e165f0":["d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"23550189554f52bad1625fceab84a71d20a4df3f":["c26f00b574427b55127e869b935845554afde1fa"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["72afa881b0b5c361ebd0b6d37927fe072151fbe0"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"]},"commit2Childs":{"640ded7811e1b7d29236a5e2934ec3cd266a8199":["72afa881b0b5c361ebd0b6d37927fe072151fbe0","b3e6e3d7e1e6a8eeca8c0d3e14e2ce425bae839b"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"c26f00b574427b55127e869b935845554afde1fa":["23550189554f52bad1625fceab84a71d20a4df3f"],"d5bc8e25f59990525f5beb14afe9c96240dcf4a2":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"72afa881b0b5c361ebd0b6d37927fe072151fbe0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1db68e96dd908fcd79ef809095822736aa601d08":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"c75ea0343a1ac7ea10bf4790c190f96b2c7b1195":["37a0f60745e53927c4c876cfe5b5a58170f0646c","d5bc8e25f59990525f5beb14afe9c96240dcf4a2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc":["1db68e96dd908fcd79ef809095822736aa601d08"],"50eb25774a5690a93352e49e7732b8008c5e681e":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"5c4d4ec3bca82c8eac712592ab518cd082026f34":["d4d8a0350513120be3cf48c0eafd6b8787fcd3ec"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"3219e7215437030592c42ca55b29e3f77e0d6808":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"d4d8a0350513120be3cf48c0eafd6b8787fcd3ec":["640ded7811e1b7d29236a5e2934ec3cd266a8199"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f8ec642b0195d666cf3b5a6a6c2a80bdd3b756bc"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"ebcafb9e6302e7e39ce2199768a1428d22dd3ce0":["37a0f60745e53927c4c876cfe5b5a58170f0646c","c75ea0343a1ac7ea10bf4790c190f96b2c7b1195"],"b3e6e3d7e1e6a8eeca8c0d3e14e2ce425bae839b":["72afa881b0b5c361ebd0b6d37927fe072151fbe0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["5c4d4ec3bca82c8eac712592ab518cd082026f34"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"ae73da626f97850c922c42736f808d0378e165f0":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","3219e7215437030592c42ca55b29e3f77e0d6808"],"23550189554f52bad1625fceab84a71d20a4df3f":["50eb25774a5690a93352e49e7732b8008c5e681e"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","1d3f7ab1a502671bbdb03bcced21e764d2483221"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["ebcafb9e6302e7e39ce2199768a1428d22dd3ce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","15e323346eac5e4685c0a9f2df85eb96b4239bbb","fe33227f6805edab2036cbb80645cc4e2d1fa424","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}