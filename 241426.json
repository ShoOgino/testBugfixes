{"path":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","commits":[{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"/dev/null","sourceNew":"  public void doTest() throws Exception {\n    createServers();\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.mincount\",2);\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37","072f211dfa8387028bb978d128c35bf9a450bbbf","072f211dfa8387028bb978d128c35bf9a450bbbf","072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"705cbdd6d66202e299a6f186f5fbb69dbb64f41a","date":1205860565,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    createServers();\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",\"missing_field_t\",\"facet.mincount\",2);\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    createServers();\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.mincount\",2);\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"409850dbbdb6e3184a228ed61332c3fee211f481","date":1205869216,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    createServers();\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    createServers();\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",\"missing_field_t\",\"facet.mincount\",2);\n\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["1805a9b39f81f70b33c67bd84a1d672c896ceca0","d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88c208297981f95c495558c24ae47a36a6300a63","date":1207891374,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    createServers();\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da0acfe5ceed804451d76c8f887855b3d060e132","date":1208287358,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\");\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shal pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ed9977f1cdec244969bc4f5054a6041028238bf","date":1209503245,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"{!func}\"+i1);\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"<!func>\"+i1);\n    query(\"q\",\"<!func>\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7116df897fd068949084f44e80c7c4a0869652e6","date":1213709875,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"{!func}\"+i1);\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"maxScore\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1ab02b73dc61b51bca98e09b5b72926c4580ecb","date":1213987100,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a65fafd2cd022da518bb7ee43dcef8d80014c57d","date":1215448650,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc036b9a71fd0bea4fa51158c11f7104e679902f","date":1215909507,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"958002d120dd01c9ea3b3278c3616ef0f1a899a3","date":1215910008,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    //query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["1af58bfae0521d6b9609c701909e824291964c14"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1af58bfae0521d6b9609c701909e824291964c14","date":1216088694,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    //query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":["958002d120dd01c9ea3b3278c3616ef0f1a899a3"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ac277fcde6efbfb4b34a6b2cdbda483003cda18","date":1220648479,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",true);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e5a95ce1d7a3779af6db59b6b39d3b89172d7445","date":1228620032,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",true);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb179b2fab2183d2f6041e450ff8022c592ecf0","date":1229553695,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"18a1b51b47d1035bf90ecfc7d16c739fe983647a","date":1229928361,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. NamedListCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95c18944ff53ae8d9f26822b93473fb5621d320e","date":1231751360,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1161f19bd84204b140d97fea16ff621e86ce7ab4","date":1235924971,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"lex\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c4ed8b555b728a98390ef8546612f6b94f9987f","date":1240848313,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    index(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 ,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2 ,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876 ,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7 ,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321 ,t1,\"this too shall pass\");\n    index(id,11, i1, -987 ,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379 ,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232 ,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9eeefc9a351a2910959c41bf241877a3d60eec37","date":1244136536,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    index(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    index(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["d1c5c000a4f7db9f84794088342aa428d80dfa37"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3da65606b2cf2b2357063f779126d1521733034","date":1249401214,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    index(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    index(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3a7619905ebecda128779ae65e20ca9776b1714","date":1249655243,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    RandVal.uniqueValues = new HashSet();   // reset unique random values\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    del(\"*:*\");\n    index(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    index(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\");\n    index(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\");\n    index(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\");\n    index(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\");\n    index(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    index(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    index(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    index(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    index(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    index(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    index(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    index(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    index(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    index(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    index(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    index(id, 17, \"SubjectTerms_mfacet\", vals);\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":["8c19c480d77a53905bbd65f04e90fa35925c0f9b","8c19c480d77a53905bbd65f04e90fa35925c0f9b","8c19c480d77a53905bbd65f04e90fa35925c0f9b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1c2dfb6aa7b4d342a493c0982be96b76f595add","date":1252705594,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    RandVal.uniqueValues = new HashSet();   // reset unique random values\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    RandVal.uniqueValues = new HashSet();   // reset unique random values\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"52c7a21951a44948544c782d645588d404cace61","date":1259040420,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  public void doTest() throws Exception {\n    RandVal.uniqueValues = new HashSet();   // reset unique random values\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    RandVal.uniqueValues = new HashSet();   // reset unique random values\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0b57d1523f42368168ea21982dd84effd69453d3","date":1260216800,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  public void doTest() throws Exception {\n    RandVal.uniqueValues = new HashSet();   // reset unique random values\n\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n\n    destroyServers();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","pathOld":"src/test/org/apache/solr/TestDistributedSearch#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    del(\"*:*\");\n    indexr(id,1, i1, 100, tlong, 100,t1,\"now is the time for all good men\"\n            ,\"foo_f\", 1.414f, \"foo_b\", \"true\", \"foo_d\", 1.414d);\n    indexr(id,2, i1, 50 , tlong, 50,t1,\"to come to the aid of their country.\"\n    );\n    indexr(id,3, i1, 2, tlong, 2,t1,\"how now brown cow\"\n    );\n    indexr(id,4, i1, -100 ,tlong, 101,t1,\"the quick fox jumped over the lazy dog\"\n    );\n    indexr(id,5, i1, 500, tlong, 500 ,t1,\"the quick fox jumped way over the lazy dog\"\n    );\n    indexr(id,6, i1, -600, tlong, 600 ,t1,\"humpty dumpy sat on a wall\");\n    indexr(id,7, i1, 123, tlong, 123 ,t1,\"humpty dumpy had a great fall\");\n    indexr(id,8, i1, 876, tlong, 876,t1,\"all the kings horses and all the kings men\");\n    indexr(id,9, i1, 7, tlong, 7,t1,\"couldn't put humpty together again\");\n    indexr(id,10, i1, 4321, tlong, 4321,t1,\"this too shall pass\");\n    indexr(id,11, i1, -987, tlong, 987,t1,\"An eye for eye only ends up making the whole world blind.\");\n    indexr(id,12, i1, 379, tlong, 379,t1,\"Great works are performed, not by strength, but by perseverance.\");\n    indexr(id,13, i1, 232, tlong, 232,t1,\"no eggs on wall, lesson learned\", oddField, \"odd man out\");\n\n    indexr(id, 14, \"SubjectTerms_mfacet\", new String[]  {\"mathematical models\", \"mathematical analysis\"});\n    indexr(id, 15, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    indexr(id, 16, \"SubjectTerms_mfacet\", new String[]  {\"test 1\", \"test 2\", \"test3\"});\n    String[] vals = new String[100];\n    for (int i=0; i<100; i++) {\n      vals[i] = \"test \" + i;\n    }\n    indexr(id, 17, \"SubjectTerms_mfacet\", vals);\n\n    for (int i=100; i<150; i++) {\n      indexr(id, i);      \n    }\n\n    commit();\n\n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n\n    // random value sort\n    for (String f : fieldNames) {\n      query(\"q\",\"*:*\", \"sort\",f+\" desc\");\n      query(\"q\",\"*:*\", \"sort\",f+\" asc\");\n    }\n\n\n    // these queries should be exactly ordered and scores should exactly match\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" asc\");\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"fl\",\"*,score\");\n    query(\"q\",\"*:*\", \"sort\",tlong+\" asc\", \"fl\",\"score\");  // test legacy behavior - \"score\"==\"*,score\"\n    query(\"q\",\"*:*\", \"sort\",tlong+\" desc\");\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"{!func}\"+i1);// does not expect maxScore. So if it comes ,ignore it. JavaBinCodec.writeSolrDocumentList()\n    //is agnostic of request params.\n    handle.remove(\"maxScore\");\n    query(\"q\",\"{!func}\"+i1, \"fl\",\"*,score\");  // even scores should match exactly here\n\n    handle.put(\"highlighting\", UNORDERED);\n    handle.put(\"response\", UNORDERED);\n\n    handle.put(\"maxScore\", SKIPVAL);\n    query(\"q\",\"quick\");\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"0\");\n    query(\"q\",\"all\",\"fl\",\"foofoofoo\",\"start\",\"0\");  // no fields in returned docs\n    query(\"q\",\"all\",\"fl\",\"id\",\"start\",\"100\");\n\n    handle.put(\"score\", SKIPVAL);\n    query(\"q\",\"quick\",\"fl\",\"*,score\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"1\");\n    query(\"q\",\"all\",\"fl\",\"*,score\",\"start\",\"100\");\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"foofoofoo\",\n            \"hl\",\"true\",\"hl.fl\",t1);\n\n\n    handle.put(\"debug\", UNORDERED);\n    handle.put(\"time\", SKIPVAL);\n\n    query(\"q\",\"now their fox sat had put\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");\n\n    // TODO: This test currently fails because debug info is obtained only\n    // on shards with matches.\n    /***\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\",\n            \"debugQuery\", \"true\");    \n    ***/\n    query(\"q\",\"matchesnothing\",\"fl\",\"*,score\");  \n\n\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"count\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.limit\",-1, \"facet.sort\",\"index\", \"facet.mincount\",2);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1,\"facet.limit\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\");\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.offset\",1);\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",t1, \"facet.mincount\",2);\n\n    // test faceting multiple things at once\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"quick\", \"facet.query\",\"all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",t1);\n\n    // test filter tagging, facet exclusion, and naming (multi-select facet support)\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.query\",\"{!key=myquick}quick\", \"facet.query\",\"{!key=myall ex=a}all\", \"facet.query\",\"*:*\"\n    ,\"facet.field\",\"{!key=mykey ex=a}\"+t1\n    ,\"facet.field\",\"{!key=other ex=b}\"+t1\n    ,\"facet.field\",\"{!key=again ex=a,b}\"+t1\n    ,\"facet.field\",t1\n    ,\"fq\",\"{!tag=a}id:[1 TO 7]\", \"fq\",\"{!tag=b}id:[3 TO 9]\"\n    );\n    query(\"q\", \"*:*\", \"facet\", \"true\", \"facet.field\", \"{!ex=t1}SubjectTerms_mfacet\", \"fq\", \"{!tag=t1}SubjectTerms_mfacet:(test 1)\", \"facet.limit\", \"10\", \"facet.mincount\", \"1\");\n\n    // test field that is valid in schema but missing in all shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",missingField, \"facet.mincount\",2);\n    // test field that is valid in schema and missing in some shards\n    query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",oddField, \"facet.mincount\",2);\n\n    query(\"q\",\"*:*\", \"sort\",i1+\" desc\", \"stats\", \"true\", \"stats.field\", i1);\n\n    try {\n      // test error produced for field that is invalid for schema\n      query(\"q\",\"*:*\", \"rows\",100, \"facet\",\"true\", \"facet.field\",invalidField, \"facet.mincount\",2);\n      fail(\"SolrServerException expected for invalid field that is not in schema\");\n    } catch (SolrServerException ex) {\n      // expected\n    }\n\n    // index the same document to two servers and make sure things\n    // don't blow up.\n    if (clients.size()>=2) {\n      index(id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      for (int i=0; i<clients.size(); i++) {\n        index_specific(i, id,100, i1, 107 ,t1,\"oh no, a duplicate!\");\n      }\n      commit();\n      query(\"q\",\"duplicate\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"fox duplicate horses\", \"hl\",\"true\", \"hl.fl\", t1);\n      query(\"q\",\"*:*\", \"rows\",100);\n    }\n\n    // Thread.sleep(10000000000L);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1af58bfae0521d6b9609c701909e824291964c14":["958002d120dd01c9ea3b3278c3616ef0f1a899a3"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"0b57d1523f42368168ea21982dd84effd69453d3":["52c7a21951a44948544c782d645588d404cace61"],"95c18944ff53ae8d9f26822b93473fb5621d320e":["18a1b51b47d1035bf90ecfc7d16c739fe983647a"],"52c7a21951a44948544c782d645588d404cace61":["c1c2dfb6aa7b4d342a493c0982be96b76f595add"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["9ac277fcde6efbfb4b34a6b2cdbda483003cda18"],"409850dbbdb6e3184a228ed61332c3fee211f481":["705cbdd6d66202e299a6f186f5fbb69dbb64f41a"],"0ed9977f1cdec244969bc4f5054a6041028238bf":["da0acfe5ceed804451d76c8f887855b3d060e132"],"c1c2dfb6aa7b4d342a493c0982be96b76f595add":["b3a7619905ebecda128779ae65e20ca9776b1714"],"958002d120dd01c9ea3b3278c3616ef0f1a899a3":["bc036b9a71fd0bea4fa51158c11f7104e679902f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1ab02b73dc61b51bca98e09b5b72926c4580ecb":["7116df897fd068949084f44e80c7c4a0869652e6"],"7116df897fd068949084f44e80c7c4a0869652e6":["0ed9977f1cdec244969bc4f5054a6041028238bf"],"18a1b51b47d1035bf90ecfc7d16c739fe983647a":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"a65fafd2cd022da518bb7ee43dcef8d80014c57d":["a1ab02b73dc61b51bca98e09b5b72926c4580ecb"],"bc036b9a71fd0bea4fa51158c11f7104e679902f":["a65fafd2cd022da518bb7ee43dcef8d80014c57d"],"ad94625fb8d088209f46650c8097196fec67f00c":["0b57d1523f42368168ea21982dd84effd69453d3"],"9ac277fcde6efbfb4b34a6b2cdbda483003cda18":["1af58bfae0521d6b9609c701909e824291964c14"],"b3a7619905ebecda128779ae65e20ca9776b1714":["c3da65606b2cf2b2357063f779126d1521733034"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"705cbdd6d66202e299a6f186f5fbb69dbb64f41a":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"9c4ed8b555b728a98390ef8546612f6b94f9987f":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"da0acfe5ceed804451d76c8f887855b3d060e132":["88c208297981f95c495558c24ae47a36a6300a63"],"9eeefc9a351a2910959c41bf241877a3d60eec37":["9c4ed8b555b728a98390ef8546612f6b94f9987f"],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["95c18944ff53ae8d9f26822b93473fb5621d320e"],"88c208297981f95c495558c24ae47a36a6300a63":["409850dbbdb6e3184a228ed61332c3fee211f481"],"c3da65606b2cf2b2357063f779126d1521733034":["9eeefc9a351a2910959c41bf241877a3d60eec37"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"1af58bfae0521d6b9609c701909e824291964c14":["9ac277fcde6efbfb4b34a6b2cdbda483003cda18"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"0b57d1523f42368168ea21982dd84effd69453d3":["ad94625fb8d088209f46650c8097196fec67f00c"],"95c18944ff53ae8d9f26822b93473fb5621d320e":["1161f19bd84204b140d97fea16ff621e86ce7ab4"],"52c7a21951a44948544c782d645588d404cace61":["0b57d1523f42368168ea21982dd84effd69453d3"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["705cbdd6d66202e299a6f186f5fbb69dbb64f41a"],"e5a95ce1d7a3779af6db59b6b39d3b89172d7445":["9cb179b2fab2183d2f6041e450ff8022c592ecf0"],"409850dbbdb6e3184a228ed61332c3fee211f481":["88c208297981f95c495558c24ae47a36a6300a63"],"0ed9977f1cdec244969bc4f5054a6041028238bf":["7116df897fd068949084f44e80c7c4a0869652e6"],"958002d120dd01c9ea3b3278c3616ef0f1a899a3":["1af58bfae0521d6b9609c701909e824291964c14"],"c1c2dfb6aa7b4d342a493c0982be96b76f595add":["52c7a21951a44948544c782d645588d404cace61"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a1ab02b73dc61b51bca98e09b5b72926c4580ecb":["a65fafd2cd022da518bb7ee43dcef8d80014c57d"],"7116df897fd068949084f44e80c7c4a0869652e6":["a1ab02b73dc61b51bca98e09b5b72926c4580ecb"],"18a1b51b47d1035bf90ecfc7d16c739fe983647a":["95c18944ff53ae8d9f26822b93473fb5621d320e"],"a65fafd2cd022da518bb7ee43dcef8d80014c57d":["bc036b9a71fd0bea4fa51158c11f7104e679902f"],"bc036b9a71fd0bea4fa51158c11f7104e679902f":["958002d120dd01c9ea3b3278c3616ef0f1a899a3"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"9ac277fcde6efbfb4b34a6b2cdbda483003cda18":["e5a95ce1d7a3779af6db59b6b39d3b89172d7445"],"b3a7619905ebecda128779ae65e20ca9776b1714":["c1c2dfb6aa7b4d342a493c0982be96b76f595add"],"9cb179b2fab2183d2f6041e450ff8022c592ecf0":["18a1b51b47d1035bf90ecfc7d16c739fe983647a"],"705cbdd6d66202e299a6f186f5fbb69dbb64f41a":["409850dbbdb6e3184a228ed61332c3fee211f481"],"da0acfe5ceed804451d76c8f887855b3d060e132":["0ed9977f1cdec244969bc4f5054a6041028238bf"],"9c4ed8b555b728a98390ef8546612f6b94f9987f":["9eeefc9a351a2910959c41bf241877a3d60eec37"],"9eeefc9a351a2910959c41bf241877a3d60eec37":["c3da65606b2cf2b2357063f779126d1521733034"],"1161f19bd84204b140d97fea16ff621e86ce7ab4":["9c4ed8b555b728a98390ef8546612f6b94f9987f"],"88c208297981f95c495558c24ae47a36a6300a63":["da0acfe5ceed804451d76c8f887855b3d060e132"],"c3da65606b2cf2b2357063f779126d1521733034":["b3a7619905ebecda128779ae65e20ca9776b1714"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}