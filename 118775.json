{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"/dev/null","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\", e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"/dev/null","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\", e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"/dev/null","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\", e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469","date":1345037674,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\", e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70fa1c0f4d75735ff2e1485e059d9bc5efa50598","date":1345296911,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\", e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"616c1830142ff5c1ddedec1ed898733b73c8e23b","date":1345368925,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\", e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2","date":1389633998,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Exception e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Throwable e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#newHolder(SolrIndexSearcher,List[RefCounted[SolrIndexSearcher]]).mjava","sourceNew":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized (searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Exception e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","sourceOld":"  private RefCounted<SolrIndexSearcher> newHolder(SolrIndexSearcher newSearcher, final List<RefCounted<SolrIndexSearcher>> searcherList) {\n    RefCounted<SolrIndexSearcher> holder = new RefCounted<SolrIndexSearcher>(newSearcher) {\n      @Override\n      public void close() {\n        try {\n          synchronized(searcherLock) {\n            // it's possible for someone to get a reference via the _searchers queue\n            // and increment the refcount while RefCounted.close() is being called.\n            // we check the refcount again to see if this has happened and abort the close.\n            // This relies on the RefCounted class allowing close() to be called every\n            // time the counter hits zero.\n            if (refcount.get() > 0) return;\n            searcherList.remove(this);\n          }\n          resource.close();\n        } catch (Exception e) {\n          // do not allow decref() operations to fail since they are typically called in finally blocks\n          // and throwing another exception would be very unexpected.\n          SolrException.log(log, \"Error closing searcher:\" + this, e);\n        }\n      }\n    };\n    holder.incref();  // set ref count to 1 to account for this._searcher\n    return holder;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"616c1830142ff5c1ddedec1ed898733b73c8e23b":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"]},"commit2Childs":{"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"616c1830142ff5c1ddedec1ed898733b73c8e23b":[],"2668c99990e4c94a78bac005aa682b7c5986d23a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"70fa1c0f4d75735ff2e1485e059d9bc5efa50598":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["0d22ac6a4146774c1bc8400160fc0b6150294e92","616c1830142ff5c1ddedec1ed898733b73c8e23b","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469"],"f56da6f4f15d95f318d2d6ac2a39a9183dfecff2":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"b6d2d51ff0b489e2d7ddc42a63f0d6cb69326469":["616c1830142ff5c1ddedec1ed898733b73c8e23b","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","f56da6f4f15d95f318d2d6ac2a39a9183dfecff2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d22ac6a4146774c1bc8400160fc0b6150294e92","616c1830142ff5c1ddedec1ed898733b73c8e23b","70fa1c0f4d75735ff2e1485e059d9bc5efa50598","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}