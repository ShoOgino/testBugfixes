{"path":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","commits":[{"id":"3301c97f51316f9c9937654c07d7a6a21e7aecb8","date":1503489616,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.getValues().add(\"response\", qr.getResults());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        LOG.info(\"Collection \" + collection + \" does not exist.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3646ead588297558973dbd1162e69791e822b944","c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.getValues().add(\"response\", qr.getResults());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        LOG.info(\"Collection \" + collection + \" does not exist.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.getValues().add(\"response\", qr.getResults());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        LOG.info(\"Collection \" + collection + \" does not exist.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e9ae2fb2f75e4dc95285c6fa084a21034436cf1","date":1507109084,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.getValues().add(\"response\", qr.getResults());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        LOG.info(\"Collection \" + collection + \" does not exist.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.getValues().add(\"response\", qr.getResults());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        LOG.info(\"Collection \" + collection + \" does not exist.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0b75f2455c630dc7bec970dca143c8eed7c0e813","date":1519649815,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        LOG.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.getValues().add(\"response\", qr.getResults());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        LOG.info(\"Collection \" + collection + \" does not exist.\");\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8","date":1520696743,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        LOG.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(coreContainer.getZkController().getZkServerAddress())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        LOG.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":["3301c97f51316f9c9937654c07d7a6a21e7aecb8"],"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3646ead588297558973dbd1162e69791e822b944","date":1525482176,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        LOG.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        LOG.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":["3301c97f51316f9c9937654c07d7a6a21e7aecb8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        log.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        LOG.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        log.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty())\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        log.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba055e19afc289adcb5bedaf68513793a7254012","date":1591268575,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        log.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        log.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/AutoscalingHistoryHandler#handleRequestBody(SolrQueryRequest,SolrQueryResponse).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception {\n    ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n    String collection = params.get(SYSTEM_COLLECTION_PARAM, CollectionAdminParams.SYSTEM_COLL);\n    params.remove(SYSTEM_COLLECTION_PARAM);\n    params.remove(CommonParams.QT);\n    // check that we have the main query, if not then use *:*\n    if (params.get(CommonParams.Q) == null) {\n      params.add(CommonParams.Q, \"*:*\");\n    }\n    // sort by doc id, which are time-based, unless specified otherwise\n    if (params.get(CommonParams.SORT) == null) {\n      params.add(CommonParams.SORT, \"id asc\");\n    }\n    // filter query to pick only autoscaling events\n    params.remove(CommonParams.FQ, EVENTS_FQ);\n    params.add(CommonParams.FQ, EVENTS_FQ);\n    // add filters translated from simplified parameters\n    for (Map.Entry<String, String> e : formats.entrySet()) {\n      String[] values = params.remove(e.getKey());\n      if (values != null) {\n        for (String value : values) {\n          params.add(CommonParams.FQ, String.format(Locale.ROOT, e.getValue(), value));\n        }\n      }\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder(Collections.singletonList(coreContainer.getZkController().getZkServerAddress()), Optional.empty()).withSocketTimeout(30000).withConnectionTimeout(15000)\n        .withHttpClient(coreContainer.getUpdateShardHandler().getDefaultHttpClient())\n        .build()) {\n      QueryResponse qr = cloudSolrClient.query(collection, params);\n      rsp.setAllValues(qr.getResponse());\n    } catch (Exception e) {\n      if ((e instanceof SolrException) && e.getMessage().contains(\"Collection not found\")) {\n        // relatively benign\n        String msg = \"Collection \" + collection + \" does not exist.\";\n        log.info(msg);\n        rsp.getValues().add(\"error\", msg);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3301c97f51316f9c9937654c07d7a6a21e7aecb8"],"3f504512a03d978990cbff30db0522b354e846db":["ba055e19afc289adcb5bedaf68513793a7254012"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"ba055e19afc289adcb5bedaf68513793a7254012":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"3646ead588297558973dbd1162e69791e822b944":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8":["0b75f2455c630dc7bec970dca143c8eed7c0e813"],"4e9ae2fb2f75e4dc95285c6fa084a21034436cf1":["560c18d71dad43d675158783c3840f8c80d6d39c"],"3301c97f51316f9c9937654c07d7a6a21e7aecb8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0b75f2455c630dc7bec970dca143c8eed7c0e813":["4e9ae2fb2f75e4dc95285c6fa084a21034436cf1"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["3646ead588297558973dbd1162e69791e822b944"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["ba055e19afc289adcb5bedaf68513793a7254012"],"3301c97f51316f9c9937654c07d7a6a21e7aecb8":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"ba055e19afc289adcb5bedaf68513793a7254012":["3f504512a03d978990cbff30db0522b354e846db"],"3646ead588297558973dbd1162e69791e822b944":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"c7d763eff38c4e1702b60d626f9c8d39f9ad8af8":["3646ead588297558973dbd1162e69791e822b944"],"4e9ae2fb2f75e4dc95285c6fa084a21034436cf1":["0b75f2455c630dc7bec970dca143c8eed7c0e813"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","3301c97f51316f9c9937654c07d7a6a21e7aecb8","560c18d71dad43d675158783c3840f8c80d6d39c"],"0b75f2455c630dc7bec970dca143c8eed7c0e813":["c7d763eff38c4e1702b60d626f9c8d39f9ad8af8"],"560c18d71dad43d675158783c3840f8c80d6d39c":["4e9ae2fb2f75e4dc95285c6fa084a21034436cf1"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}