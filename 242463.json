{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","commits":[{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRef).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same BytesRef.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRef output) {\n\n    output.offset = 0;\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.length = 0;\n        return output;\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          if (idx >= output.bytes.length) {\n            output.grow(1+idx);\n          }\n          output.bytes[idx] = (byte) label;\n          output.length = input.length;\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output;\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.length = idx;\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output;\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.length = idx;\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output;\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        if (idx >= output.bytes.length) {\n          output.grow(1+idx);\n        }\n        output.bytes[idx] = (byte) label;\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  &lt;= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  <= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7543e96e2d4820e09334d36a699b998ed963f4f","date":1476121426,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  &lt;= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = 0;\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  &lt;= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/CompiledAutomaton#floor(BytesRef,BytesRefBuilder).mjava","sourceNew":"  /** Finds largest term accepted by this Automaton, that's\n   *  &lt;= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = 0;\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Finds largest term accepted by this Automaton, that's\n   *  &lt;= the provided input term.  The result is placed in\n   *  output; it's fine for output and input to point to\n   *  the same bytes.  The returned result is either the\n   *  provided output, or null if there is no floor term\n   *  (ie, the provided input term is before the first term\n   *  accepted by this Automaton). */\n  public BytesRef floor(BytesRef input, BytesRefBuilder output) {\n\n    //if (DEBUG) System.out.println(\"CA.floor input=\" + input.utf8ToString());\n\n    int state = runAutomaton.getInitialState();\n\n    // Special case empty string:\n    if (input.length == 0) {\n      if (runAutomaton.isAccept(state)) {\n        output.clear();\n        return output.get();\n      } else {\n        return null;\n      }\n    }\n\n    final List<Integer> stack = new ArrayList<>();\n\n    int idx = 0;\n    while (true) {\n      int label = input.bytes[input.offset + idx] & 0xff;\n      int nextState = runAutomaton.step(state, label);\n      //if (DEBUG) System.out.println(\"  cycle label=\" + (char) label + \" nextState=\" + nextState);\n\n      if (idx == input.length-1) {\n        if (nextState != -1 && runAutomaton.isAccept(nextState)) {\n          // Input string is accepted\n          output.grow(1+idx);\n          output.setByteAt(idx, (byte) label);\n          output.setLength(input.length);\n          //if (DEBUG) System.out.println(\"  input is accepted; return term=\" + output.utf8ToString());\n          return output.get();\n        } else {\n          nextState = -1;\n        }\n      }\n\n      if (nextState == -1) {\n\n        // Pop back to a state that has a transition\n        // <= our label:\n        while (true) {\n          int numTransitions = automaton.getNumTransitions(state);\n          if (numTransitions == 0) {\n            assert runAutomaton.isAccept(state);\n            output.setLength(idx);\n            //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n            return output.get();\n          } else {\n            automaton.getTransition(state, 0, transition);\n\n            if (label-1 < transition.min) {\n\n              if (runAutomaton.isAccept(state)) {\n                output.setLength(idx);\n                //if (DEBUG) System.out.println(\"  return \" + output.utf8ToString());\n                return output.get();\n              }\n              // pop\n              if (stack.size() == 0) {\n                //if (DEBUG) System.out.println(\"  pop ord=\" + idx + \" return null\");\n                return null;\n              } else {\n                state = stack.remove(stack.size()-1);\n                idx--;\n                //if (DEBUG) System.out.println(\"  pop ord=\" + (idx+1) + \" label=\" + (char) label + \" first trans.min=\" + (char) transitions[0].min);\n                label = input.bytes[input.offset + idx] & 0xff;\n              }\n            } else {\n              //if (DEBUG) System.out.println(\"  stop pop ord=\" + idx + \" first trans.min=\" + (char) transitions[0].min);\n              break;\n            }\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"  label=\" + (char) label + \" idx=\" + idx);\n\n        return addTail(state, output, idx, label);\n        \n      } else {\n        output.grow(1+idx);\n        output.setByteAt(idx, (byte) label);\n        stack.add(state);\n        state = nextState;\n        idx++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"b7543e96e2d4820e09334d36a699b998ed963f4f":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b1eb427f2c6beed80d1724555fc1db003ccf3030","b7543e96e2d4820e09334d36a699b998ed963f4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b7543e96e2d4820e09334d36a699b998ed963f4f"]},"commit2Childs":{"b1eb427f2c6beed80d1724555fc1db003ccf3030":["b7543e96e2d4820e09334d36a699b998ed963f4f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b7543e96e2d4820e09334d36a699b998ed963f4f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}