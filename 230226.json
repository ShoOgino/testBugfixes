{"path":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#advanceQueue(int).mjava","commits":[{"id":"b07024a7318c25225dc4d070cf6d047315b73aaf","date":1586885963,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#advanceQueue(int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Advances the queue to the next queue on flush. This carries over the the generation to the next queue and\n   * set the {@link #getMaxSeqNo()} based on the given maxNumPendingOps. This method can only be called once, subsequently\n   * the returned queue should be used.\n   * @param maxNumPendingOps the max number of possible concurrent operations that will execute on this queue after\n   *                         it was advanced. This corresponds the the number of DWPTs that own the current queue at the\n   *                         moment when this queue is advanced since each these DWPTs can increment the seqId after we\n   *                         advanced it.\n   * @return a new queue as a successor of this queue.\n   */\n  synchronized DocumentsWriterDeleteQueue advanceQueue(int maxNumPendingOps) {\n    if (advanced) {\n      throw new IllegalStateException(\"queue was already advanced\");\n    }\n    advanced = true;\n    long seqNo = getLastSequenceNumber() + maxNumPendingOps + 1;\n    maxSeqNo = seqNo;\n    return new DocumentsWriterDeleteQueue(infoStream, generation + 1, seqNo + 1,\n        // don't pass ::getMaxCompletedSeqNo here b/c otherwise we keep an reference to this queue\n        // and this will be a memory leak since the queues can't be GCed\n        () -> nextSeqNo.get() - 1);\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c247bbfab832a7aa515b3f47fbe400e337c584db"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c247bbfab832a7aa515b3f47fbe400e337c584db","date":1598297367,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#advanceQueue(int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriterDeleteQueue#advanceQueue(int).mjava","sourceNew":"  /**\n   * Advances the queue to the next queue on flush. This carries over the the generation to the next queue and\n   * set the {@link #getMaxSeqNo()} based on the given maxNumPendingOps. This method can only be called once, subsequently\n   * the returned queue should be used.\n   * @param maxNumPendingOps the max number of possible concurrent operations that will execute on this queue after\n   *                         it was advanced. This corresponds the the number of DWPTs that own the current queue at the\n   *                         moment when this queue is advanced since each these DWPTs can increment the seqId after we\n   *                         advanced it.\n   * @return a new queue as a successor of this queue.\n   */\n  synchronized DocumentsWriterDeleteQueue advanceQueue(int maxNumPendingOps) {\n    if (advanced) {\n      throw new IllegalStateException(\"queue was already advanced\");\n    }\n    advanced = true;\n    long seqNo = getLastSequenceNumber() + maxNumPendingOps + 1;\n    maxSeqNo = seqNo;\n    return new DocumentsWriterDeleteQueue(infoStream, generation + 1, seqNo + 1,\n        // don't pass ::getMaxCompletedSeqNo here b/c otherwise we keep an reference to this queue\n        // and this will be a memory leak since the queues can't be GCed\n        getPrevMaxSeqIdSupplier(nextSeqNo));\n\n  }\n\n","sourceOld":"  /**\n   * Advances the queue to the next queue on flush. This carries over the the generation to the next queue and\n   * set the {@link #getMaxSeqNo()} based on the given maxNumPendingOps. This method can only be called once, subsequently\n   * the returned queue should be used.\n   * @param maxNumPendingOps the max number of possible concurrent operations that will execute on this queue after\n   *                         it was advanced. This corresponds the the number of DWPTs that own the current queue at the\n   *                         moment when this queue is advanced since each these DWPTs can increment the seqId after we\n   *                         advanced it.\n   * @return a new queue as a successor of this queue.\n   */\n  synchronized DocumentsWriterDeleteQueue advanceQueue(int maxNumPendingOps) {\n    if (advanced) {\n      throw new IllegalStateException(\"queue was already advanced\");\n    }\n    advanced = true;\n    long seqNo = getLastSequenceNumber() + maxNumPendingOps + 1;\n    maxSeqNo = seqNo;\n    return new DocumentsWriterDeleteQueue(infoStream, generation + 1, seqNo + 1,\n        // don't pass ::getMaxCompletedSeqNo here b/c otherwise we keep an reference to this queue\n        // and this will be a memory leak since the queues can't be GCed\n        () -> nextSeqNo.get() - 1);\n\n  }\n\n","bugFix":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b07024a7318c25225dc4d070cf6d047315b73aaf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c247bbfab832a7aa515b3f47fbe400e337c584db":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c247bbfab832a7aa515b3f47fbe400e337c584db"]},"commit2Childs":{"b07024a7318c25225dc4d070cf6d047315b73aaf":["c247bbfab832a7aa515b3f47fbe400e337c584db"],"c247bbfab832a7aa515b3f47fbe400e337c584db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}