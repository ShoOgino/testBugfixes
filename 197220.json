{"path":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4a470c93b2b0f8f51241f52705fc110a01f27ad2","date":1337969379,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue());\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue());\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55110eb60c5105294fc2ae7912d82b750865aa58","date":1341389822,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7460755aa94143153400f49c8ac2746f5d092e1a","date":1345536974,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = (IndexInput) in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = (IndexInput) in.clone();\n          final IndexInput clone2 = (IndexInput) in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2","date":1346834651,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/FixedGapTermsIndexReader.FieldIndexData.CoreFieldIndex#CoreFieldIndex(long,long,long,long,int).mjava","sourceNew":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","sourceOld":"      public CoreFieldIndex(long indexStart, long termsStart, long packedIndexStart, long packedOffsetsStart, int numIndexTerms) throws IOException {\n\n        this.termsStart = termsStart;\n        termBytesStart = termBytes.getPointer();\n\n        IndexInput clone = in.clone();\n        clone.seek(indexStart);\n\n        // -1 is passed to mean \"don't load term index\", but\n        // if we are then later loaded it's overwritten with\n        // a real value\n        assert indexDivisor > 0;\n\n        this.numIndexTerms = 1+(numIndexTerms-1) / indexDivisor;\n\n        assert this.numIndexTerms  > 0: \"numIndexTerms=\" + numIndexTerms + \" indexDivisor=\" + indexDivisor;\n\n        if (indexDivisor == 1) {\n          // Default (load all index terms) is fast -- slurp in the images from disk:\n          \n          try {\n            final long numTermBytes = packedIndexStart - indexStart;\n            termBytes.copy(clone, numTermBytes);\n\n            // records offsets into main terms dict file\n            termsDictOffsets = PackedInts.getReader(clone);\n            assert termsDictOffsets.size() == numIndexTerms;\n\n            // records offsets into byte[] term data\n            termOffsets = PackedInts.getReader(clone);\n            assert termOffsets.size() == 1+numIndexTerms;\n          } finally {\n            clone.close();\n          }\n        } else {\n          // Get packed iterators\n          final IndexInput clone1 = in.clone();\n          final IndexInput clone2 = in.clone();\n\n          try {\n            // Subsample the index terms\n            clone1.seek(packedIndexStart);\n            final PackedInts.ReaderIterator termsDictOffsetsIter = PackedInts.getReaderIterator(clone1, PackedInts.DEFAULT_BUFFER_SIZE);\n\n            clone2.seek(packedOffsetsStart);\n            final PackedInts.ReaderIterator termOffsetsIter = PackedInts.getReaderIterator(clone2,  PackedInts.DEFAULT_BUFFER_SIZE);\n\n            // TODO: often we can get by w/ fewer bits per\n            // value, below.. .but this'd be more complex:\n            // we'd have to try @ fewer bits and then grow\n            // if we overflowed it.\n\n            PackedInts.Mutable termsDictOffsetsM = PackedInts.getMutable(this.numIndexTerms, termsDictOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n            PackedInts.Mutable termOffsetsM = PackedInts.getMutable(this.numIndexTerms+1, termOffsetsIter.getBitsPerValue(), PackedInts.DEFAULT);\n\n            termsDictOffsets = termsDictOffsetsM;\n            termOffsets = termOffsetsM;\n\n            int upto = 0;\n\n            long termOffsetUpto = 0;\n\n            while(upto < this.numIndexTerms) {\n              // main file offset copies straight over\n              termsDictOffsetsM.set(upto, termsDictOffsetsIter.next());\n\n              termOffsetsM.set(upto, termOffsetUpto);\n\n              long termOffset = termOffsetsIter.next();\n              long nextTermOffset = termOffsetsIter.next();\n              final int numTermBytes = (int) (nextTermOffset - termOffset);\n\n              clone.seek(indexStart + termOffset);\n              assert indexStart + termOffset < clone.length() : \"indexStart=\" + indexStart + \" termOffset=\" + termOffset + \" len=\" + clone.length();\n              assert indexStart + termOffset + numTermBytes < clone.length();\n\n              termBytes.copy(clone, numTermBytes);\n              termOffsetUpto += numTermBytes;\n\n              upto++;\n              if (upto == this.numIndexTerms) {\n                break;\n              }\n\n              // skip terms:\n              termsDictOffsetsIter.next();\n              for(int i=0;i<indexDivisor-2;i++) {\n                termOffsetsIter.next();\n                termsDictOffsetsIter.next();\n              }\n            }\n            termOffsetsM.set(upto, termOffsetUpto);\n\n          } finally {\n            clone1.close();\n            clone2.close();\n            clone.close();\n          }\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"001b25b42373b22a52f399dbf072f1224632e8e6":["55110eb60c5105294fc2ae7912d82b750865aa58","7460755aa94143153400f49c8ac2746f5d092e1a"],"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["7460755aa94143153400f49c8ac2746f5d092e1a"],"55110eb60c5105294fc2ae7912d82b750865aa58":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4a470c93b2b0f8f51241f52705fc110a01f27ad2","55110eb60c5105294fc2ae7912d82b750865aa58"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7460755aa94143153400f49c8ac2746f5d092e1a":["55110eb60c5105294fc2ae7912d82b750865aa58"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"]},"commit2Childs":{"001b25b42373b22a52f399dbf072f1224632e8e6":[],"55110eb60c5105294fc2ae7912d82b750865aa58":["001b25b42373b22a52f399dbf072f1224632e8e6","fe33227f6805edab2036cbb80645cc4e2d1fa424","7460755aa94143153400f49c8ac2746f5d092e1a"],"3e45d45bc3730ddd1341f4eb6025f33b8482e6e2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4a470c93b2b0f8f51241f52705fc110a01f27ad2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4a470c93b2b0f8f51241f52705fc110a01f27ad2":["55110eb60c5105294fc2ae7912d82b750865aa58","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"7460755aa94143153400f49c8ac2746f5d092e1a":["001b25b42373b22a52f399dbf072f1224632e8e6","3e45d45bc3730ddd1341f4eb6025f33b8482e6e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}