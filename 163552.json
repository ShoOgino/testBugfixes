{"path":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","commits":[{"id":"92ff363eabbaa0b7706976aea7997bb2f620caa0","date":1412866130,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.getNormType() != null) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","pathOld":"/dev/null","sourceNew":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.getNormType() != null) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05da2d758a6089e737cdfc230e57a51b472b94b6","date":1413392310,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","sourceNew":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.hasNorms()) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","sourceOld":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.getNormType() != null) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","date":1413458798,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","sourceNew":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.hasNorms()) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","sourceOld":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.getNormType() != null) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71387d8cb6923eb831b17a8b734608ba2e21c653","date":1414126093,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/backward-codecs/src/test/org/apache/lucene/codecs/lucene40/TestLucene40FieldInfoFormat#addAttributes(FieldInfo).mjava","sourceNew":null,"sourceOld":"  // but we have more internal typing information, previously recorded in fieldinfos.\n  // this is exposed via attributes (so our writer expects them to be set by the dv impl)\n  @Override\n  protected void addAttributes(FieldInfo fi) {\n    DocValuesType dvType = fi.getDocValuesType();\n    if (dvType != null) {\n      switch (dvType) {\n        case BINARY: \n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_STRAIGHT.name());\n          break;\n        case NUMERIC:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_32.name());\n          break;\n        case SORTED:\n          fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_DV_TYPE_KEY, LegacyDocValuesType.BYTES_FIXED_SORTED.name());\n          break;\n        default:\n          throw new AssertionError();\n      }\n    }\n    \n    if (fi.hasNorms()) {\n      fi.putAttribute(Lucene40FieldInfosFormat.LEGACY_NORM_TYPE_KEY, LegacyDocValuesType.FIXED_INTS_8.name());\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["92ff363eabbaa0b7706976aea7997bb2f620caa0"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":["55980207f1977bd1463465de1659b821347e2fa8","05da2d758a6089e737cdfc230e57a51b472b94b6"],"55980207f1977bd1463465de1659b821347e2fa8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","92ff363eabbaa0b7706976aea7997bb2f620caa0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92ff363eabbaa0b7706976aea7997bb2f620caa0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["05da2d758a6089e737cdfc230e57a51b472b94b6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71387d8cb6923eb831b17a8b734608ba2e21c653"]},"commit2Childs":{"05da2d758a6089e737cdfc230e57a51b472b94b6":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","71387d8cb6923eb831b17a8b734608ba2e21c653"],"c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84":[],"55980207f1977bd1463465de1659b821347e2fa8":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55980207f1977bd1463465de1659b821347e2fa8","92ff363eabbaa0b7706976aea7997bb2f620caa0"],"92ff363eabbaa0b7706976aea7997bb2f620caa0":["05da2d758a6089e737cdfc230e57a51b472b94b6","55980207f1977bd1463465de1659b821347e2fa8"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c93b0dbaa6abe99bc8d1b476bcacc27b324b2b84","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}