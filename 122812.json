{"path":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","commits":[{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  protected Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else {\n      if (format == SegmentInfos.FORMAT_CHECKSUM)\n        sFormat = \"FORMAT_CHECKSUM [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_DEL_COUNT)\n        sFormat = \"FORMAT_DEL_COUNT [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_HAS_PROX)\n        sFormat = \"FORMAT_HAS_PROX [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_USER_DATA)\n        sFormat = \"FORMAT_USER_DATA [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n        sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_FLEX_POSTINGS)\n        sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 3.1]\";\n      else if (format < SegmentInfos.CURRENT_FORMAT) {\n        sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n        skip = true;\n      } else {\n        sFormat = format + \" [Lucene 1.3 or prior]\";\n      }\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c","2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c","date":1270671893,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else {\n      if (format == SegmentInfos.FORMAT_CHECKSUM)\n        sFormat = \"FORMAT_CHECKSUM [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_DEL_COUNT)\n        sFormat = \"FORMAT_DEL_COUNT [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_HAS_PROX)\n        sFormat = \"FORMAT_HAS_PROX [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_USER_DATA)\n        sFormat = \"FORMAT_USER_DATA [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n        sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_FLEX_POSTINGS)\n        sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 3.1]\";\n      else if (format < SegmentInfos.CURRENT_FORMAT) {\n        sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n        skip = true;\n      } else {\n        sFormat = format + \" [Lucene 1.3 or prior]\";\n      }\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  protected Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else {\n      if (format == SegmentInfos.FORMAT_CHECKSUM)\n        sFormat = \"FORMAT_CHECKSUM [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_DEL_COUNT)\n        sFormat = \"FORMAT_DEL_COUNT [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_HAS_PROX)\n        sFormat = \"FORMAT_HAS_PROX [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_USER_DATA)\n        sFormat = \"FORMAT_USER_DATA [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n        sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_FLEX_POSTINGS)\n        sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 3.1]\";\n      else if (format < SegmentInfos.CURRENT_FORMAT) {\n        sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n        skip = true;\n      } else {\n        sFormat = format + \" [Lucene 1.3 or prior]\";\n      }\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6267e1ce56c2eec111425690cd04e251b6f14952","date":1275222352,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    else if (format == SegmentInfos.FORMAT_4_0)\n      sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 4.0]\";\n    else if (format < SegmentInfos.CURRENT_FORMAT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT)\n      sFormat = \"FORMAT [Lucene Pre-2.1]\";\n    if (format == SegmentInfos.FORMAT_LOCKLESS)\n      sFormat = \"FORMAT_LOCKLESS [Lucene 2.1]\";\n    else if (format == SegmentInfos.FORMAT_SINGLE_NORM_FILE)\n      sFormat = \"FORMAT_SINGLE_NORM_FILE [Lucene 2.2]\";\n    else if (format == SegmentInfos.FORMAT_SHARED_DOC_STORE)\n      sFormat = \"FORMAT_SHARED_DOC_STORE [Lucene 2.3]\";\n    else {\n      if (format == SegmentInfos.FORMAT_CHECKSUM)\n        sFormat = \"FORMAT_CHECKSUM [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_DEL_COUNT)\n        sFormat = \"FORMAT_DEL_COUNT [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_HAS_PROX)\n        sFormat = \"FORMAT_HAS_PROX [Lucene 2.4]\";\n      else if (format == SegmentInfos.FORMAT_USER_DATA)\n        sFormat = \"FORMAT_USER_DATA [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n        sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n      else if (format == SegmentInfos.FORMAT_FLEX_POSTINGS)\n        sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 3.1]\";\n      else if (format < SegmentInfos.CURRENT_FORMAT) {\n        sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n        skip = true;\n      } else {\n        sFormat = format + \" [Lucene 1.3 or prior]\";\n      }\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0cd8367c3d48e4b63dee1895a261d4986c716bbb","date":1279637747,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    else if (format == SegmentInfos.FORMAT_4_0)\n      sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 4.0]\";\n    else if (format < SegmentInfos.CURRENT_FORMAT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == SegmentInfos.FORMAT_DIAGNOSTICS)\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    else if (format == SegmentInfos.FORMAT_4_0)\n      sFormat = \"FORMAT_FLEX_POSTINGS [Lucene 4.0]\";\n    else if (format < SegmentInfos.CURRENT_FORMAT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6","date":1288888250,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a493e6d0c3ad86bd55c0a1360d110142e948f2bd","date":1289406991,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getCodecInfo();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getCodecInfo();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bc084aae57b2027dcd1e8786dabc47987dce76b","date":1289596643,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getCodecInfo();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c498d3f8d75170b121f5eda2c6210ac5beb5d411","date":1289726298,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getCodecInfo();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d5efdc434c21e20adcb20d316e227be9eaf377d2","date":1292842437,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos();\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final String codec = info.getCodec().name;\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"70ad682703b8585f5d0a637efec044d57ec05efb","date":1294259117,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        msg(\"    size (MB)=\" + nf.format(info.sizeInBytes()/(1024.*1024.)));\n        segInfoStat.sizeMB = info.sizeInBytes()/(1024.*1024.);\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d4da1ea7abe50a573d0b5315a952d314daa7b86","date":1299597057,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ebb742ffd3fae76a577a68de595d711f43e6944","date":1305546231,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e8d7ba2175f47e280231533f7d3016249cea88b","date":1307711934,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fec0d7b897279d9441884bfaa0cb01dd9a3cd58c","date":1307835543,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db34814b6371cfa39b9622ddf3f6bc32b683f18b","date":1307872232,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ed208afa1e7aa98899ddb1dedfddedddf898253","date":1308079587,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n      msg(\"No problems were detected with this index.\\n\");\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca791416b7d9cc876025db4aea7ec799e8167c0e","date":1308701127,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_SEGMENT_RECORDS_VERSION) {\n      sFormat = \"FORMAT_SEGMENT_RECORDS_VERSION [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_FLEX) {\n      sFormat = \"FORMAT_FLEX [Lucene 4.0+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4aa91b365d4819eed673110a366d7ce611fdab1b","date":1308730304,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_SEGMENT_RECORDS_VERSION) {\n      sFormat = \"FORMAT_SEGMENT_RECORDS_VERSION [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_FLEX) {\n      sFormat = \"FORMAT_FLEX [Lucene 4.0+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3e5cfcd920648fdd531192a41ad4087285aecc1","date":1308920374,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments + \" version=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.deletedDocs.count() != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (reader.deletedDocs.count() > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs deletedDocs.count()=\" + reader.deletedDocs.count());\n          }\n          if (info.docCount - numDocs != info.getDelCount()){\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/CheckIndex#checkIndex(List[String],CodecProvider).mjava","sourceNew":null,"sourceOld":"  /** Returns a {@link Status} instance detailing\n   *  the state of the index.\n   * \n   *  @param onlySegments list of specific segment names to check\n   *\n   *  <p>As this method checks every byte in the specified\n   *  segments, on a large index it can take quite a long\n   *  time to run.\n   *\n   *  <p><b>WARNING</b>: make sure\n   *  you only call this when the index is not opened by any\n   *  writer. */\n  public Status checkIndex(List<String> onlySegments, CodecProvider codecs) throws IOException {\n    NumberFormat nf = NumberFormat.getInstance();\n    SegmentInfos sis = new SegmentInfos(codecs);\n    Status result = new Status();\n    result.dir = dir;\n    try {\n      sis.read(dir, codecs);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read any segments file in directory\");\n      result.missingSegments = true;\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      return result;\n    }\n\n    // find the oldest and newest segment versions\n    String oldest = Integer.toString(Integer.MAX_VALUE), newest = Integer.toString(Integer.MIN_VALUE);\n    String oldSegs = null;\n    boolean foundNonNullVersion = false;\n    Comparator<String> versionComparator = StringHelper.getVersionComparator();\n    for (SegmentInfo si : sis) {\n      String version = si.getVersion();\n      if (version == null) {\n        // pre-3.1 segment\n        oldSegs = \"pre-3.1\";\n      } else {\n        foundNonNullVersion = true;\n        if (versionComparator.compare(version, oldest) < 0) {\n          oldest = version;\n        }\n        if (versionComparator.compare(version, newest) > 0) {\n          newest = version;\n        }\n      }\n    }\n\n    final int numSegments = sis.size();\n    final String segmentsFileName = sis.getCurrentSegmentFileName();\n    IndexInput input = null;\n    try {\n      input = dir.openInput(segmentsFileName, IOContext.DEFAULT);\n    } catch (Throwable t) {\n      msg(\"ERROR: could not open segments file in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.cantOpenSegments = true;\n      return result;\n    }\n    int format = 0;\n    try {\n      format = input.readInt();\n    } catch (Throwable t) {\n      msg(\"ERROR: could not read segment file version in directory\");\n      if (infoStream != null)\n        t.printStackTrace(infoStream);\n      result.missingSegmentVersion = true;\n      return result;\n    } finally {\n      if (input != null)\n        input.close();\n    }\n\n    String sFormat = \"\";\n    boolean skip = false;\n\n    if (format == DefaultSegmentInfosWriter.FORMAT_DIAGNOSTICS) {\n      sFormat = \"FORMAT_DIAGNOSTICS [Lucene 2.9]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_HAS_VECTORS) {\n      sFormat = \"FORMAT_HAS_VECTORS [Lucene 3.1]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_3_1) {\n      sFormat = \"FORMAT_3_1 [Lucene 3.1+]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_4_0) {\n      sFormat = \"FORMAT_4_0 [Lucene 4.0]\";\n    } else if (format == DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      throw new RuntimeException(\"BUG: You should update this tool!\");\n    } else if (format < DefaultSegmentInfosWriter.FORMAT_CURRENT) {\n      sFormat = \"int=\" + format + \" [newer version of Lucene than this tool supports]\";\n      skip = true;\n    } else if (format > DefaultSegmentInfosWriter.FORMAT_MINIMUM) {\n      sFormat = \"int=\" + format + \" [older version of Lucene than this tool supports]\";\n      skip = true;\n    }\n\n    result.segmentsFileName = segmentsFileName;\n    result.numSegments = numSegments;\n    result.segmentFormat = sFormat;\n    result.userData = sis.getUserData();\n    String userDataString;\n    if (sis.getUserData().size() > 0) {\n      userDataString = \" userData=\" + sis.getUserData();\n    } else {\n      userDataString = \"\";\n    }\n\n    String versionString = null;\n    if (oldSegs != null) {\n      if (foundNonNullVersion) {\n        versionString = \"versions=[\" + oldSegs + \" .. \" + newest + \"]\";\n      } else {\n        versionString = \"version=\" + oldSegs;\n      }\n    } else {\n      versionString = oldest.equals(newest) ? ( \"version=\" + oldest ) : (\"versions=[\" + oldest + \" .. \" + newest + \"]\");\n    }\n\n    msg(\"Segments file=\" + segmentsFileName + \" numSegments=\" + numSegments\n        + \" \" + versionString + \" format=\" + sFormat + userDataString);\n\n    if (onlySegments != null) {\n      result.partial = true;\n      if (infoStream != null)\n        infoStream.print(\"\\nChecking only these segments:\");\n      for (String s : onlySegments) {\n        if (infoStream != null)\n          infoStream.print(\" \" + s);\n      }\n      result.segmentsChecked.addAll(onlySegments);\n      msg(\":\");\n    }\n\n    if (skip) {\n      msg(\"\\nERROR: this index appears to be created by a newer version of Lucene than this tool was compiled on; please re-compile this tool on the matching version of Lucene; exiting\");\n      result.toolOutOfDate = true;\n      return result;\n    }\n\n\n    result.newSegments = (SegmentInfos) sis.clone();\n    result.newSegments.clear();\n    result.maxSegmentName = -1;\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = sis.info(i);\n      int segmentName = Integer.parseInt(info.name.substring(1), Character.MAX_RADIX);\n      if (segmentName > result.maxSegmentName) {\n        result.maxSegmentName = segmentName;\n      }\n      if (onlySegments != null && !onlySegments.contains(info.name))\n        continue;\n      Status.SegmentInfoStatus segInfoStat = new Status.SegmentInfoStatus();\n      result.segmentInfos.add(segInfoStat);\n      msg(\"  \" + (1+i) + \" of \" + numSegments + \": name=\" + info.name + \" docCount=\" + info.docCount);\n      segInfoStat.name = info.name;\n      segInfoStat.docCount = info.docCount;\n\n      int toLoseDocCount = info.docCount;\n\n      SegmentReader reader = null;\n\n      try {\n        final SegmentCodecs codec = info.getSegmentCodecs();\n        msg(\"    codec=\" + codec);\n        segInfoStat.codec = codec;\n        msg(\"    compound=\" + info.getUseCompoundFile());\n        segInfoStat.compound = info.getUseCompoundFile();\n        msg(\"    hasProx=\" + info.getHasProx());\n        segInfoStat.hasProx = info.getHasProx();\n        msg(\"    numFiles=\" + info.files().size());\n        segInfoStat.numFiles = info.files().size();\n        segInfoStat.sizeMB = info.sizeInBytes(true)/(1024.*1024.);\n        msg(\"    size (MB)=\" + nf.format(segInfoStat.sizeMB));\n        Map<String,String> diagnostics = info.getDiagnostics();\n        segInfoStat.diagnostics = diagnostics;\n        if (diagnostics.size() > 0) {\n          msg(\"    diagnostics = \" + diagnostics);\n        }\n\n        final int docStoreOffset = info.getDocStoreOffset();\n        if (docStoreOffset != -1) {\n          msg(\"    docStoreOffset=\" + docStoreOffset);\n          segInfoStat.docStoreOffset = docStoreOffset;\n          msg(\"    docStoreSegment=\" + info.getDocStoreSegment());\n          segInfoStat.docStoreSegment = info.getDocStoreSegment();\n          msg(\"    docStoreIsCompoundFile=\" + info.getDocStoreIsCompoundFile());\n          segInfoStat.docStoreCompoundFile = info.getDocStoreIsCompoundFile();\n        }\n\n        final String delFileName = info.getDelFileName();\n        if (delFileName == null){\n          msg(\"    no deletions\");\n          segInfoStat.hasDeletions = false;\n        }\n        else{\n          msg(\"    has deletions [delFileName=\" + delFileName + \"]\");\n          segInfoStat.hasDeletions = true;\n          segInfoStat.deletionsFileName = delFileName;\n        }\n        if (infoStream != null)\n          infoStream.print(\"    test: open reader.........\");\n        reader = SegmentReader.get(true, info, IndexReader.DEFAULT_TERMS_INDEX_DIVISOR, IOContext.DEFAULT);\n\n        segInfoStat.openReaderPassed = true;\n\n        final int numDocs = reader.numDocs();\n        toLoseDocCount = numDocs;\n        if (reader.hasDeletions()) {\n          if (reader.liveDocs.count() != info.docCount - info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + (info.docCount - info.getDelCount()) + \" vs reader=\" + reader.liveDocs.count());\n          }\n          if ((info.docCount-reader.liveDocs.count()) > reader.maxDoc()) {\n            throw new RuntimeException(\"too many deleted docs: maxDoc()=\" + reader.maxDoc() + \" vs del count=\" + (info.docCount-reader.liveDocs.count()));\n          }\n          if (info.docCount - numDocs != info.getDelCount()) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          segInfoStat.numDeleted = info.docCount - numDocs;\n          msg(\"OK [\" + (segInfoStat.numDeleted) + \" deleted docs]\");\n        } else {\n          if (info.getDelCount() != 0) {\n            throw new RuntimeException(\"delete count mismatch: info=\" + info.getDelCount() + \" vs reader=\" + (info.docCount - numDocs));\n          }\n          msg(\"OK\");\n        }\n        if (reader.maxDoc() != info.docCount)\n          throw new RuntimeException(\"SegmentReader.maxDoc() \" + reader.maxDoc() + \" != SegmentInfos.docCount \" + info.docCount);\n\n        // Test getFieldNames()\n        if (infoStream != null) {\n          infoStream.print(\"    test: fields..............\");\n        }         \n        Collection<String> fieldNames = reader.getFieldNames(IndexReader.FieldOption.ALL);\n        msg(\"OK [\" + fieldNames.size() + \" fields]\");\n        segInfoStat.numFields = fieldNames.size();\n        \n        // Test Field Norms\n        segInfoStat.fieldNormStatus = testFieldNorms(fieldNames, reader);\n\n        // Test the Term Index\n        segInfoStat.termIndexStatus = testTermIndex(reader);\n\n        // Test Stored Fields\n        segInfoStat.storedFieldStatus = testStoredFields(info, reader, nf);\n\n        // Test Term Vectors\n        segInfoStat.termVectorStatus = testTermVectors(info, reader, nf);\n        \n        segInfoStat.docValuesStatus = testDocValues(info, reader);\n\n        // Rethrow the first exception we encountered\n        //  This will cause stats for failed segments to be incremented properly\n        if (segInfoStat.fieldNormStatus.error != null) {\n          throw new RuntimeException(\"Field Norm test failed\");\n        } else if (segInfoStat.termIndexStatus.error != null) {\n          throw new RuntimeException(\"Term Index test failed\");\n        } else if (segInfoStat.storedFieldStatus.error != null) {\n          throw new RuntimeException(\"Stored Field test failed\");\n        } else if (segInfoStat.termVectorStatus.error != null) {\n          throw new RuntimeException(\"Term Vector test failed\");\n        }  else if (segInfoStat.docValuesStatus.error != null) {\n          throw new RuntimeException(\"DocValues test failed\");\n        }\n\n        msg(\"\");\n\n      } catch (Throwable t) {\n        msg(\"FAILED\");\n        String comment;\n        comment = \"fixIndex() would remove reference to this segment\";\n        msg(\"    WARNING: \" + comment + \"; full exception:\");\n        if (infoStream != null)\n          t.printStackTrace(infoStream);\n        msg(\"\");\n        result.totLoseDocCount += toLoseDocCount;\n        result.numBadSegments++;\n        continue;\n      } finally {\n        if (reader != null)\n          reader.close();\n      }\n\n      // Keeper\n      result.newSegments.add((SegmentInfo) info.clone());\n    }\n\n    if (0 == result.numBadSegments) {\n      result.clean = true;\n    } else\n      msg(\"WARNING: \" + result.numBadSegments + \" broken segments (containing \" + result.totLoseDocCount + \" documents) detected\");\n\n    if ( ! (result.validCounter = (result.maxSegmentName < sis.counter))) {\n      result.clean = false;\n      result.newSegments.counter = result.maxSegmentName + 1; \n      msg(\"ERROR: Next segment name counter \" + sis.counter + \" is not greater than max segment name \" + result.maxSegmentName);\n    }\n    \n    if (result.clean) {\n      msg(\"No problems were detected with this index.\\n\");\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["e3e5cfcd920648fdd531192a41ad4087285aecc1"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["db34814b6371cfa39b9622ddf3f6bc32b683f18b"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","d5efdc434c21e20adcb20d316e227be9eaf377d2"],"1d4da1ea7abe50a573d0b5315a952d314daa7b86":["d5efdc434c21e20adcb20d316e227be9eaf377d2"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["1d4da1ea7abe50a573d0b5315a952d314daa7b86","5ebb742ffd3fae76a577a68de595d711f43e6944"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","1d4da1ea7abe50a573d0b5315a952d314daa7b86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["817d8435e9135b756f08ce6710ab0baac51bdf88","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"ca791416b7d9cc876025db4aea7ec799e8167c0e":["db34814b6371cfa39b9622ddf3f6bc32b683f18b"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["1d4da1ea7abe50a573d0b5315a952d314daa7b86","2e8d7ba2175f47e280231533f7d3016249cea88b"],"70ad682703b8585f5d0a637efec044d57ec05efb":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","d5efdc434c21e20adcb20d316e227be9eaf377d2"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["85a883878c0af761245ab048babc63d099f835f3","8bc084aae57b2027dcd1e8786dabc47987dce76b"],"85a883878c0af761245ab048babc63d099f835f3":["0cd8367c3d48e4b63dee1895a261d4986c716bbb","a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["6267e1ce56c2eec111425690cd04e251b6f14952"],"5f4e87790277826a2aea119328600dfb07761f32":["6267e1ce56c2eec111425690cd04e251b6f14952","0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"d5efdc434c21e20adcb20d316e227be9eaf377d2":["8bc084aae57b2027dcd1e8786dabc47987dce76b"],"2553b00f699380c64959ccb27991289aae87be2e":["9ed208afa1e7aa98899ddb1dedfddedddf898253","e3e5cfcd920648fdd531192a41ad4087285aecc1"],"db34814b6371cfa39b9622ddf3f6bc32b683f18b":["fec0d7b897279d9441884bfaa0cb01dd9a3cd58c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","db34814b6371cfa39b9622ddf3f6bc32b683f18b"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["2553b00f699380c64959ccb27991289aae87be2e","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"7b91922b55d15444d554721b352861d028eb8278":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"8bc084aae57b2027dcd1e8786dabc47987dce76b":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"6267e1ce56c2eec111425690cd04e251b6f14952":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"5ebb742ffd3fae76a577a68de595d711f43e6944":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["70ad682703b8585f5d0a637efec044d57ec05efb","1d4da1ea7abe50a573d0b5315a952d314daa7b86"],"fec0d7b897279d9441884bfaa0cb01dd9a3cd58c":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"4aa91b365d4819eed673110a366d7ce611fdab1b":["ca791416b7d9cc876025db4aea7ec799e8167c0e"],"e3e5cfcd920648fdd531192a41ad4087285aecc1":["4aa91b365d4819eed673110a366d7ce611fdab1b"],"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6":["0cd8367c3d48e4b63dee1895a261d4986c716bbb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7b91922b55d15444d554721b352861d028eb8278"]},"commit2Childs":{"b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c":["6267e1ce56c2eec111425690cd04e251b6f14952"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["ddc4c914be86e34b54f70023f45a60fa7f04e929","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["85a883878c0af761245ab048babc63d099f835f3","8bc084aae57b2027dcd1e8786dabc47987dce76b"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["b43b719dab44d1ccc5ee5b6e01c50f1ee86bb76c"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["d083e83f225b11e5fdd900e83d26ddb385b6955c"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"1d4da1ea7abe50a573d0b5315a952d314daa7b86":["2e8d7ba2175f47e280231533f7d3016249cea88b","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","d619839baa8ce5503e496b94a9e42ad6f079293f"],"2e8d7ba2175f47e280231533f7d3016249cea88b":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","fec0d7b897279d9441884bfaa0cb01dd9a3cd58c"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","7b91922b55d15444d554721b352861d028eb8278"],"ca791416b7d9cc876025db4aea7ec799e8167c0e":["4aa91b365d4819eed673110a366d7ce611fdab1b"],"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["9ed208afa1e7aa98899ddb1dedfddedddf898253"],"70ad682703b8585f5d0a637efec044d57ec05efb":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"c498d3f8d75170b121f5eda2c6210ac5beb5d411":["70ad682703b8585f5d0a637efec044d57ec05efb"],"85a883878c0af761245ab048babc63d099f835f3":["c498d3f8d75170b121f5eda2c6210ac5beb5d411"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"0cd8367c3d48e4b63dee1895a261d4986c716bbb":["85a883878c0af761245ab048babc63d099f835f3","5f4e87790277826a2aea119328600dfb07761f32","2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"d5efdc434c21e20adcb20d316e227be9eaf377d2":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","1d4da1ea7abe50a573d0b5315a952d314daa7b86","70ad682703b8585f5d0a637efec044d57ec05efb"],"2553b00f699380c64959ccb27991289aae87be2e":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"db34814b6371cfa39b9622ddf3f6bc32b683f18b":["639c36565ce03aed5b0fce7c9e4448e53a1f7efd","ca791416b7d9cc876025db4aea7ec799e8167c0e","9ed208afa1e7aa98899ddb1dedfddedddf898253"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"9ed208afa1e7aa98899ddb1dedfddedddf898253":["2553b00f699380c64959ccb27991289aae87be2e"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"5ebb742ffd3fae76a577a68de595d711f43e6944":["2e8d7ba2175f47e280231533f7d3016249cea88b"],"8bc084aae57b2027dcd1e8786dabc47987dce76b":["c498d3f8d75170b121f5eda2c6210ac5beb5d411","d5efdc434c21e20adcb20d316e227be9eaf377d2"],"6267e1ce56c2eec111425690cd04e251b6f14952":["0cd8367c3d48e4b63dee1895a261d4986c716bbb","5f4e87790277826a2aea119328600dfb07761f32"],"7b91922b55d15444d554721b352861d028eb8278":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["5ebb742ffd3fae76a577a68de595d711f43e6944"],"fec0d7b897279d9441884bfaa0cb01dd9a3cd58c":["db34814b6371cfa39b9622ddf3f6bc32b683f18b"],"4aa91b365d4819eed673110a366d7ce611fdab1b":["e3e5cfcd920648fdd531192a41ad4087285aecc1"],"e3e5cfcd920648fdd531192a41ad4087285aecc1":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","2553b00f699380c64959ccb27991289aae87be2e"],"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}