{"path":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","commits":[{"id":"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","date":1406137403,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d91746c67539428e26abf078daf1d830c2dec3f4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = LegacyNumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = LegacyNumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = LegacyNumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = LegacyNumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb","date":1457059932,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = LegacyNumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = LegacyNumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = LegacyNumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = LegacyNumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","bugFix":["770342641f7b505eaa8dccdc666158bff2419109"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = LegacyNumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = LegacyNumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = LegacyNumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = LegacyNumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d81baa64023bbb9b43f6d929ee168b105940d30","date":1486492702,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            break;\n          case DATE:\n            startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            break;\n          case INTEGER:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            break;\n          case DATE:\n            endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            break;\n          case INTEGER:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            } else {\n              startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            }\n            break;\n          case INT:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumericType()) {\n          case LONG:\n            if (schemaField.getType() instanceof TrieDateField) {\n              endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            } else {\n              endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            }\n            break;\n          case INT:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d91746c67539428e26abf078daf1d830c2dec3f4","date":1500321307,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            break;\n          case DATE:\n            startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            break;\n          case INTEGER:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          if (startLimit == Long.MAX_VALUE) {\n            /*\n             * This interval can match no docs\n             */\n            includeNoDocs = true;\n          } else {\n            startLimit++;\n          }\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            break;\n          case DATE:\n            endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            break;\n          case INTEGER:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          if (endLimit == Long.MIN_VALUE) {\n            /*\n             * This interval can match no docs\n             */\n            includeNoDocs = true;\n          } else {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            break;\n          case DATE:\n            startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            break;\n          case INTEGER:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            break;\n          case DATE:\n            endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            break;\n          case INTEGER:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","bugFix":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","pathOld":"solr/core/src/java/org/apache/solr/request/IntervalFacets.FacetInterval#setNumericLimits(SchemaField).mjava","sourceNew":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            break;\n          case DATE:\n            startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            break;\n          case INTEGER:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          if (startLimit == Long.MAX_VALUE) {\n            /*\n             * This interval can match no docs\n             */\n            includeNoDocs = true;\n          } else {\n            startLimit++;\n          }\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            break;\n          case DATE:\n            endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            break;\n          case INTEGER:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          if (endLimit == Long.MIN_VALUE) {\n            /*\n             * This interval can match no docs\n             */\n            includeNoDocs = true;\n          } else {\n            endLimit--;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    /**\n     * Set startLimit and endLimit for numeric values. The limits in this case\n     * are going to be the <code>long</code> representation of the original\n     * value. <code>startLimit</code> will be incremented by one in case of the\n     * interval start being exclusive. <code>endLimit</code> will be decremented by\n     * one in case of the interval end being exclusive.\n     */\n    private void setNumericLimits(SchemaField schemaField) {\n      if (start == null) {\n        startLimit = Long.MIN_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            startLimit = (long) schemaField.getType().toObject(schemaField, start);\n            break;\n          case DATE:\n            startLimit = ((Date) schemaField.getType().toObject(schemaField, start)).getTime();\n            break;\n          case INTEGER:\n            startLimit = ((Integer) schemaField.getType().toObject(schemaField, start)).longValue();\n            break;\n          case FLOAT:\n            startLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, start));\n            break;\n          case DOUBLE:\n            startLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, start));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (startOpen) {\n          startLimit++;\n        }\n      }\n\n\n      if (end == null) {\n        endLimit = Long.MAX_VALUE;\n      } else {\n        switch (schemaField.getType().getNumberType()) {\n          case LONG:\n            endLimit = (long) schemaField.getType().toObject(schemaField, end);\n            break;\n          case DATE:\n            endLimit = ((Date) schemaField.getType().toObject(schemaField, end)).getTime();\n            break;\n          case INTEGER:\n            endLimit = ((Integer) schemaField.getType().toObject(schemaField, end)).longValue();\n            break;\n          case FLOAT:\n            endLimit = NumericUtils.floatToSortableInt((float) schemaField.getType().toObject(schemaField, end));\n            break;\n          case DOUBLE:\n            endLimit = NumericUtils.doubleToSortableLong((double) schemaField.getType().toObject(schemaField, end));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        if (endOpen) {\n          endLimit--;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3d81baa64023bbb9b43f6d929ee168b105940d30":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["3d81baa64023bbb9b43f6d929ee168b105940d30","d91746c67539428e26abf078daf1d830c2dec3f4"],"d91746c67539428e26abf078daf1d830c2dec3f4":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["770342641f7b505eaa8dccdc666158bff2419109","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d91746c67539428e26abf078daf1d830c2dec3f4"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["770342641f7b505eaa8dccdc666158bff2419109"]},"commit2Childs":{"3d81baa64023bbb9b43f6d929ee168b105940d30":["aaf90fc29510e72665ac7934f34c3d1c25efad64","d91746c67539428e26abf078daf1d830c2dec3f4"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"d91746c67539428e26abf078daf1d830c2dec3f4":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["3d81baa64023bbb9b43f6d929ee168b105940d30"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["770342641f7b505eaa8dccdc666158bff2419109"],"770342641f7b505eaa8dccdc666158bff2419109":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","a0e7cdd0facd912df00ec53365f98e7c54d6c9bb"],"a0e7cdd0facd912df00ec53365f98e7c54d6c9bb":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}