{"path":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","commits":[{"id":"1513361122ebc5ddd6075f633cd77d2345611767","date":1273770174,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator();\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          TermsEnum terms = fieldsEnum.terms();\n          fillQueue(terms, tiq, field);\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator();\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          TermsEnum terms = fieldsEnum.terms();\n          fillQueue(terms, tiq, field);\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6abbad078dc62143b2aad8a447a26ac8e42141f9","date":1323602706,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new FieldReaderException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08eba3d52b63561ebf936481ce73e6b6a14aa03","date":1333879759,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      InvertedFields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      InvertedFields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf","date":1333892281,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      InvertedFields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      InvertedFields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":["8028ab7a24273833d53d35eb160dba5b57283cf5"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","pathOld":"lucene/contrib/misc/src/java/org/apache/lucene/misc/HighFreqTerms#getHighFreqTerms(IndexReader,int,String).mjava","sourceNew":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","sourceOld":"  /**\n   * \n   * @param reader\n   * @param numTerms\n   * @param field\n   * @return TermStats[] ordered by terms with highest docFreq first.\n   * @throws Exception\n   */\n  public static TermStats[] getHighFreqTerms(IndexReader reader, int numTerms, String field) throws Exception {\n    TermStatsQueue tiq = null;\n    \n    if (field != null) {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"field \" + field + \" not found\");\n      }\n      Terms terms = fields.terms(field);\n      if (terms != null) {\n        TermsEnum termsEnum = terms.iterator(null);\n        tiq = new TermStatsQueue(numTerms);\n        fillQueue(termsEnum, tiq, field);\n      }\n    } else {\n      Fields fields = MultiFields.getFields(reader);\n      if (fields == null) {\n        throw new RuntimeException(\"no fields found for this index\");\n      }\n      tiq = new TermStatsQueue(numTerms);\n      FieldsEnum fieldsEnum = fields.iterator();\n      while (true) {\n        field = fieldsEnum.next();\n        if (field != null) {\n          Terms terms = fieldsEnum.terms();\n          if (terms != null) {\n            fillQueue(terms.iterator(null), tiq, field);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    \n    TermStats[] result = new TermStats[tiq.size()];\n    // we want highest first so we read the queue and populate the array\n    // starting at the end and work backwards\n    int count = tiq.size() - 1;\n    while (tiq.size() != 0) {\n      result[count] = tiq.pop();\n      count--;\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"6abbad078dc62143b2aad8a447a26ac8e42141f9":["3cc749c053615f5871f3b95715fe292f34e70a53"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["3cc749c053615f5871f3b95715fe292f34e70a53","6abbad078dc62143b2aad8a447a26ac8e42141f9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"3cc749c053615f5871f3b95715fe292f34e70a53":["1513361122ebc5ddd6075f633cd77d2345611767"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["6abbad078dc62143b2aad8a447a26ac8e42141f9"],"1513361122ebc5ddd6075f633cd77d2345611767":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6abbad078dc62143b2aad8a447a26ac8e42141f9":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","d08eba3d52b63561ebf936481ce73e6b6a14aa03"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1513361122ebc5ddd6075f633cd77d2345611767"],"e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"3cc749c053615f5871f3b95715fe292f34e70a53":["6abbad078dc62143b2aad8a447a26ac8e42141f9","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"d08eba3d52b63561ebf936481ce73e6b6a14aa03":["e3f8ac3877ad6d160de0fd3a6f7155b243dfbddf"],"1513361122ebc5ddd6075f633cd77d2345611767":["3cc749c053615f5871f3b95715fe292f34e70a53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}