{"path":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","commits":[{"id":"1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b","date":1455308162,"type":0,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final TestSegmentTerminateEarlyState tstes = new TestSegmentTerminateEarlyState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // add some documents, then optimize to get merged-sorted segments\n        tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n        tstes.queryTimestampDescending(cloudSolrClient);\n\n        // add a few more documents, but don't optimize to have some not-merge-sorted segments\n        tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n        tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n        tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f2cc4cc34bb16ef750f9e4be14637706977993e","date":1455320490,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // add some documents, then optimize to get merged-sorted segments\n        tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n        tstes.queryTimestampDescending(cloudSolrClient);\n\n        // add a few more documents, but don't optimize to have some not-merge-sorted segments\n        tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n        tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n        tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final TestSegmentTerminateEarlyState tstes = new TestSegmentTerminateEarlyState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // add some documents, then optimize to get merged-sorted segments\n        tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n        tstes.queryTimestampDescending(cloudSolrClient);\n\n        // add a few more documents, but don't optimize to have some not-merge-sorted segments\n        tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n        tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n        tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      try (SolrZkClient zkClient = new SolrZkClient\n          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);\n          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {\n        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n        // add some documents, then optimize to get merged-sorted segments\n        tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n        tstes.queryTimestampDescending(cloudSolrClient);\n\n        // add a few more documents, but don't optimize to have some not-merge-sorted segments\n        tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n        tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n        // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n        tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n        tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n        // delete the collection we created earlier\n        miniCluster.deleteCollection(collectionName);\n        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n      }\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"162e1895a880a7263b46e184f1478f0366eb095c","date":1467859866,"type":3,"author":"Erick","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e89a32cc825033ebae8bb9e1c6877c2d9d76749e","date":1476790453,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr-no-core.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n        if (asyncId != null) {\n          final RequestStatusState state = AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient);\n          assertSame(\"did not see async createCollection completion\", RequestStatusState.COMPLETED, state);\n        }\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n      // delete the collection we created earlier\n      miniCluster.deleteCollection(collectionName);\n      AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7fee5fdef2fee1378cc07129e0c40d0b7eab3b2","date":1481746736,"type":4,"author":"Chris Hostetter","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudCluster#testSegmentTerminateEarly().mjava","sourceNew":null,"sourceOld":"  @Test\n  public void testSegmentTerminateEarly() throws Exception {\n\n    final String collectionName = \"testSegmentTerminateEarlyCollection\";\n\n    final SegmentTerminateEarlyTestState tstes = new SegmentTerminateEarlyTestState();\n\n    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), \"solr.xml\");\n    Builder jettyConfig = JettyConfig.builder();\n    jettyConfig.waitForLoadingCoresToFinish(null);\n    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();\n    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();\n    cloudSolrClient.setDefaultCollection(collectionName);\n\n    try {\n      // create collection\n      {\n        final String asyncId = (random().nextBoolean() ? null : \"asyncId(\"+collectionName+\".create)=\"+random().nextInt());\n        final Map<String, String> collectionProperties = new HashMap<>();\n        collectionProperties.put(CoreDescriptor.CORE_CONFIG, \"solrconfig-sortingmergepolicyfactory.xml\");\n        createCollection(miniCluster, collectionName, null, asyncId, Boolean.TRUE, collectionProperties);\n      }\n\n      ZkStateReader zkStateReader = cloudSolrClient.getZkStateReader();\n      AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);\n\n      // add some documents, then optimize to get merged-sorted segments\n      tstes.addDocuments(cloudSolrClient, 10, 10, true);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter intentionally absent\n      tstes.queryTimestampDescending(cloudSolrClient);\n\n      // add a few more documents, but don't optimize to have some not-merge-sorted segments\n      tstes.addDocuments(cloudSolrClient, 2, 10, false);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter now present\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYes(cloudSolrClient);\n      tstes.queryTimestampDescendingSegmentTerminateEarlyNo(cloudSolrClient);\n\n      // CommonParams.SEGMENT_TERMINATE_EARLY parameter present but it won't be used\n      tstes.queryTimestampDescendingSegmentTerminateEarlyYesGrouped(cloudSolrClient);\n      tstes.queryTimestampAscendingSegmentTerminateEarlyYes(cloudSolrClient); // uses a sort order that is _not_ compatible with the merge sort order\n\n    }\n    finally {\n      miniCluster.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"162e1895a880a7263b46e184f1478f0366eb095c":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["162e1895a880a7263b46e184f1478f0366eb095c"],"a7fee5fdef2fee1378cc07129e0c40d0b7eab3b2":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9856095f7afb5a607bf5e65077615ed91273508c":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a7fee5fdef2fee1378cc07129e0c40d0b7eab3b2"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["3f2cc4cc34bb16ef750f9e4be14637706977993e"],"3f2cc4cc34bb16ef750f9e4be14637706977993e":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7fee5fdef2fee1378cc07129e0c40d0b7eab3b2"]},"commit2Childs":{"162e1895a880a7263b46e184f1478f0366eb095c":["e89a32cc825033ebae8bb9e1c6877c2d9d76749e"],"1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b":["3f2cc4cc34bb16ef750f9e4be14637706977993e"],"e89a32cc825033ebae8bb9e1c6877c2d9d76749e":["a7fee5fdef2fee1378cc07129e0c40d0b7eab3b2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a7fee5fdef2fee1378cc07129e0c40d0b7eab3b2":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1a9c2b42591c0db6f85041d5cfc9cba17fe45e0b"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["162e1895a880a7263b46e184f1478f0366eb095c","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"3f2cc4cc34bb16ef750f9e4be14637706977993e":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["9856095f7afb5a607bf5e65077615ed91273508c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}