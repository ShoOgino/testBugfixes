{"path":"solr/core/src/java/org/apache/solr/rest/CopyFieldCollectionResource#get().mjava","commits":[{"id":"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37","date":1362545433,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/CopyFieldCollectionResource#get().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Representation get() {\n    try {\n      final List<SimpleOrderedMap<Object>> props = new ArrayList<SimpleOrderedMap<Object>>();\n      SortedMap<String,List<CopyField>> sortedCopyFields\n          = new TreeMap<String, List<CopyField>>(getSchema().getCopyFieldsMap());\n      for (List<CopyField> copyFields : sortedCopyFields.values()) {\n        Collections.sort(copyFields, new Comparator<CopyField>() {\n          @Override\n          public int compare(CopyField cf1, CopyField cf2) {\n            // source should all be the same => already sorted\n            return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n          }\n        });\n        for (CopyField copyField : copyFields) {\n          final String source = copyField.getSource().getName();\n          final String destination = copyField.getDestination().getName();\n          if (   (null == sourceFields      || sourceFields.contains(source))\n              && (null == destinationFields || destinationFields.contains(destination))) {\n            SimpleOrderedMap<Object> copyFieldProps = new SimpleOrderedMap<Object>();\n            copyFieldProps.add(SOURCE, source);\n            copyFieldProps.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              copyFieldProps.add(MAX_CHARS, copyField.getMaxChars());\n            }\n            props.add(copyFieldProps);\n          }\n        }\n      }\n      for (IndexSchema.DynamicCopy dynamicCopy : getSchema().getDynamicCopyFields()) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if (   (null == sourceFields      || sourceFields.contains(source))\n            && (null == destinationFields || destinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n          \n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          }\n          \n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n          \n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          props.add(dynamicCopyProps);\n        }\n      }\n      getSolrResponse().add(SchemaRestApi.COPY_FIELDS, props);\n    } catch (Exception e) {\n      getSolrResponse().setException(e);\n    }\n    handlePostExecution(log);\n\n    return new SolrOutputRepresentation();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b","date":1363161710,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/rest/CopyFieldCollectionResource#get().mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/CopyFieldCollectionResource#get().mjava","sourceNew":"  @Override\n  public Representation get() {\n    try {\n      final List<SimpleOrderedMap<Object>> props = new ArrayList<SimpleOrderedMap<Object>>();\n      SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<String, List<CopyField>>(getSchema().getCopyFieldsMap());\n      for (List<CopyField> copyFields : sortedCopyFields.values()) {\n        Collections.sort(copyFields, new Comparator<CopyField>() {\n          @Override\n          public int compare(CopyField cf1, CopyField cf2) {\n            // source should all be the same => already sorted\n            return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n          }\n        });\n        for (CopyField copyField : copyFields) {\n          final String source = copyField.getSource().getName();\n          final String destination = copyField.getDestination().getName();\n          if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n              && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n            SimpleOrderedMap<Object> copyFieldProps = new SimpleOrderedMap<Object>();\n            copyFieldProps.add(SOURCE, source);\n            copyFieldProps.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              copyFieldProps.add(MAX_CHARS, copyField.getMaxChars());\n            }\n            props.add(copyFieldProps);\n          }\n        }\n      }\n      for (IndexSchema.DynamicCopy dynamicCopy : getSchema().getDynamicCopyFields()) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<String>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : getSchema().getFields().keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n          \n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n          \n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          props.add(dynamicCopyProps);\n        }\n      }\n      getSolrResponse().add(SchemaRestApi.COPY_FIELDS, props);\n    } catch (Exception e) {\n      getSolrResponse().setException(e);\n    }\n    handlePostExecution(log);\n\n    return new SolrOutputRepresentation();\n  }\n\n","sourceOld":"  @Override\n  public Representation get() {\n    try {\n      final List<SimpleOrderedMap<Object>> props = new ArrayList<SimpleOrderedMap<Object>>();\n      SortedMap<String,List<CopyField>> sortedCopyFields\n          = new TreeMap<String, List<CopyField>>(getSchema().getCopyFieldsMap());\n      for (List<CopyField> copyFields : sortedCopyFields.values()) {\n        Collections.sort(copyFields, new Comparator<CopyField>() {\n          @Override\n          public int compare(CopyField cf1, CopyField cf2) {\n            // source should all be the same => already sorted\n            return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n          }\n        });\n        for (CopyField copyField : copyFields) {\n          final String source = copyField.getSource().getName();\n          final String destination = copyField.getDestination().getName();\n          if (   (null == sourceFields      || sourceFields.contains(source))\n              && (null == destinationFields || destinationFields.contains(destination))) {\n            SimpleOrderedMap<Object> copyFieldProps = new SimpleOrderedMap<Object>();\n            copyFieldProps.add(SOURCE, source);\n            copyFieldProps.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              copyFieldProps.add(MAX_CHARS, copyField.getMaxChars());\n            }\n            props.add(copyFieldProps);\n          }\n        }\n      }\n      for (IndexSchema.DynamicCopy dynamicCopy : getSchema().getDynamicCopyFields()) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if (   (null == sourceFields      || sourceFields.contains(source))\n            && (null == destinationFields || destinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n          \n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          }\n          \n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n          \n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          props.add(dynamicCopyProps);\n        }\n      }\n      getSolrResponse().add(SchemaRestApi.COPY_FIELDS, props);\n    } catch (Exception e) {\n      getSolrResponse().setException(e);\n    }\n    handlePostExecution(log);\n\n    return new SolrOutputRepresentation();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd","date":1364185773,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/schema/IndexSchema#getCopyFieldProperties(boolean,Set[String],Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/rest/CopyFieldCollectionResource#get().mjava","sourceNew":"  /**\n   * Returns a list of copyField directives, with optional details and optionally restricting to those\n   * directives that contain the requested source and/or destination field names.\n   * \n   * @param showDetails If true, source and destination dynamic bases, and explicit fields matched by source globs,\n   *                    will be added to dynamic copyField directives where appropriate\n   * @param requestedSourceFields If not null, output is restricted to those copyField directives\n   *                              with the requested source field names \n   * @param requestedDestinationFields If not null, output is restricted to those copyField directives\n   *                                   with the requested destination field names \n   * @return a list of copyField directives \n   */\n  public List<SimpleOrderedMap<Object>> getCopyFieldProperties\n      (boolean showDetails, Set<String> requestedSourceFields, Set<String> requestedDestinationFields) {\n    List<SimpleOrderedMap<Object>> copyFieldProperties = new ArrayList<SimpleOrderedMap<Object>>();\n    SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<String,List<CopyField>>(copyFieldsMap);\n    for (List<CopyField> copyFields : sortedCopyFields.values()) {\n      Collections.sort(copyFields, new Comparator<CopyField>() {\n        @Override\n        public int compare(CopyField cf1, CopyField cf2) {\n          // sources are all be the same, just sorting by destination here\n          return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n        }\n      });\n      for (CopyField copyField : copyFields) {\n        final String source = copyField.getSource().getName();\n        final String destination = copyField.getDestination().getName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> props = new SimpleOrderedMap<Object>();\n          props.add(SOURCE, source);\n          props.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              props.add(MAX_CHARS, copyField.getMaxChars());\n            }\n          copyFieldProperties.add(props);\n        }\n      }\n    }\n    for (IndexSchema.DynamicCopy dynamicCopy : dynamicCopyFields) {\n      final String source = dynamicCopy.getRegex();\n      final String destination = dynamicCopy.getDestFieldName();\n      if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n          && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n        SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n\n        dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n        if (showDetails) {\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<String>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : fields.keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n        }\n        \n        dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n        if (showDetails) {\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n        }\n\n        if (0 != dynamicCopy.getMaxChars()) {\n          dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n        }\n\n        copyFieldProperties.add(dynamicCopyProps);\n      }\n    }\n    return copyFieldProperties;\n  }\n\n","sourceOld":"  @Override\n  public Representation get() {\n    try {\n      final List<SimpleOrderedMap<Object>> props = new ArrayList<SimpleOrderedMap<Object>>();\n      SortedMap<String,List<CopyField>> sortedCopyFields = new TreeMap<String, List<CopyField>>(getSchema().getCopyFieldsMap());\n      for (List<CopyField> copyFields : sortedCopyFields.values()) {\n        Collections.sort(copyFields, new Comparator<CopyField>() {\n          @Override\n          public int compare(CopyField cf1, CopyField cf2) {\n            // source should all be the same => already sorted\n            return cf1.getDestination().getName().compareTo(cf2.getDestination().getName());\n          }\n        });\n        for (CopyField copyField : copyFields) {\n          final String source = copyField.getSource().getName();\n          final String destination = copyField.getDestination().getName();\n          if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n              && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n            SimpleOrderedMap<Object> copyFieldProps = new SimpleOrderedMap<Object>();\n            copyFieldProps.add(SOURCE, source);\n            copyFieldProps.add(DESTINATION, destination);\n            if (0 != copyField.getMaxChars()) {\n              copyFieldProps.add(MAX_CHARS, copyField.getMaxChars());\n            }\n            props.add(copyFieldProps);\n          }\n        }\n      }\n      for (IndexSchema.DynamicCopy dynamicCopy : getSchema().getDynamicCopyFields()) {\n        final String source = dynamicCopy.getRegex();\n        final String destination = dynamicCopy.getDestFieldName();\n        if (   (null == requestedSourceFields      || requestedSourceFields.contains(source))\n            && (null == requestedDestinationFields || requestedDestinationFields.contains(destination))) {\n          SimpleOrderedMap<Object> dynamicCopyProps = new SimpleOrderedMap<Object>();\n\n          dynamicCopyProps.add(SOURCE, dynamicCopy.getRegex());\n          IndexSchema.DynamicField sourceDynamicBase = dynamicCopy.getSourceDynamicBase();\n          if (null != sourceDynamicBase) {\n            dynamicCopyProps.add(SOURCE_DYNAMIC_BASE, sourceDynamicBase.getRegex());\n          } else if (source.contains(\"*\")) {\n            List<String> sourceExplicitFields = new ArrayList<String>();\n            Pattern pattern = Pattern.compile(source.replace(\"*\", \".*\"));   // glob->regex\n            for (String field : getSchema().getFields().keySet()) {\n              if (pattern.matcher(field).matches()) {\n                sourceExplicitFields.add(field);\n              }\n            }\n            if (sourceExplicitFields.size() > 0) {\n              Collections.sort(sourceExplicitFields);\n              dynamicCopyProps.add(SOURCE_EXPLICIT_FIELDS, sourceExplicitFields);\n            }\n          }\n          \n          dynamicCopyProps.add(DESTINATION, dynamicCopy.getDestFieldName());\n          IndexSchema.DynamicField destDynamicBase = dynamicCopy.getDestDynamicBase();\n          if (null != destDynamicBase) {\n            dynamicCopyProps.add(DESTINATION_DYNAMIC_BASE, destDynamicBase.getRegex());\n          }\n          \n          if (0 != dynamicCopy.getMaxChars()) {\n            dynamicCopyProps.add(MAX_CHARS, dynamicCopy.getMaxChars());\n          }\n\n          props.add(dynamicCopyProps);\n        }\n      }\n      getSolrResponse().add(SchemaRestApi.COPY_FIELDS, props);\n    } catch (Exception e) {\n      getSolrResponse().setException(e);\n    }\n    handlePostExecution(log);\n\n    return new SolrOutputRepresentation();\n  }\n\n","bugFix":null,"bugIntro":["cbf48bc10d8aa7b417d61814c87fee4f942cdeca","43320f4e37917fa7fd8f8c1e703fc6eaf55d78b3"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"]},"commit2Childs":{"f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b":["d2fa053a06c9c158f82d8e8b53b9a95031f43ebd"],"d2fa053a06c9c158f82d8e8b53b9a95031f43ebd":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["054c04cf724f73ebdd3b16e3a86ce802c0ba5e37"],"054c04cf724f73ebdd3b16e3a86ce802c0ba5e37":["f4ebbcaa830b0a3008a69f1a4cdbcdec2703be0b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}