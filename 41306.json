{"path":"lucene/sandbox/src/java/org/apache/lucene/util/GeoHashUtils#neighbor(String,int,int,int).mjava","commits":[{"id":"b6a3f9fb1b9d12b2236e48df7a49751f1495a95e","date":1438980529,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/util/GeoHashUtils#neighbor(String,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Calculate the geohash of a neighbor of a geohash\n   *\n   * @param geohash the geohash of a cell\n   * @param level   level of the geohash\n   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)\n   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)\n   * @return geohash of the defined cell\n   */\n  public final static String neighbor(String geohash, int level, int dx, int dy) {\n    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));\n\n    // Decoding the Geohash bit pattern to determine grid coordinates\n    int x0 = cell & 1;  // first bit of x\n    int y0 = cell & 2;  // first bit of y\n    int x1 = cell & 4;  // second bit of x\n    int y1 = cell & 8;  // second bit of y\n    int x2 = cell & 16; // third bit of x\n\n    // combine the bitpattern to grid coordinates.\n    // note that the semantics of x and y are swapping\n    // on each level\n    int x = x0 + (x1 / 2) + (x2 / 4);\n    int y = (y0 / 2) + (y1 / 4);\n\n    if (level == 1) {\n      // Root cells at north (namely \"bcfguvyz\") or at\n      // south (namely \"0145hjnp\") do not have neighbors\n      // in north/south direction\n      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {\n        return null;\n      } else {\n        return Character.toString(encode(x + dx, y + dy));\n      }\n    } else {\n      // define grid coordinates for next level\n      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);\n      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);\n\n      // if the defined neighbor has the same parent a the current cell\n      // encode the cell directly. Otherwise find the cell next to this\n      // cell recursively. Since encoding wraps around within a cell\n      // it can be encoded here.\n      // xLimit and YLimit must always be respectively 7 and 3\n      // since x and y semantics are swapping on each level.\n      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {\n        return geohash.substring(0, level - 1) + encode(nx, ny);\n      } else {\n        String neighbor = neighbor(geohash, level - 1, dx, dy);\n        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"937923083e4d137932336fc80f3d78758ff698a6","date":1454691519,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils#neighbor(String,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/util/GeoHashUtils#neighbor(String,int,int,int).mjava","sourceNew":"  /**\n   * Calculate the geohash of a neighbor of a geohash\n   *\n   * @param geohash the geohash of a cell\n   * @param level   level of the geohash\n   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)\n   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)\n   * @return geohash of the defined cell\n   */\n  public final static String neighbor(String geohash, int level, int dx, int dy) {\n    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));\n\n    // Decoding the Geohash bit pattern to determine grid coordinates\n    int x0 = cell & 1;  // first bit of x\n    int y0 = cell & 2;  // first bit of y\n    int x1 = cell & 4;  // second bit of x\n    int y1 = cell & 8;  // second bit of y\n    int x2 = cell & 16; // third bit of x\n\n    // combine the bitpattern to grid coordinates.\n    // note that the semantics of x and y are swapping\n    // on each level\n    int x = x0 + (x1 / 2) + (x2 / 4);\n    int y = (y0 / 2) + (y1 / 4);\n\n    if (level == 1) {\n      // Root cells at north (namely \"bcfguvyz\") or at\n      // south (namely \"0145hjnp\") do not have neighbors\n      // in north/south direction\n      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {\n        return null;\n      } else {\n        return Character.toString(encode(x + dx, y + dy));\n      }\n    } else {\n      // define grid coordinates for next level\n      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);\n      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);\n\n      // if the defined neighbor has the same parent a the current cell\n      // encode the cell directly. Otherwise find the cell next to this\n      // cell recursively. Since encoding wraps around within a cell\n      // it can be encoded here.\n      // xLimit and YLimit must always be respectively 7 and 3\n      // since x and y semantics are swapping on each level.\n      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {\n        return geohash.substring(0, level - 1) + encode(nx, ny);\n      } else {\n        String neighbor = neighbor(geohash, level - 1, dx, dy);\n        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calculate the geohash of a neighbor of a geohash\n   *\n   * @param geohash the geohash of a cell\n   * @param level   level of the geohash\n   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)\n   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)\n   * @return geohash of the defined cell\n   */\n  public final static String neighbor(String geohash, int level, int dx, int dy) {\n    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));\n\n    // Decoding the Geohash bit pattern to determine grid coordinates\n    int x0 = cell & 1;  // first bit of x\n    int y0 = cell & 2;  // first bit of y\n    int x1 = cell & 4;  // second bit of x\n    int y1 = cell & 8;  // second bit of y\n    int x2 = cell & 16; // third bit of x\n\n    // combine the bitpattern to grid coordinates.\n    // note that the semantics of x and y are swapping\n    // on each level\n    int x = x0 + (x1 / 2) + (x2 / 4);\n    int y = (y0 / 2) + (y1 / 4);\n\n    if (level == 1) {\n      // Root cells at north (namely \"bcfguvyz\") or at\n      // south (namely \"0145hjnp\") do not have neighbors\n      // in north/south direction\n      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {\n        return null;\n      } else {\n        return Character.toString(encode(x + dx, y + dy));\n      }\n    } else {\n      // define grid coordinates for next level\n      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);\n      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);\n\n      // if the defined neighbor has the same parent a the current cell\n      // encode the cell directly. Otherwise find the cell next to this\n      // cell recursively. Since encoding wraps around within a cell\n      // it can be encoded here.\n      // xLimit and YLimit must always be respectively 7 and 3\n      // since x and y semantics are swapping on each level.\n      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {\n        return geohash.substring(0, level - 1) + encode(nx, ny);\n      } else {\n        String neighbor = neighbor(geohash, level - 1, dx, dy);\n        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/util/GeoHashUtils#neighbor(String,int,int,int).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/util/GeoHashUtils#neighbor(String,int,int,int).mjava","sourceNew":"  /**\n   * Calculate the geohash of a neighbor of a geohash\n   *\n   * @param geohash the geohash of a cell\n   * @param level   level of the geohash\n   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)\n   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)\n   * @return geohash of the defined cell\n   */\n  public final static String neighbor(String geohash, int level, int dx, int dy) {\n    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));\n\n    // Decoding the Geohash bit pattern to determine grid coordinates\n    int x0 = cell & 1;  // first bit of x\n    int y0 = cell & 2;  // first bit of y\n    int x1 = cell & 4;  // second bit of x\n    int y1 = cell & 8;  // second bit of y\n    int x2 = cell & 16; // third bit of x\n\n    // combine the bitpattern to grid coordinates.\n    // note that the semantics of x and y are swapping\n    // on each level\n    int x = x0 + (x1 / 2) + (x2 / 4);\n    int y = (y0 / 2) + (y1 / 4);\n\n    if (level == 1) {\n      // Root cells at north (namely \"bcfguvyz\") or at\n      // south (namely \"0145hjnp\") do not have neighbors\n      // in north/south direction\n      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {\n        return null;\n      } else {\n        return Character.toString(encode(x + dx, y + dy));\n      }\n    } else {\n      // define grid coordinates for next level\n      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);\n      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);\n\n      // if the defined neighbor has the same parent a the current cell\n      // encode the cell directly. Otherwise find the cell next to this\n      // cell recursively. Since encoding wraps around within a cell\n      // it can be encoded here.\n      // xLimit and YLimit must always be respectively 7 and 3\n      // since x and y semantics are swapping on each level.\n      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {\n        return geohash.substring(0, level - 1) + encode(nx, ny);\n      } else {\n        String neighbor = neighbor(geohash, level - 1, dx, dy);\n        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Calculate the geohash of a neighbor of a geohash\n   *\n   * @param geohash the geohash of a cell\n   * @param level   level of the geohash\n   * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)\n   * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)\n   * @return geohash of the defined cell\n   */\n  public final static String neighbor(String geohash, int level, int dx, int dy) {\n    int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));\n\n    // Decoding the Geohash bit pattern to determine grid coordinates\n    int x0 = cell & 1;  // first bit of x\n    int y0 = cell & 2;  // first bit of y\n    int x1 = cell & 4;  // second bit of x\n    int y1 = cell & 8;  // second bit of y\n    int x2 = cell & 16; // third bit of x\n\n    // combine the bitpattern to grid coordinates.\n    // note that the semantics of x and y are swapping\n    // on each level\n    int x = x0 + (x1 / 2) + (x2 / 4);\n    int y = (y0 / 2) + (y1 / 4);\n\n    if (level == 1) {\n      // Root cells at north (namely \"bcfguvyz\") or at\n      // south (namely \"0145hjnp\") do not have neighbors\n      // in north/south direction\n      if ((dy < 0 && y == 0) || (dy > 0 && y == 3)) {\n        return null;\n      } else {\n        return Character.toString(encode(x + dx, y + dy));\n      }\n    } else {\n      // define grid coordinates for next level\n      final int nx = ((level % 2) == 1) ? (x + dx) : (x + dy);\n      final int ny = ((level % 2) == 1) ? (y + dy) : (y + dx);\n\n      // if the defined neighbor has the same parent a the current cell\n      // encode the cell directly. Otherwise find the cell next to this\n      // cell recursively. Since encoding wraps around within a cell\n      // it can be encoded here.\n      // xLimit and YLimit must always be respectively 7 and 3\n      // since x and y semantics are swapping on each level.\n      if (nx >= 0 && nx <= 7 && ny >= 0 && ny <= 3) {\n        return geohash.substring(0, level - 1) + encode(nx, ny);\n      } else {\n        String neighbor = neighbor(geohash, level - 1, dx, dy);\n        return (neighbor != null) ? neighbor + encode(nx, ny) : neighbor;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b6a3f9fb1b9d12b2236e48df7a49751f1495a95e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["b6a3f9fb1b9d12b2236e48df7a49751f1495a95e","937923083e4d137932336fc80f3d78758ff698a6"],"937923083e4d137932336fc80f3d78758ff698a6":["b6a3f9fb1b9d12b2236e48df7a49751f1495a95e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["937923083e4d137932336fc80f3d78758ff698a6"]},"commit2Childs":{"b6a3f9fb1b9d12b2236e48df7a49751f1495a95e":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","937923083e4d137932336fc80f3d78758ff698a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b6a3f9fb1b9d12b2236e48df7a49751f1495a95e"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"937923083e4d137932336fc80f3d78758ff698a6":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}