{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","commits":[{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(ByteBuffersDataOutput writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = FutureArrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      \n      byte[] bytes2 = writeBuffer.toArrayCopy();\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + bytes2.length + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = FutureArrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(ByteBuffersDataOutput writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = Arrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      \n      byte[] bytes2 = writeBuffer.toArrayCopy();\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + bytes2.length + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(ByteBuffersDataOutput writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = FutureArrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      \n      byte[] bytes2 = writeBuffer.toArrayCopy();\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + bytes2.length + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce","date":1589215155,"type":5,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,BKDTreeLeafNodes,long,List[byte[]],byte[],boolean[],boolean,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(ByteBuffersDataOutput writeBuffer, BKDTreeLeafNodes leafNodes, long minBlockFP, List<byte[]> blocks,\n                               byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft, int leavesOffset, int numLeaves) throws IOException {\n    if (numLeaves == 1) {\n      if (isLeft) {\n        assert leafNodes.getLeafLP(leavesOffset) - minBlockFP == 0;\n        return 0;\n      } else {\n        long delta = leafNodes.getLeafLP(leavesOffset) - minBlockFP;\n        assert leafNodes.numLeaves() == numLeaves || delta > 0 : \"expected delta > 0; got numLeaves =\" + numLeaves + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n        return appendBlock(writeBuffer, blocks);\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft) {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        assert leafNodes.getLeafLP(leavesOffset) == minBlockFP;\n        leftBlockFP = minBlockFP;\n      } else {\n        leftBlockFP = leafNodes.getLeafLP(leavesOffset);\n        long delta = leftBlockFP - minBlockFP;\n        assert leafNodes.numLeaves() == numLeaves || delta > 0 : \"expected delta > 0; got numLeaves =\" + numLeaves + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      }\n\n      int numLeftLeafNodes = getNumLeftLeafNodes(numLeaves);\n      final int rightOffset = leavesOffset + numLeftLeafNodes;\n      final int splitOffset = rightOffset - 1;\n\n      int splitDim = leafNodes.getSplitDimension(splitOffset);\n      BytesRef splitValue = leafNodes.getSplitValue(splitOffset);\n      int address = splitValue.offset;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = Arrays.mismatch(splitValue.bytes, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitValue.bytes[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitValue.bytes, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitValue.bytes, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafNodes, leftBlockFP, blocks, lastSplitValues, negativeDeltas, true,\n          leavesOffset, numLeftLeafNodes);\n\n      if (numLeftLeafNodes != 1) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      \n      byte[] bytes2 = writeBuffer.toArrayCopy();\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer,  leafNodes, leftBlockFP, blocks, lastSplitValues, negativeDeltas, false,\n          rightOffset, numLeaves - numLeftLeafNodes);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + bytes2.length + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(ByteBuffersDataOutput writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = Arrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      \n      byte[] bytes2 = writeBuffer.toArrayCopy();\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + bytes2.length + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["125e5eeb7e933deec0cc0510c2368fe1ec7c36ce"]},"commit2Childs":{"b88a121b875f9ae2ac50f85cf46dcb680f126357":["125e5eeb7e933deec0cc0510c2368fe1ec7c36ce"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"125e5eeb7e933deec0cc0510c2368fe1ec7c36ce":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}