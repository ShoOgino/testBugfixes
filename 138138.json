{"path":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","commits":[{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          if (submitterContext != null) {\n            MDC.setContextMap(submitterContext);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } finally {\n            if (threadContext != null) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n          }\n        }\n      });\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95","date":1429031018,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      String ctxStr = submitterContext != null && !submitterContext.isEmpty() ?\n          submitterContext.toString().replace(\"/\", \"//\") : \"\";\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } finally {\n            if (threadContext != null) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          if (submitterContext != null) {\n            MDC.setContextMap(submitterContext);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } finally {\n            if (threadContext != null) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce5a76ca06fc2cbe721e0b65d03f3edf0bf4656c","date":1429415302,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      String ctxStr = submitterContext != null && !submitterContext.isEmpty() ?\n          submitterContext.toString().replace(\"/\", \"//\") : \"\";\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError)  {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      String ctxStr = submitterContext != null && !submitterContext.isEmpty() ?\n          submitterContext.toString().replace(\"/\", \"//\") : \"\";\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } finally {\n            if (threadContext != null) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439c63ae5d22132fca810a0029a854e97d2c1a3e","date":1432733612,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n        \n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n      \n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError)  {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      String ctxStr = submitterContext != null && !submitterContext.isEmpty() ?\n          submitterContext.toString().replace(\"/\", \"//\") : \"\";\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError)  {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6d62214e818b74b9fa407c0c51956e44878a46a","date":1438266500,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n        \n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n      \n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty()? null: new ArrayList<>(providersCopy.size());\n      if(ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          if(ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n          }\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError)  {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            if(ctx != null) {\n              for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n        \n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n      \n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError)  {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03666d115305f32da464b8ac79286ddba8bdd47","date":1438267163,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n          }\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError) {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            if (ctx != null) {\n              for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n        \n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n      \n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty()? null: new ArrayList<>(providersCopy.size());\n      if(ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          if(ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n          }\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError)  {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            if(ctx != null) {\n              for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3a34dae868734612eb6329aa0ef754f30bd2036","date":1438783154,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          isServerPool.set(Boolean.TRUE);\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n          }\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError) {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            isServerPool.remove();\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            if (ctx != null) {\n              for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n          }\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError) {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            if (ctx != null) {\n              for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(new Runnable() {\n        @Override\n        public void run() {\n          isServerPool.set(Boolean.TRUE);\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n          }\n          Map<String, String> threadContext = MDC.getCopyOfContextMap();\n          final Thread currentThread = Thread.currentThread();\n          final String oldName = currentThread.getName();\n          if (submitterContext != null && !submitterContext.isEmpty()) {\n            MDC.setContextMap(submitterContext);\n            currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n          } else {\n            MDC.clear();\n          }\n          try {\n            command.run();\n          } catch (Throwable t) {\n            if (t instanceof OutOfMemoryError) {\n              throw t;\n            }\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n            throw t;\n          } finally {\n            isServerPool.remove();\n            if (threadContext != null && !threadContext.isEmpty()) {\n              MDC.setContextMap(threadContext);\n            } else {\n              MDC.clear();\n            }\n            if (ctx != null) {\n              for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n            }\n            currentThread.setName(oldName);\n          }\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49b7c1e62ffc7edda176539a331f450b87f6f380","date":1526997402,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = enableSubmitterStackTrace ? new Exception(\"Submitter stack trace\") : null;\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          if (enableSubmitterStackTrace)  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          } else  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName());\n          }\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = new Exception(\"Submitter stack trace\");\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffe681f212e5073c69955b4ad22946794c84940","date":1560182863,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value).append(' ');\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = enableSubmitterStackTrace ? new Exception(\"Submitter stack trace\") : null;\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          if (enableSubmitterStackTrace)  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          } else  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName());\n          }\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value + \" \");\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = enableSubmitterStackTrace ? new Exception(\"Submitter stack trace\") : null;\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          if (enableSubmitterStackTrace)  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          } else  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName());\n          }\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/util/ExecutorUtil.MDCAwareThreadPoolExecutor#execute(Runnable).mjava","sourceNew":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value).append(' ');\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = enableSubmitterStackTrace ? new Exception(\"Submitter stack trace\") : null;\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      @SuppressWarnings({\"rawtypes\"})\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          @SuppressWarnings({\"rawtypes\"})\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          if (enableSubmitterStackTrace)  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          } else  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName());\n          }\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","sourceOld":"    @Override\n    public void execute(final Runnable command) {\n      final Map<String, String> submitterContext = MDC.getCopyOfContextMap();\n      StringBuilder contextString = new StringBuilder();\n      if (submitterContext != null) {\n        Collection<String> values = submitterContext.values();\n\n        for (String value : values) {\n          contextString.append(value).append(' ');\n        }\n        if (contextString.length() > 1) {\n          contextString.setLength(contextString.length() - 1);\n        }\n      }\n\n      String ctxStr = contextString.toString().replace(\"/\", \"//\");\n      final String submitterContextStr = ctxStr.length() <= MAX_THREAD_NAME_LEN ? ctxStr : ctxStr.substring(0, MAX_THREAD_NAME_LEN);\n      final Exception submitterStackTrace = enableSubmitterStackTrace ? new Exception(\"Submitter stack trace\") : null;\n      final List<InheritableThreadLocalProvider> providersCopy = providers;\n      final ArrayList<AtomicReference> ctx = providersCopy.isEmpty() ? null : new ArrayList<>(providersCopy.size());\n      if (ctx != null) {\n        for (int i = 0; i < providers.size(); i++) {\n          AtomicReference reference = new AtomicReference();\n          ctx.add(reference);\n          providersCopy.get(i).store(reference);\n        }\n      }\n      super.execute(() -> {\n        isServerPool.set(Boolean.TRUE);\n        if (ctx != null) {\n          for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).set(ctx.get(i));\n        }\n        Map<String, String> threadContext = MDC.getCopyOfContextMap();\n        final Thread currentThread = Thread.currentThread();\n        final String oldName = currentThread.getName();\n        if (submitterContext != null && !submitterContext.isEmpty()) {\n          MDC.setContextMap(submitterContext);\n          currentThread.setName(oldName + \"-processing-\" + submitterContextStr);\n        } else {\n          MDC.clear();\n        }\n        try {\n          command.run();\n        } catch (Throwable t) {\n          if (t instanceof OutOfMemoryError) {\n            throw t;\n          }\n          if (enableSubmitterStackTrace)  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName(), submitterStackTrace);\n          } else  {\n            log.error(\"Uncaught exception {} thrown by thread: {}\", t, currentThread.getName());\n          }\n          throw t;\n        } finally {\n          isServerPool.remove();\n          if (threadContext != null && !threadContext.isEmpty()) {\n            MDC.setContextMap(threadContext);\n          } else {\n            MDC.clear();\n          }\n          if (ctx != null) {\n            for (int i = 0; i < providersCopy.size(); i++) providersCopy.get(i).clean(ctx.get(i));\n          }\n          currentThread.setName(oldName);\n        }\n      });\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["cb5af3afeddbb803fb785098176e6e177c34261b"],"2ffe681f212e5073c69955b4ad22946794c84940":["49b7c1e62ffc7edda176539a331f450b87f6f380"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["2ffe681f212e5073c69955b4ad22946794c84940"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["f03666d115305f32da464b8ac79286ddba8bdd47"],"3a0c04b71951333291abc7f317109a6a5957bd28":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"ce5a76ca06fc2cbe721e0b65d03f3edf0bf4656c":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["ce5a76ca06fc2cbe721e0b65d03f3edf0bf4656c"],"f03666d115305f32da464b8ac79286ddba8bdd47":["d6d62214e818b74b9fa407c0c51956e44878a46a"],"49b7c1e62ffc7edda176539a331f450b87f6f380":["3a0c04b71951333291abc7f317109a6a5957bd28"],"d6d62214e818b74b9fa407c0c51956e44878a46a":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cb5af3afeddbb803fb785098176e6e177c34261b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"]},"commit2Childs":{"6a96b173f2f573ac82bc8279dfdd3cbe2b948f95":["ce5a76ca06fc2cbe721e0b65d03f3edf0bf4656c"],"2ffe681f212e5073c69955b4ad22946794c84940":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b3a34dae868734612eb6329aa0ef754f30bd2036":["3a0c04b71951333291abc7f317109a6a5957bd28"],"3a0c04b71951333291abc7f317109a6a5957bd28":["49b7c1e62ffc7edda176539a331f450b87f6f380"],"ce5a76ca06fc2cbe721e0b65d03f3edf0bf4656c":["439c63ae5d22132fca810a0029a854e97d2c1a3e"],"439c63ae5d22132fca810a0029a854e97d2c1a3e":["d6d62214e818b74b9fa407c0c51956e44878a46a"],"f03666d115305f32da464b8ac79286ddba8bdd47":["b3a34dae868734612eb6329aa0ef754f30bd2036"],"49b7c1e62ffc7edda176539a331f450b87f6f380":["2ffe681f212e5073c69955b4ad22946794c84940"],"d6d62214e818b74b9fa407c0c51956e44878a46a":["f03666d115305f32da464b8ac79286ddba8bdd47"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cb5af3afeddbb803fb785098176e6e177c34261b"],"cb5af3afeddbb803fb785098176e6e177c34261b":["6a96b173f2f573ac82bc8279dfdd3cbe2b948f95"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}