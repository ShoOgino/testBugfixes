{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithRename(String,String).mjava","commits":[{"id":"59bad1cc1e7f90125a140496e79b06afcedb68ec","date":1554915399,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithRename(String,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Rename an alias. This performs a \"deep rename\", which changes also the second-level alias lists.\n   * Renaming routed aliases is not supported.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param before previous alias name, must not be null\n   * @param after new alias name. If this is null then it's equivalent to calling {@link #cloneWithCollectionAlias(String, String)}\n   *              with the second argument set to null, ie. removing an alias.\n   * @return new instance with the renamed alias\n   * @throws IllegalArgumentException when either <code>before</code> or <code>after</code> is empty, or\n   * the <code>before</code> name is a routed alias\n   */\n  public Aliases cloneWithRename(String before, String after) {\n    if (before == null) {\n      throw new NullPointerException(\"'before' and 'after' cannot be null\");\n    }\n    if (after == null) {\n      return cloneWithCollectionAlias(before, after);\n    }\n    if (before.isEmpty() || after.isEmpty()) {\n      throw new IllegalArgumentException(\"'before' and 'after' cannot be empty\");\n    }\n    if (before.equals(after)) {\n      return this;\n    }\n    Map<String, String> props = collectionAliasProperties.get(before);\n    if (props != null) {\n      if (props.keySet().stream().anyMatch(k -> k.startsWith(CollectionAdminParams.ROUTER_PREFIX))) {\n        throw new IllegalArgumentException(\"source name '\" + before + \"' is a routed alias.\");\n      }\n    }\n    Map<String, Map<String, String>> newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    List<String> level1 = newColAliases.remove(before);\n    props = newColProperties.remove(before);\n    if (level1 != null) {\n      newColAliases.put(after, level1);\n    }\n    if (props != null) {\n      newColProperties.put(after, props);\n    }\n    for (Map.Entry<String, List<String>> entry : newColAliases.entrySet()) {\n      List<String> collections = entry.getValue();\n      if (collections.contains(before)) {\n        LinkedHashSet<String> newCollections = new LinkedHashSet<>(collections.size());\n        for (String coll : collections) {\n          if (coll.equals(before)) {\n            newCollections.add(after);\n          } else {\n            newCollections.add(coll);\n          }\n        }\n        entry.setValue(Collections.unmodifiableList(new ArrayList<>(newCollections)));\n      }\n    }\n    if (level1 == null) { // create an alias that points to the collection\n      newColAliases.put(before, Collections.singletonList(after));\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce0b61a2648584b34304ab915de569c63bdb36b4","date":1562311172,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithRename(String,String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Aliases#cloneWithRename(String,String).mjava","sourceNew":"  /**\n   * Rename an alias. This performs a \"deep rename\", which changes also the second-level alias lists.\n   * Renaming routed aliases is not supported.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param before previous alias name, must not be null\n   * @param after new alias name. If this is null then it's equivalent to calling {@link #cloneWithCollectionAlias(String, String)}\n   *              with the second argument set to null, ie. removing an alias.\n   * @return new instance with the renamed alias\n   * @throws SolrException when either <code>before</code> or <code>after</code> is empty, or\n   * the <code>before</code> name is a routed alias\n   */\n  public Aliases cloneWithRename(String before, String after) throws SolrException {\n    if (before == null) {\n      throw new NullPointerException(\"'before' and 'after' cannot be null\");\n    }\n    if (after == null) {\n      return cloneWithCollectionAlias(before, after);\n    }\n    if (before.isEmpty() || after.isEmpty()) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'before' and 'after' cannot be empty\");\n    }\n    if (before.equals(after)) {\n      return this;\n    }\n    Map<String, String> props = collectionAliasProperties.get(before);\n    if (props != null) {\n      if (props.keySet().stream().anyMatch(k -> k.startsWith(CollectionAdminParams.ROUTER_PREFIX))) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"source name '\" + before + \"' is a routed alias.\");\n      }\n    }\n    Map<String, Map<String, String>> newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    List<String> level1 = newColAliases.remove(before);\n    props = newColProperties.remove(before);\n    if (level1 != null) {\n      newColAliases.put(after, level1);\n    }\n    if (props != null) {\n      newColProperties.put(after, props);\n    }\n    for (Map.Entry<String, List<String>> entry : newColAliases.entrySet()) {\n      List<String> collections = entry.getValue();\n      if (collections.contains(before)) {\n        LinkedHashSet<String> newCollections = new LinkedHashSet<>(collections.size());\n        for (String coll : collections) {\n          if (coll.equals(before)) {\n            newCollections.add(after);\n          } else {\n            newCollections.add(coll);\n          }\n        }\n        entry.setValue(Collections.unmodifiableList(new ArrayList<>(newCollections)));\n      }\n    }\n    if (level1 == null) { // create an alias that points to the collection\n      newColAliases.put(before, Collections.singletonList(after));\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","sourceOld":"  /**\n   * Rename an alias. This performs a \"deep rename\", which changes also the second-level alias lists.\n   * Renaming routed aliases is not supported.\n   * <p>\n   * Note that the state in zookeeper is unaffected by this method and the change must still be persisted via\n   * {@link ZkStateReader.AliasesManager#applyModificationAndExportToZk(UnaryOperator)}\n   *\n   * @param before previous alias name, must not be null\n   * @param after new alias name. If this is null then it's equivalent to calling {@link #cloneWithCollectionAlias(String, String)}\n   *              with the second argument set to null, ie. removing an alias.\n   * @return new instance with the renamed alias\n   * @throws IllegalArgumentException when either <code>before</code> or <code>after</code> is empty, or\n   * the <code>before</code> name is a routed alias\n   */\n  public Aliases cloneWithRename(String before, String after) {\n    if (before == null) {\n      throw new NullPointerException(\"'before' and 'after' cannot be null\");\n    }\n    if (after == null) {\n      return cloneWithCollectionAlias(before, after);\n    }\n    if (before.isEmpty() || after.isEmpty()) {\n      throw new IllegalArgumentException(\"'before' and 'after' cannot be empty\");\n    }\n    if (before.equals(after)) {\n      return this;\n    }\n    Map<String, String> props = collectionAliasProperties.get(before);\n    if (props != null) {\n      if (props.keySet().stream().anyMatch(k -> k.startsWith(CollectionAdminParams.ROUTER_PREFIX))) {\n        throw new IllegalArgumentException(\"source name '\" + before + \"' is a routed alias.\");\n      }\n    }\n    Map<String, Map<String, String>> newColProperties = new LinkedHashMap<>(this.collectionAliasProperties);\n    Map<String, List<String>> newColAliases = new LinkedHashMap<>(this.collectionAliases);//clone to modify\n    List<String> level1 = newColAliases.remove(before);\n    props = newColProperties.remove(before);\n    if (level1 != null) {\n      newColAliases.put(after, level1);\n    }\n    if (props != null) {\n      newColProperties.put(after, props);\n    }\n    for (Map.Entry<String, List<String>> entry : newColAliases.entrySet()) {\n      List<String> collections = entry.getValue();\n      if (collections.contains(before)) {\n        LinkedHashSet<String> newCollections = new LinkedHashSet<>(collections.size());\n        for (String coll : collections) {\n          if (coll.equals(before)) {\n            newCollections.add(after);\n          } else {\n            newCollections.add(coll);\n          }\n        }\n        entry.setValue(Collections.unmodifiableList(new ArrayList<>(newCollections)));\n      }\n    }\n    if (level1 == null) { // create an alias that points to the collection\n      newColAliases.put(before, Collections.singletonList(after));\n    }\n    return new Aliases(newColAliases, newColProperties, zNodeVersion);\n  }\n\n","bugFix":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ce0b61a2648584b34304ab915de569c63bdb36b4":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ce0b61a2648584b34304ab915de569c63bdb36b4"]},"commit2Childs":{"ce0b61a2648584b34304ab915de569c63bdb36b4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"59bad1cc1e7f90125a140496e79b06afcedb68ec":["ce0b61a2648584b34304ab915de569c63bdb36b4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["59bad1cc1e7f90125a140496e79b06afcedb68ec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}