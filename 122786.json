{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","commits":[{"id":"3ce36a160d1241ae9c70e109dc3fdfdfb009674a","date":1307033216,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    final GroupDocs[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups(new TopGroups(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d62f5453a200cec2cbb60148de159dbf55591e9d","date":1307049300,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    final GroupDocs[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups(new TopGroups(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fa60a501961bce2ff07ee1cde7c78699025547e","date":1307054117,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    final GroupDocs[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups(new TopGroups(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":["85d41890f2bad879e6a04c6dd7d2cf276f973994"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c715a0f99152be7566591f323c6c5a25725a1bcb","date":1307118449,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e7c99bd45fa88a3d93a03fdd773053bef72268e","date":1307218088,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    final GroupDocs[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups(new TopGroups(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4aa50b979cd392e00e5bc0f23f78cbd106cb968","date":1308150768,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Comparable[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bfa39296944e5fddc334aa89243d91f9cbb8367","date":1330973284,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72c26897e0e0c4b4f3e73c8c43b1cf89f2564127","date":1331198608,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eb008c8f8fc29e5deccfa43d8a054268ba1c5e48","date":1331199997,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings(\"unchecked\")\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/BlockGroupingCollector#getTopGroups(Sort,int,int,int,boolean).mjava","sourceNew":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","sourceOld":"  /** Returns the grouped results.  Returns null if the\n   *  number of groups collected is <= groupOffset.\n   *\n   *  <p><b>NOTE</b>: This collector is unable to compute\n   *  the groupValue per group so it will always be null.\n   *  This is normally not a problem, as you can obtain the\n   *  value just like you obtain other values for each\n   *  matching document (eg, via stored fields, via\n   *  FieldCache, etc.)\n   *\n   *  @param withinGroupSort The {@link Sort} used to sort\n   *    documents within each group.  Passing null is\n   *    allowed, to sort by relevance.\n   *  @param groupOffset Which group to start from\n   *  @param withinGroupOffset Which document to start from\n   *    within each group\n   *  @param maxDocsPerGroup How many top documents to keep\n   *     within each group.\n   *  @param fillSortFields If true then the Comparable\n   *     values for the sort fields will be set\n   */\n  public TopGroups<?> getTopGroups(Sort withinGroupSort, int groupOffset, int withinGroupOffset, int maxDocsPerGroup, boolean fillSortFields) throws IOException {\n\n    //if (queueFull) {\n    //System.out.println(\"getTopGroups groupOffset=\" + groupOffset + \" topNGroups=\" + topNGroups);\n    //}\n    if (subDocUpto != 0) {\n      processGroup();\n    }\n    if (groupOffset >= groupQueue.size()) {\n      return null;\n    }\n    int totalGroupedHitCount = 0;\n\n    final FakeScorer fakeScorer = new FakeScorer();\n\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n    final GroupDocs<Object>[] groups = new GroupDocs[groupQueue.size() - groupOffset];\n    for(int downTo=groupQueue.size()-groupOffset-1;downTo>=0;downTo--) {\n      final OneGroup og = groupQueue.pop();\n\n      // At this point we hold all docs w/ in each group,\n      // unsorted; we now sort them:\n      final TopDocsCollector<?> collector;\n      if (withinGroupSort == null) {\n        // Sort by score\n        if (!needsScores) {\n          throw new IllegalArgumentException(\"cannot sort by relevance within group: needsScores=false\");\n        }\n        collector = TopScoreDocCollector.create(maxDocsPerGroup, true);\n      } else {\n        // Sort by fields\n        collector = TopFieldCollector.create(withinGroupSort, maxDocsPerGroup, fillSortFields, needsScores, needsScores, true);\n      }\n\n      collector.setScorer(fakeScorer);\n      collector.setNextReader(og.readerContext);\n      for(int docIDX=0;docIDX<og.count;docIDX++) {\n        final int doc = og.docs[docIDX];\n        fakeScorer.doc = doc;\n        if (needsScores) {\n          fakeScorer.score = og.scores[docIDX];\n        }\n        collector.collect(doc);\n      }\n      totalGroupedHitCount += og.count;\n\n      final Object[] groupSortValues;\n\n      if (fillSortFields) {\n        groupSortValues = new Comparable<?>[comparators.length];\n        for(int sortFieldIDX=0;sortFieldIDX<comparators.length;sortFieldIDX++) {\n          groupSortValues[sortFieldIDX] = comparators[sortFieldIDX].value(og.comparatorSlot);\n        }\n      } else {\n        groupSortValues = null;\n      }\n\n      final TopDocs topDocs = collector.topDocs(withinGroupOffset, maxDocsPerGroup);\n\n      groups[downTo] = new GroupDocs<Object>(topDocs.getMaxScore(),\n                                     og.count,\n                                     topDocs.scoreDocs,\n                                     null,\n                                     groupSortValues);\n    }\n\n    /*\n    while (groupQueue.size() != 0) {\n      final OneGroup og = groupQueue.pop();\n      //System.out.println(\"  leftover: og ord=\" + og.groupOrd + \" count=\" + og.count);\n      totalGroupedHitCount += og.count;\n    }\n    */\n\n    return new TopGroups<Object>(new TopGroups<Object>(groupSort.getSort(),\n                                       withinGroupSort == null ? null : withinGroupSort.getSort(),\n                                       totalHitCount, totalGroupedHitCount, groups),\n                         totalGroupCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","eb008c8f8fc29e5deccfa43d8a054268ba1c5e48"],"72c26897e0e0c4b4f3e73c8c43b1cf89f2564127":["8bfa39296944e5fddc334aa89243d91f9cbb8367"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968","8bfa39296944e5fddc334aa89243d91f9cbb8367"],"eb008c8f8fc29e5deccfa43d8a054268ba1c5e48":["72c26897e0e0c4b4f3e73c8c43b1cf89f2564127"],"c715a0f99152be7566591f323c6c5a25725a1bcb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1fa60a501961bce2ff07ee1cde7c78699025547e"],"d62f5453a200cec2cbb60148de159dbf55591e9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["1fa60a501961bce2ff07ee1cde7c78699025547e"],"1fa60a501961bce2ff07ee1cde7c78699025547e":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["d62f5453a200cec2cbb60148de159dbf55591e9d","1fa60a501961bce2ff07ee1cde7c78699025547e"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["1e7c99bd45fa88a3d93a03fdd773053bef72268e","d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["eb008c8f8fc29e5deccfa43d8a054268ba1c5e48"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8bfa39296944e5fddc334aa89243d91f9cbb8367":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"72c26897e0e0c4b4f3e73c8c43b1cf89f2564127":["eb008c8f8fc29e5deccfa43d8a054268ba1c5e48"],"3ce36a160d1241ae9c70e109dc3fdfdfb009674a":["d62f5453a200cec2cbb60148de159dbf55591e9d","1fa60a501961bce2ff07ee1cde7c78699025547e"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"eb008c8f8fc29e5deccfa43d8a054268ba1c5e48":["38e3b736c7ca086d61b7dbb841c905ee115490da","b89678825b68eccaf09e6ab71675fc0b0af1e099"],"c715a0f99152be7566591f323c6c5a25725a1bcb":[],"d62f5453a200cec2cbb60148de159dbf55591e9d":["1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","8bfa39296944e5fddc334aa89243d91f9cbb8367"],"1fa60a501961bce2ff07ee1cde7c78699025547e":["c715a0f99152be7566591f323c6c5a25725a1bcb","d4aa50b979cd392e00e5bc0f23f78cbd106cb968","1e7c99bd45fa88a3d93a03fdd773053bef72268e"],"1e7c99bd45fa88a3d93a03fdd773053bef72268e":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b"],"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":[],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3ce36a160d1241ae9c70e109dc3fdfdfb009674a","c715a0f99152be7566591f323c6c5a25725a1bcb","d62f5453a200cec2cbb60148de159dbf55591e9d"],"8bfa39296944e5fddc334aa89243d91f9cbb8367":["72c26897e0e0c4b4f3e73c8c43b1cf89f2564127","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","c715a0f99152be7566591f323c6c5a25725a1bcb","0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}