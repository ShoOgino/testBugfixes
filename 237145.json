{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#uninvert(String,PointValues).mjava","commits":[{"id":"270881512f74569f7bc71bfe95534b337d53a60b","date":1454112544,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#uninvert(String,PointValues).mjava","pathOld":"/dev/null","sourceNew":"  // naive silly memory heavy uninversion!!  maps docID -> packed values (a Set because a given doc can be multi-valued)\n  private Map<Integer,Set<BytesRef>> uninvert(String fieldName, PointValues points) throws IOException {\n    final Map<Integer,Set<BytesRef>> docValues = new HashMap<>();\n    points.intersect(fieldName, new PointValues.IntersectVisitor() {\n        @Override\n        public void visit(int docID) {\n          throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {\n          if (docValues.containsKey(docID) == false) {\n            docValues.put(docID, new HashSet<BytesRef>());\n          }\n          docValues.get(docID).add(new BytesRef(packedValue.clone()));\n        }\n\n        @Override\n        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          // We pretend our query shape is so hairy that it crosses every single cell:\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    return docValues;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d15e34266d75e4e8b95da046cd0afc812367b38","date":1454246129,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#uninvert(String,PointValues).mjava","pathOld":"/dev/null","sourceNew":"  // naive silly memory heavy uninversion!!  maps docID -> packed values (a Set because a given doc can be multi-valued)\n  private Map<Integer,Set<BytesRef>> uninvert(String fieldName, PointValues points) throws IOException {\n    final Map<Integer,Set<BytesRef>> docValues = new HashMap<>();\n    points.intersect(fieldName, new PointValues.IntersectVisitor() {\n        @Override\n        public void visit(int docID) {\n          throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {\n          if (docValues.containsKey(docID) == false) {\n            docValues.put(docID, new HashSet<BytesRef>());\n          }\n          docValues.get(docID).add(new BytesRef(packedValue.clone()));\n        }\n\n        @Override\n        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          // We pretend our query shape is so hairy that it crosses every single cell:\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    return docValues;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#uninvert(String,PointValues).mjava","pathOld":"/dev/null","sourceNew":"  // naive silly memory heavy uninversion!!  maps docID -> packed values (a Set because a given doc can be multi-valued)\n  private Map<Integer,Set<BytesRef>> uninvert(String fieldName, PointValues points) throws IOException {\n    final Map<Integer,Set<BytesRef>> docValues = new HashMap<>();\n    points.intersect(fieldName, new PointValues.IntersectVisitor() {\n        @Override\n        public void visit(int docID) {\n          throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {\n          if (docValues.containsKey(docID) == false) {\n            docValues.put(docID, new HashSet<BytesRef>());\n          }\n          docValues.get(docID).add(new BytesRef(packedValue.clone()));\n        }\n\n        @Override\n        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          // We pretend our query shape is so hairy that it crosses every single cell:\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    return docValues;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#uninvert(String,PointValues).mjava","sourceNew":null,"sourceOld":"  // naive silly memory heavy uninversion!!  maps docID -> packed values (a Set because a given doc can be multi-valued)\n  private Map<Integer,Set<BytesRef>> uninvert(String fieldName, PointValues points) throws IOException {\n    final Map<Integer,Set<BytesRef>> docValues = new HashMap<>();\n    points.intersect(fieldName, new PointValues.IntersectVisitor() {\n        @Override\n        public void visit(int docID) {\n          throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {\n          if (docValues.containsKey(docID) == false) {\n            docValues.put(docID, new HashSet<BytesRef>());\n          }\n          docValues.get(docID).add(new BytesRef(packedValue.clone()));\n        }\n\n        @Override\n        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          // We pretend our query shape is so hairy that it crosses every single cell:\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    return docValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#uninvert(String,PointValues).mjava","sourceNew":null,"sourceOld":"  // naive silly memory heavy uninversion!!  maps docID -> packed values (a Set because a given doc can be multi-valued)\n  private Map<Integer,Set<BytesRef>> uninvert(String fieldName, PointValues points) throws IOException {\n    final Map<Integer,Set<BytesRef>> docValues = new HashMap<>();\n    points.intersect(fieldName, new PointValues.IntersectVisitor() {\n        @Override\n        public void visit(int docID) {\n          throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void visit(int docID, byte[] packedValue) throws IOException {\n          if (docValues.containsKey(docID) == false) {\n            docValues.put(docID, new HashSet<BytesRef>());\n          }\n          docValues.get(docID).add(new BytesRef(packedValue.clone()));\n        }\n\n        @Override\n        public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n          // We pretend our query shape is so hairy that it crosses every single cell:\n          return PointValues.Relation.CELL_CROSSES_QUERY;\n        }\n      });\n    return docValues;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"270881512f74569f7bc71bfe95534b337d53a60b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8d15e34266d75e4e8b95da046cd0afc812367b38"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["8d15e34266d75e4e8b95da046cd0afc812367b38","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","270881512f74569f7bc71bfe95534b337d53a60b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"270881512f74569f7bc71bfe95534b337d53a60b":["8d15e34266d75e4e8b95da046cd0afc812367b38"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["270881512f74569f7bc71bfe95534b337d53a60b","1e6acbaae7af722f17204ceccf0f7db5753eccf3","8d15e34266d75e4e8b95da046cd0afc812367b38"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"8d15e34266d75e4e8b95da046cd0afc812367b38":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cf1a614098b46c9c22afebd7b898ae4d1d2fc273","adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}