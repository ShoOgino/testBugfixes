{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","commits":[{"id":"f838187609fee3a1afa5f162f93c796046242c84","date":1406216791,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"/dev/null","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length, text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.bytes[pos] == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length, text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.bytes[pos] == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","bugFix":["f838187609fee3a1afa5f162f93c796046242c84"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4d0c32e610dfdab7f36c51dae0db055948cc335","date":1578297771,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      // Find common prefix between last term and current term:\n      int prefixLength = Arrays.mismatch(lastTerm.bytes(), 0, lastTerm.length(), text.bytes, text.offset, text.offset + text.length);\n      if (prefixLength == -1) { // Only happens for the first term, if it is empty\n        assert lastTerm.length() == 0;\n        prefixLength = 0;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=prefixLength;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=prefixLength;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca62564055241632cd20d65b5ecb8c8e93bd60c4","date":1578383112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsWriter.TermsWriter#pushTerm(BytesRef).mjava","sourceNew":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      // Find common prefix between last term and current term:\n      int prefixLength = Arrays.mismatch(lastTerm.bytes(), 0, lastTerm.length(), text.bytes, text.offset, text.offset + text.length);\n      if (prefixLength == -1) { // Only happens for the first term, if it is empty\n        assert lastTerm.length() == 0;\n        prefixLength = 0;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=prefixLength;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=prefixLength;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","sourceOld":"    /** Pushes the new term to the top of the stack, and writes new blocks. */\n    private void pushTerm(BytesRef text) throws IOException {\n      int limit = Math.min(lastTerm.length(), text.length);\n\n      // Find common prefix between last term and current term:\n      int pos = 0;\n      while (pos < limit && lastTerm.byteAt(pos) == text.bytes[text.offset+pos]) {\n        pos++;\n      }\n\n      // if (DEBUG) System.out.println(\"  shared=\" + pos + \"  lastTerm.length=\" + lastTerm.length);\n\n      // Close the \"abandoned\" suffix now:\n      for(int i=lastTerm.length()-1;i>=pos;i--) {\n\n        // How many items on top of the stack share the current suffix\n        // we are closing:\n        int prefixTopSize = pending.size() - prefixStarts[i];\n        if (prefixTopSize >= minItemsInBlock) {\n          // if (DEBUG) System.out.println(\"pushTerm i=\" + i + \" prefixTopSize=\" + prefixTopSize + \" minItemsInBlock=\" + minItemsInBlock);\n          writeBlocks(i+1, prefixTopSize);\n          prefixStarts[i] -= prefixTopSize-1;\n        }\n      }\n\n      if (prefixStarts.length < text.length) {\n        prefixStarts = ArrayUtil.grow(prefixStarts, text.length);\n      }\n\n      // Init new tail:\n      for(int i=pos;i<text.length;i++) {\n        prefixStarts[i] = pending.size();\n      }\n\n      lastTerm.copyBytes(text);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f4d0c32e610dfdab7f36c51dae0db055948cc335":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f838187609fee3a1afa5f162f93c796046242c84"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","f4d0c32e610dfdab7f36c51dae0db055948cc335"],"f838187609fee3a1afa5f162f93c796046242c84":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f4d0c32e610dfdab7f36c51dae0db055948cc335"]},"commit2Childs":{"f4d0c32e610dfdab7f36c51dae0db055948cc335":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f838187609fee3a1afa5f162f93c796046242c84"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f4d0c32e610dfdab7f36c51dae0db055948cc335","ca62564055241632cd20d65b5ecb8c8e93bd60c4"],"ca62564055241632cd20d65b5ecb8c8e93bd60c4":[],"f838187609fee3a1afa5f162f93c796046242c84":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ca62564055241632cd20d65b5ecb8c8e93bd60c4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}