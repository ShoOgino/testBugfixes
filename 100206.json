{"path":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","commits":[{"id":"a219f1dcad1700e84807666bdbd2b573e8de7021","date":1428130940,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Map[String,Object]).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE. Preparing to switch shard states.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n            propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n            propMap.put(sliceName, Slice.State.ACTIVE.toString());\n            for (Slice subShardSlice : subShardSlices) {\n              propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n            }\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Map<String, Object> replicaProps) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (ZkStateReader.ACTIVE.equals(replicaProps.get(ZkStateReader.STATE_PROP))) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (!ZkStateReader.ACTIVE.equals(entry.getValue().getStr(ZkStateReader.STATE_PROP))) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (!ZkStateReader.ACTIVE.equals(sliceEntry.getValue().getStr(ZkStateReader.STATE_PROP))) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE. Preparing to switch shard states.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n            propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n            propMap.put(sliceName, Slice.State.ACTIVE.toString());\n            for (Slice subShardSlice : subShardSlices) {\n              propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n            }\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","date":1473679846,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                Stat leaderZnodeStat = zkStateReader.getZkClient().exists(ZkStateReader.LIVE_NODES_ZKNODE\n                    + \"/\" + shardParentNode, null, true);\n                if (leaderZnodeStat == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (leaderZnodeStat.getEphemeralOwner() != Long.parseLong(shardParentZkSession))  {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnodeStat.getEphemeralOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE. Preparing to switch shard states.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n            propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n            propMap.put(sliceName, Slice.State.ACTIVE.toString());\n            for (Slice subShardSlice : subShardSlices) {\n              propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n            }\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":["d0dcc63c22f7cfe3d3a83aee576d0fc5b403a296","24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                Stat leaderZnodeStat = zkStateReader.getZkClient().exists(ZkStateReader.LIVE_NODES_ZKNODE\n                    + \"/\" + shardParentNode, null, true);\n                if (leaderZnodeStat == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (leaderZnodeStat.getEphemeralOwner() != Long.parseLong(shardParentZkSession))  {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnodeStat.getEphemeralOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE. Preparing to switch shard states.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n            propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n            propMap.put(sliceName, Slice.State.ACTIVE.toString());\n            for (Slice subShardSlice : subShardSlices) {\n              propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n            }\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                Stat leaderZnodeStat = zkStateReader.getZkClient().exists(ZkStateReader.LIVE_NODES_ZKNODE\n                    + \"/\" + shardParentNode, null, true);\n                if (leaderZnodeStat == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (leaderZnodeStat.getEphemeralOwner() != Long.parseLong(shardParentZkSession))  {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnodeStat.getEphemeralOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE. Preparing to switch shard states.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n            propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n            propMap.put(sliceName, Slice.State.ACTIVE.toString());\n            for (Slice subShardSlice : subShardSlices) {\n              propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n            }\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                Stat leaderZnodeStat = zkStateReader.getZkClient().exists(ZkStateReader.LIVE_NODES_ZKNODE\n                    + \"/\" + shardParentNode, null, true);\n                if (leaderZnodeStat == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (leaderZnodeStat.getEphemeralOwner() != Long.parseLong(shardParentZkSession))  {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnodeStat.getEphemeralOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE. Preparing to switch shard states.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n            propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n            propMap.put(sliceName, Slice.State.ACTIVE.toString());\n            for (Slice subShardSlice : subShardSlices) {\n              propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n            }\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(dataProvider).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(dataProvider).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                Stat leaderZnodeStat = zkStateReader.getZkClient().exists(ZkStateReader.LIVE_NODES_ZKNODE\n                    + \"/\" + shardParentNode, null, true);\n                if (leaderZnodeStat == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (leaderZnodeStat.getEphemeralOwner() != Long.parseLong(shardParentZkSession))  {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnodeStat.getEphemeralOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(zkStateReader).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"20c968c14aace7cf49843bf2c1fafc7fd3845659","date":1533133859,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(dataProvider).updateShardState(prevState, m).collection;\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              Map<String, Object> propMap = new HashMap<>();\n              propMap.put(Overseer.QUEUE_OPERATION, \"updateshardstate\");\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n              propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n              ZkNodeProps m = new ZkNodeProps(propMap);\n              return new SliceMutator(dataProvider).updateShardState(prevState, m).collection;\n            }\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae70f2df00762dfce0455c0e39381848762662e5","date":1539113410,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"383671a9fe2f5147abf22eb1ce56e3ca3d6eb133","date":1541008054,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all replicas are active. Finding status of fellow sub-shards\", sliceName);\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all replicas active\", sliceName, otherSlice.getName());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":["24a5da2a0d397ff29f3de8f6cf451d3412c2509a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null) {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null) {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null) {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null) {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession  = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null)  {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null)  {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else  {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator#checkAndCompleteShardSplit(ClusterState,DocCollection,String,String,Replica).mjava","sourceNew":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          if (log.isInfoEnabled()) {\n            log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          }\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                }\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                if (log.isInfoEnabled()) {\n                  log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                }\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null) {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null) {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. {}\"\n                    , \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  if (log.isInfoEnabled()) {\n                    log.info(\"TIMINGS: Sub-shard {} recovered in {} ms\", subShardSlice.getName(),\n                        TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS));\n                  }\n                } else {\n                  if (log.isInfoEnabled()) {\n                    log.info(\"TIMINGS Sub-shard {} not available: {}\", subShardSlice.getName(), subShardSlice);\n                  }\n                }\n              }\n            } else {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after {} successful split: {} / {}\"\n                  , (isLeaderSame ? \"\" : \"un\"), collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","sourceOld":"  private DocCollection checkAndCompleteShardSplit(ClusterState prevState, DocCollection collection, String coreNodeName, String sliceName, Replica replica) {\n    Slice slice = collection.getSlice(sliceName);\n    Map<String, Object> sliceProps = slice.getProperties();\n    if (slice.getState() == Slice.State.RECOVERY) {\n      log.info(\"Shard: {} is in recovery state\", sliceName);\n      // is this replica active?\n      if (replica.getState() == Replica.State.ACTIVE) {\n        log.info(\"Shard: {} is in recovery state and coreNodeName: {} is active\", sliceName, coreNodeName);\n        // are all other replicas also active?\n        boolean allActive = true;\n        for (Map.Entry<String, Replica> entry : slice.getReplicasMap().entrySet()) {\n          if (coreNodeName.equals(entry.getKey())) continue;\n          if (entry.getValue().getState() != Replica.State.ACTIVE) {\n            allActive = false;\n            break;\n          }\n        }\n        if (allActive) {\n          log.info(\"Shard: {} - all {} replicas are active. Finding status of fellow sub-shards\", sliceName, slice.getReplicasMap().size());\n          // find out about other sub shards\n          Map<String, Slice> allSlicesCopy = new HashMap<>(collection.getSlicesMap());\n          List<Slice> subShardSlices = new ArrayList<>();\n          outer:\n          for (Map.Entry<String, Slice> entry : allSlicesCopy.entrySet()) {\n            if (sliceName.equals(entry.getKey()))\n              continue;\n            Slice otherSlice = entry.getValue();\n            if (otherSlice.getState() == Slice.State.RECOVERY) {\n              if (slice.getParent() != null && slice.getParent().equals(otherSlice.getParent())) {\n                log.info(\"Shard: {} - Fellow sub-shard: {} found\", sliceName, otherSlice.getName());\n                // this is a fellow sub shard so check if all replicas are active\n                for (Map.Entry<String, Replica> sliceEntry : otherSlice.getReplicasMap().entrySet()) {\n                  if (sliceEntry.getValue().getState() != Replica.State.ACTIVE) {\n                    allActive = false;\n                    break outer;\n                  }\n                }\n                log.info(\"Shard: {} - Fellow sub-shard: {} has all {} replicas active\", sliceName, otherSlice.getName(), otherSlice.getReplicasMap().size());\n                subShardSlices.add(otherSlice);\n              }\n            }\n          }\n          if (allActive) {\n            // hurray, all sub shard replicas are active\n            log.info(\"Shard: {} - All replicas across all fellow sub-shards are now ACTIVE.\", sliceName);\n            String parentSliceName = (String) sliceProps.remove(Slice.PARENT);\n            // now lets see if the parent leader is still the same or else there's a chance of data loss\n            // see SOLR-9438 for details\n            String shardParentZkSession = (String) sliceProps.remove(\"shard_parent_zk_session\");\n            String shardParentNode = (String) sliceProps.remove(\"shard_parent_node\");\n            boolean isLeaderSame = true;\n            if (shardParentNode != null && shardParentZkSession != null) {\n              log.info(\"Checking whether sub-shard leader node is still the same one at {} with ZK session id {}\", shardParentNode, shardParentZkSession);\n              try {\n                VersionedData leaderZnode = null;\n                try {\n                  leaderZnode = stateManager.getData(ZkStateReader.LIVE_NODES_ZKNODE\n                      + \"/\" + shardParentNode, null);\n                } catch (NoSuchElementException e) {\n                  // ignore\n                }\n                if (leaderZnode == null) {\n                  log.error(\"The shard leader node: {} is not live anymore!\", shardParentNode);\n                  isLeaderSame = false;\n                } else if (!shardParentZkSession.equals(leaderZnode.getOwner())) {\n                  log.error(\"The zk session id for shard leader node: {} has changed from {} to {}\",\n                      shardParentNode, shardParentZkSession, leaderZnode.getOwner());\n                  isLeaderSame = false;\n                }\n              } catch (Exception e) {\n                log.warn(\"Error occurred while checking if parent shard node is still live with the same zk session id. \" +\n                    \"We cannot switch shard states at this time.\", e);\n                return collection; // we aren't going to make any changes right now\n              }\n            }\n\n            Map<String, Object> propMap = new HashMap<>();\n            propMap.put(Overseer.QUEUE_OPERATION, OverseerAction.UPDATESHARDSTATE.toLower());\n            propMap.put(ZkStateReader.COLLECTION_PROP, collection.getName());\n            if (isLeaderSame) {\n              log.info(\"Sub-shard leader node is still the same one at {} with ZK session id {}. Preparing to switch shard states.\", shardParentNode, shardParentZkSession);\n              propMap.put(parentSliceName, Slice.State.INACTIVE.toString());\n              propMap.put(sliceName, Slice.State.ACTIVE.toString());\n              long now = cloudManager.getTimeSource().getEpochTimeNs();\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.ACTIVE.toString());\n                String lastTimeStr = subShardSlice.getStr(ZkStateReader.STATE_TIMESTAMP_PROP);\n                if (lastTimeStr != null) {\n                  long start = Long.parseLong(lastTimeStr);\n                  log.info(\"TIMINGS: Sub-shard \" + subShardSlice.getName() + \" recovered in \" +\n                      TimeUnit.MILLISECONDS.convert(now - start, TimeUnit.NANOSECONDS) + \" ms\");\n                } else {\n                  log.info(\"TIMINGS Sub-shard \" + subShardSlice.getName() + \" not available: \" + subShardSlice);\n                }\n              }\n            } else {\n              // we must mark the shard split as failed by switching sub-shards to recovery_failed state\n              propMap.put(sliceName, Slice.State.RECOVERY_FAILED.toString());\n              for (Slice subShardSlice : subShardSlices) {\n                propMap.put(subShardSlice.getName(), Slice.State.RECOVERY_FAILED.toString());\n              }\n            }\n            TestInjection.injectSplitLatch();\n            try {\n              SplitShardCmd.unlockForSplit(cloudManager, collection.getName(), parentSliceName);\n            } catch (Exception e) {\n              log.warn(\"Failed to unlock shard after \" + (isLeaderSame ? \"\" : \"un\") + \"successful split: {} / {}\",\n                  collection.getName(), parentSliceName);\n            }\n            ZkNodeProps m = new ZkNodeProps(propMap);\n            return new SliceMutator(cloudManager).updateShardState(prevState, m).collection;\n          }\n        }\n      }\n    }\n    return collection;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["383671a9fe2f5147abf22eb1ce56e3ca3d6eb133","6681d02f2302c363be938426e68f8dfd090cc1bf"],"383671a9fe2f5147abf22eb1ce56e3ca3d6eb133":["ae70f2df00762dfce0455c0e39381848762662e5"],"6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"20c968c14aace7cf49843bf2c1fafc7fd3845659":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a219f1dcad1700e84807666bdbd2b573e8de7021","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["383671a9fe2f5147abf22eb1ce56e3ca3d6eb133"],"ae70f2df00762dfce0455c0e39381848762662e5":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"89424def13674ea17829b41c5883c54ecc31a132":["a219f1dcad1700e84807666bdbd2b573e8de7021","6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4abf821a41a2fdca2a1dea148999931d22e20529":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a219f1dcad1700e84807666bdbd2b573e8de7021","89424def13674ea17829b41c5883c54ecc31a132"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4abf821a41a2fdca2a1dea148999931d22e20529"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"383671a9fe2f5147abf22eb1ce56e3ca3d6eb133":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b":["89424def13674ea17829b41c5883c54ecc31a132"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["20c968c14aace7cf49843bf2c1fafc7fd3845659"],"20c968c14aace7cf49843bf2c1fafc7fd3845659":["ae70f2df00762dfce0455c0e39381848762662e5"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","4abf821a41a2fdca2a1dea148999931d22e20529"],"ae70f2df00762dfce0455c0e39381848762662e5":["383671a9fe2f5147abf22eb1ce56e3ca3d6eb133"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"a219f1dcad1700e84807666bdbd2b573e8de7021":["6a23ab64d81a448ad6ec571cbfc9599cc09b4e4b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"4abf821a41a2fdca2a1dea148999931d22e20529":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a219f1dcad1700e84807666bdbd2b573e8de7021"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}