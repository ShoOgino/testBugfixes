{"path":"lucene/core/src/test/org/apache/lucene/util/TestTimSorterWorstCase#generateWrongElem(int,int,List[Integer]).mjava","commits":[{"id":"6b084aac8181b28fb44fa34869a3137484ddde90","date":1428901096,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/util/TestTimSorterWorstCase#generateWrongElem(int,int,List[Integer]).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/util/TestTimSorter#generateWrongElem(int,int,List[Integer]).mjava","sourceNew":"  /**\n   * Adds a sequence x_1, ..., x_n of run lengths to <code>runs</code> such that:<br>\n   * 1. X = x_1 + ... + x_n <br>\n   * 2. x_j >= minRun for all j <br>\n   * 3. x_1 + ... + x_{j-2}  <  x_j  <  x_1 + ... + x_{j-1} for all j <br>\n   * These conditions guarantee that TimSort merges all x_j's one by one\n   * (resulting in X) using only merges on the second-to-last element.\n   * @param X  The sum of the sequence that should be added to runs.\n   */\n  private static void generateWrongElem(int X, int minRun, List<Integer> runs) {\n    for(int newTotal; X >= 2*minRun+1; X = newTotal) {\n      //Default strategy\n      newTotal = X/2 + 1;\n\n      //Specialized strategies\n      if(3*minRun+3 <= X && X <= 4*minRun+1) {\n        // add x_1=MIN+1, x_2=MIN, x_3=X-newTotal  to runs\n        newTotal = 2*minRun+1;\n      } else if(5*minRun+5 <= X && X <= 6*minRun+5) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=X-newTotal  to runs\n        newTotal = 3*minRun+3;\n      } else if(8*minRun+9 <= X && X <= 10*minRun+9) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=X-newTotal  to runs\n        newTotal = 5*minRun+5;\n      } else if(13*minRun+15 <= X && X <= 16*minRun+17) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=3MIN+4, x_6=X-newTotal  to runs\n        newTotal = 8*minRun+9;\n      }\n      runs.add(0, X-newTotal);\n    }\n    runs.add(0, X);\n  }\n\n","sourceOld":"  /**\n   * Adds a sequence x_1, ..., x_n of run lengths to <code>runs</code> such that:<br>\n   * 1. X = x_1 + ... + x_n <br>\n   * 2. x_j >= minRun for all j <br>\n   * 3. x_1 + ... + x_{j-2}  <  x_j  <  x_1 + ... + x_{j-1} for all j <br>\n   * These conditions guarantee that TimSort merges all x_j's one by one\n   * (resulting in X) using only merges on the second-to-last element.\n   * @param X  The sum of the sequence that should be added to runs.\n   */\n  private static void generateWrongElem(int X, int minRun, List<Integer> runs) {\n    for(int newTotal; X >= 2*minRun+1; X = newTotal) {\n      //Default strategy\n      newTotal = X/2 + 1;\n\n      //Specialized strategies\n      if(3*minRun+3 <= X && X <= 4*minRun+1) {\n        // add x_1=MIN+1, x_2=MIN, x_3=X-newTotal  to runs\n        newTotal = 2*minRun+1;\n      } else if(5*minRun+5 <= X && X <= 6*minRun+5) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=X-newTotal  to runs\n        newTotal = 3*minRun+3;\n      } else if(8*minRun+9 <= X && X <= 10*minRun+9) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=X-newTotal  to runs\n        newTotal = 5*minRun+5;\n      } else if(13*minRun+15 <= X && X <= 16*minRun+17) {\n        // add x_1=MIN+1, x_2=MIN, x_3=MIN+2, x_4=2MIN+2, x_5=3MIN+4, x_6=X-newTotal  to runs\n        newTotal = 8*minRun+9;\n      }\n      runs.add(0, X-newTotal);\n    }\n    runs.add(0, X);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6b084aac8181b28fb44fa34869a3137484ddde90":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b084aac8181b28fb44fa34869a3137484ddde90"]},"commit2Childs":{"6b084aac8181b28fb44fa34869a3137484ddde90":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6b084aac8181b28fb44fa34869a3137484ddde90"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}