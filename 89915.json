{"path":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"66e0b82bd39567aa2bf534e5282d05fb4a4a2c76","date":1471585465,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n      \n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      \n      collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#deleteCollection(ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  private void deleteCollection(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n      \n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      \n      collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n                             // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ee9ee847c92f9e0395e1ff6655ec464e0a57a2","date":1485828282,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0806aac02ecbbdc6b5d9705ae15da193219c7af4","date":1499930856,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      String collectionSpecificPolicy = \"COLL_POLICY_\" + collection;\n      if (collectionSpecificPolicy.equals(policy)) {\n        for (Map.Entry<String, ClusterState.CollectionRef> e : state.getCollectionStates().entrySet()) {\n          if (collection.equals(e.getKey())) continue;\n          DocCollection c = e.getValue().get();\n          if (collectionSpecificPolicy.equals(c.getPolicyName())) {\n            log.info(StrUtils.formatString(\"{0} is being used by collection {1} . So, it's not deleted\", collectionSpecificPolicy, e.getKey()));\n            return;\n          }\n\n        }\n        AutoScalingHandler ash = (AutoScalingHandler) ocmh.overseer.getZkController().getCoreContainer()\n            .getRequestHandler(AutoScalingHandler.HANDLER_PATH);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        try {\n          ash.handleRemovePolicy(null, rsp, new CommandOperation(AutoScalingParams.CMD_REMOVE_POLICY, collectionSpecificPolicy));\n        } catch (SolrException e) {\n          if (e.getMessage().contains(\"No policy exists with name\")) {\n            log.warn(\"The policy: \" + collectionSpecificPolicy + \" does not exist to be removed\");\n          } else {\n            throw e;\n          }\n        }\n      }\n\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25","date":1499961129,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      String collectionSpecificPolicy = \"COLL_POLICY_\" + collection;\n      if (collectionSpecificPolicy.equals(policy)) {\n        for (Map.Entry<String, ClusterState.CollectionRef> e : state.getCollectionStates().entrySet()) {\n          if (collection.equals(e.getKey())) continue;\n          DocCollection c = e.getValue().get();\n          if (collectionSpecificPolicy.equals(c.getPolicyName())) {\n            log.info(StrUtils.formatString(\"{0} is being used by collection {1} . So, it's not deleted\", collectionSpecificPolicy, e.getKey()));\n            return;\n          }\n\n        }\n        AutoScalingHandler ash = (AutoScalingHandler) ocmh.overseer.getZkController().getCoreContainer()\n            .getRequestHandler(AutoScalingHandler.HANDLER_PATH);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        try {\n          ash.processOps(null, rsp, Collections.singletonList(new CommandOperation(AutoScalingParams.CMD_REMOVE_POLICY, collectionSpecificPolicy)));\n        } catch (SolrException e) {\n          if (e.getMessage().contains(\"No policy exists with name\")) {\n            log.warn(\"The policy: \" + collectionSpecificPolicy + \" does not exist to be removed\");\n          } else {\n            throw e;\n          }\n        }\n      }\n\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      String collectionSpecificPolicy = \"COLL_POLICY_\" + collection;\n      if (collectionSpecificPolicy.equals(policy)) {\n        for (Map.Entry<String, ClusterState.CollectionRef> e : state.getCollectionStates().entrySet()) {\n          if (collection.equals(e.getKey())) continue;\n          DocCollection c = e.getValue().get();\n          if (collectionSpecificPolicy.equals(c.getPolicyName())) {\n            log.info(StrUtils.formatString(\"{0} is being used by collection {1} . So, it's not deleted\", collectionSpecificPolicy, e.getKey()));\n            return;\n          }\n\n        }\n        AutoScalingHandler ash = (AutoScalingHandler) ocmh.overseer.getZkController().getCoreContainer()\n            .getRequestHandler(AutoScalingHandler.HANDLER_PATH);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        try {\n          ash.handleRemovePolicy(null, rsp, new CommandOperation(AutoScalingParams.CMD_REMOVE_POLICY, collectionSpecificPolicy));\n        } catch (SolrException e) {\n          if (e.getMessage().contains(\"No policy exists with name\")) {\n            log.warn(\"The policy: \" + collectionSpecificPolicy + \" does not exist to be removed\");\n          } else {\n            throw e;\n          }\n        }\n      }\n\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4328dbef1afa8336d38a4301a545999d1e21f8fa","date":1502941879,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n      String collectionSpecificPolicy = \"COLL_POLICY_\" + collection;\n      if (collectionSpecificPolicy.equals(policy)) {\n        for (Map.Entry<String, ClusterState.CollectionRef> e : state.getCollectionStates().entrySet()) {\n          if (collection.equals(e.getKey())) continue;\n          DocCollection c = e.getValue().get();\n          if (collectionSpecificPolicy.equals(c.getPolicyName())) {\n            log.info(StrUtils.formatString(\"{0} is being used by collection {1} . So, it's not deleted\", collectionSpecificPolicy, e.getKey()));\n            return;\n          }\n\n        }\n        AutoScalingHandler ash = (AutoScalingHandler) ocmh.overseer.getZkController().getCoreContainer()\n            .getRequestHandler(AutoScalingHandler.HANDLER_PATH);\n        SolrQueryResponse rsp = new SolrQueryResponse();\n        try {\n          ash.processOps(null, rsp, Collections.singletonList(new CommandOperation(AutoScalingParams.CMD_REMOVE_POLICY, collectionSpecificPolicy)));\n        } catch (SolrException e) {\n          if (e.getMessage().contains(\"No policy exists with name\")) {\n            log.warn(\"The policy: \" + collectionSpecificPolicy + \" does not exist to be removed\");\n          } else {\n            throw e;\n          }\n        }\n      }\n\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        Thread.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          Thread.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b342321d8906f4b19f6f87ea33ea3fff12bffa7","date":1515547632,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["7d9def7b715c2324a9f84c1fc2e60a5c03c73331","7d9def7b715c2324a9f84c1fc2e60a5c03c73331"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    Aliases aliases = zkStateReader.getAliases();\n    final String collection = message.getStr(NAME);\n    for (Map.Entry<String, List<String>> ent :  aliases.getCollectionAliasListMap().entrySet()) {\n      if (ent.getValue().contains(collection)) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Collection : \" + collection + \" is part of alias \" + ent.getKey() + \" remove or modify the alias before removing this collection.\");\n      }\n    }\n\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    final String collection = message.getStr(NAME);\n    DocCollection coll = state.getCollectionOrNull(collection);\n    String policy = coll == null ? null : coll.getPolicyName();\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n\n      String asyncId = message.getStr(ASYNC);\n      Map<String, String> requestMap = null;\n      if (asyncId != null) {\n        requestMap = new HashMap<>();\n      }\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n\n      ocmh.collectionCmd(message, params, results, null, asyncId, requestMap, okayExceptions);\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, timeSource);\n      boolean removed = false;\n      while (! timeout.hasTimedOut()) {\n        timeout.sleep(100);\n        removed = !zkStateReader.getClusterState().hasCollection(collection);\n        if (removed) {\n          timeout.sleep(500); // just a bit of time so it's more likely other\n          // readers see on return\n          break;\n        }\n      }\n      if (!removed) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Could not fully remove collection: \" + collection);\n      }\n\n    } finally {\n\n      try {\n        if (zkStateReader.getZkClient().exists(\n            ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          zkStateReader.getZkClient().clean(\n              ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection);\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["23ee9ee847c92f9e0395e1ff6655ec464e0a57a2","4328dbef1afa8336d38a4301a545999d1e21f8fa"],"4b342321d8906f4b19f6f87ea33ea3fff12bffa7":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","23ee9ee847c92f9e0395e1ff6655ec464e0a57a2"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["0806aac02ecbbdc6b5d9705ae15da193219c7af4"],"0806aac02ecbbdc6b5d9705ae15da193219c7af4":["23ee9ee847c92f9e0395e1ff6655ec464e0a57a2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","403d05f7f8d69b65659157eff1bc1d2717f04c66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"66e0b82bd39567aa2bf534e5282d05fb4a4a2c76":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23ee9ee847c92f9e0395e1ff6655ec464e0a57a2":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["560c18d71dad43d675158783c3840f8c80d6d39c"],"560c18d71dad43d675158783c3840f8c80d6d39c":["23ee9ee847c92f9e0395e1ff6655ec464e0a57a2","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"4328dbef1afa8336d38a4301a545999d1e21f8fa":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","23ee9ee847c92f9e0395e1ff6655ec464e0a57a2"],"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"4b342321d8906f4b19f6f87ea33ea3fff12bffa7":["6146c07c0dee1ae1e42926167acd127fed5ef59d"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25":["4328dbef1afa8336d38a4301a545999d1e21f8fa"],"0806aac02ecbbdc6b5d9705ae15da193219c7af4":["219ac4e012cb38bcfcd8f4290dccd4f5b4d7bc25"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["403d05f7f8d69b65659157eff1bc1d2717f04c66","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"66e0b82bd39567aa2bf534e5282d05fb4a4a2c76":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"23ee9ee847c92f9e0395e1ff6655ec464e0a57a2":["c304e97e7c1d472bc70e801b35ee78583916c6cd","7c3523a0ab04c3002eee3896c75ea5f10f388bcc","0806aac02ecbbdc6b5d9705ae15da193219c7af4","560c18d71dad43d675158783c3840f8c80d6d39c"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["b94236357aaa22b76c10629851fe4e376e0cea82","4b342321d8906f4b19f6f87ea33ea3fff12bffa7"],"4328dbef1afa8336d38a4301a545999d1e21f8fa":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"560c18d71dad43d675158783c3840f8c80d6d39c":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}