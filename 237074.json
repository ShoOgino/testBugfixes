{"path":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b09644855fe79c27cf261552509561b8ce34c4c7","date":1312056839,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n      \n      // open a new searcher in the sync block to avoid opening it\n      // after a deleteByQuery changed the index, or in between deletes\n      // and adds of another commit being done.\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside of the synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bfd83e4021bd95c6db3a56f97db85525f1f206be","date":1312469020,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        \n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8d4043f61e1bb9e99e8008fed9a79c6478826e1","date":1312930770,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      synchronized (this) {\n        if (cmd.softCommit) {\n          core.getSearcher(true,false,waitSearcher, true);\n        } else {\n          core.getSearcher(true,false,waitSearcher);\n        }\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n      \n      if (!cmd.softCommit) {\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n      if (cmd.softCommit) {\n        core.getSearcher(true,false,waitSearcher, true);\n      } else {\n        core.getSearcher(true,false,waitSearcher);\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e","date":1313005033,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      synchronized (this) {\n        if (cmd.softCommit) {\n          core.getSearcher(true,false,waitSearcher, true);\n        } else {\n          core.getSearcher(true,false,waitSearcher);\n        }\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter();\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      synchronized (this) {\n        if (cmd.softCommit) {\n          core.getSearcher(true,false,waitSearcher, true);\n        } else {\n          core.getSearcher(true,false,waitSearcher);\n        }\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd0ef6574805f3cb9880e0983b7548a6aa933508","date":1315345052,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      synchronized (this) {\n        if (cmd.softCommit) {\n          core.getSearcher(true,false,waitSearcher, true);\n        } else {\n          core.getSearcher(true,false,waitSearcher);\n        }\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0cf25ac9828f9d484e626a18635422d10f8c9549"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98fa1aca20a29db3d3d1a867eeed78f65448febe","date":1317919012,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = indexWriterProvider.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e","date":1320267737,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        writer.commit();\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.optimize(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34ce7c842452c79b12c45a8feb64e4597c7110e8","date":1321637224,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.expungeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8524650e878177081c15c0c5bccfae2c7dca772b","date":1325284910,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      numErrors.set(error ? 1 : 0);\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384","3f87154b8e1500ff46329ab450f45c5ecb3999af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n        if (cmd.softCommit) {\n          // ulog.preSoftCommit();\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher, true);\n            ulog.postSoftCommit(cmd);\n          }\n          // ulog.postSoftCommit();\n        } else {\n          synchronized (this) {\n            ulog.preSoftCommit(cmd);\n            core.getSearcher(true,false,waitSearcher);\n            ulog.postSoftCommit(cmd);\n          }\n          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened\n        }\n\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c01638f4dd94981c1d3d52c4f7991246a5a24aba","date":1327876712,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        writer.commit();\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad31de9d3b830bc174d4c41df9f80f4cac82576","date":1328107867,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            core.openNewSearcher(true,true);\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["799dbf7b31f0667e6d3927ba742a910752688757"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9c20614afe92acf4c134c6504cf31f8f7da079d","date":1335103080,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            core.openNewSearcher(true,true);\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            core.openNewSearcher(true,true);\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"799dbf7b31f0667e6d3927ba742a910752688757","date":1335106915,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            core.openNewSearcher(true,true);\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"08bcaef9e931052e4ca24133a89cc6aefaf61829","date":1342469326,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (this) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384","3f87154b8e1500ff46329ab450f45c5ecb3999af"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (this) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c9767265f21f7d1246b13dd7e73e8a4ad88b4384","date":1342986300,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (this) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (this) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    IndexWriter writer = solrCoreState.getIndexWriter(core);\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n\n      if (cmd.optimize) {\n        writer.forceMerge(cmd.maxOptimizeSegments);\n      } else if (cmd.expungeDeletes) {\n        writer.forceMergeDeletes();\n      }\n\n      if (!cmd.softCommit) {\n        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.\n          if (ulog != null) ulog.preCommit(cmd);\n        }\n\n        // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n        final Map<String,String> commitData = new HashMap<String,String>();\n        commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY, String.valueOf(System.currentTimeMillis()));\n        writer.commit(commitData);\n        // SolrCore.verbose(\"writer.commit() end\");\n        numDocsPending.set(0);\n        callPostCommitCallbacks();\n      } else {\n        callPostSoftCommitCallbacks();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (this) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1381b91b03f7409d8d548c7070dbc615931a0f50","date":1343667369,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b47e1512544568a22b82c96169d466fae8a4b79e","date":1354519309,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.commit(commitData);\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0cf25ac9828f9d484e626a18635422d10f8c9549","date":1360344005,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        commitLock.lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        commitLock.unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"81e688bb6f5374e52abfd07d5a9d98e35ae025fa","date":1372278161,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<String,String>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<String,String>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n          final Map<String,String> commitData = new HashMap<String,String>();\n          commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n              String.valueOf(System.currentTimeMillis()));\n          writer.setCommitData(commitData);\n          writer.commit();\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<String,String>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f87154b8e1500ff46329ab450f45c5ecb3999af","date":1414003722,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        } else {\n          callPostSoftCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        // ulog.postSoftCommit();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6e1dc1bb4254226c8d7151b596cc1be40671751","date":1421876355,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException e) {\n        SolrException.log(log,e);\n      } catch (ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            final Map<String,String> commitData = new HashMap<>();\n            commitData.put(SolrIndexWriter.COMMIT_TIME_MSEC_KEY,\n                String.valueOf(System.currentTimeMillis()));\n            writer.setCommitData(commitData);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["13734b36bfd631ed6a46b961df376f679e8a3f57"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e87eadc19419fde5ec17d75c75adf9a9b32f5037","date":1455028645,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","date":1469530061,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13734b36bfd631ed6a46b961df376f679e8a3f57","date":1473743967,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.incrementAndGet();\n    } else {\n      commitCommands.incrementAndGet();\n      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.set(0);\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.set(0);\n      deleteByIdCommands.set(0);\n      deleteByQueryCommands.set(0);\n      if (error) numErrors.incrementAndGet();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e52c21eddb989aed5815d30ea4c8abf481ace8ad","date":1488795043,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.increment();\n    } else {\n      commitCommands.increment();\n      if (cmd.expungeDeletes) expungeDeleteCommands.increment();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) numErrors.increment();\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer);\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56bc8970b7a53775536a5fbc79b5715bbc9f0f7a","date":1557321220,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          if (cmd.maxOptimizeSegments == 1) {\n            log.warn(\"Starting optimize... Reading and rewriting the entire index! Use with care.\");\n          } else {\n            log.warn(\"Starting optimize... Reading and rewriting a potentially large percent of the entire index, reducing to \" + cmd.maxOptimizeSegments + \" segments\");\n          }\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          log.warn(\"Starting expungeDeletes... Reading and rewriting segments with enough deletes, potentially the entire index\");\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"482ca6c86d7073e3c19096bdc74fe0e73da4554a","date":1576010743,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a229cb50768e988c50a2106bdae3a92154f428bf","date":1576051038,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start \"+cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0dfcb99e767e8eafdede3faac6831984ac849fc","date":1589042999,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.debug(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.debug(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.debug(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.info(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.info(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.info(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    @SuppressWarnings({\"rawtypes\"})\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.debug(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.debug(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.debug(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.debug(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.debug(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.debug(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd25fa3647fa73152703b8dccb4fb5f43633de20","date":1592060458,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DirectUpdateHandler2#commit(CommitUpdateCommand).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"rawtypes\"})\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.debug(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.debug(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.debug(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void commit(CommitUpdateCommand cmd) throws IOException {\n    TestInjection.injectDirectUpdateLatch();\n    if (cmd.prepareCommit) {\n      prepareCommit(cmd);\n      return;\n    }\n\n    if (cmd.optimize) {\n      optimizeCommands.mark();\n    } else {\n      commitCommands.mark();\n      if (cmd.expungeDeletes) expungeDeleteCommands.mark();\n    }\n\n    @SuppressWarnings({\"rawtypes\"})\n    Future[] waitSearcher = null;\n    if (cmd.waitSearcher) {\n      waitSearcher = new Future[1];\n    }\n\n    boolean error=true;\n    try {\n      // only allow one hard commit to proceed at once\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().lock();\n      }\n\n      log.debug(\"start {}\", cmd);\n\n      // We must cancel pending commits *before* we actually execute the commit.\n\n      if (cmd.openSearcher) {\n        // we can cancel any pending soft commits if this commit will open a new searcher\n        softCommitTracker.cancelPendingCommit();\n      }\n      if (!cmd.softCommit && (cmd.openSearcher || !commitTracker.getOpenSearcher())) {\n        // cancel a pending hard commit if this commit is of equal or greater \"strength\"...\n        // If the autoCommit has openSearcher=true, then this commit must have openSearcher=true\n        // to cancel.\n         commitTracker.cancelPendingCommit();\n      }\n\n      RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);\n      try {\n        IndexWriter writer = iw.get();\n        if (cmd.optimize) {\n          writer.forceMerge(cmd.maxOptimizeSegments);\n        } else if (cmd.expungeDeletes) {\n          writer.forceMergeDeletes();\n        }\n        \n        if (!cmd.softCommit) {\n          synchronized (solrCoreState.getUpdateLock()) { // sync is currently needed to prevent preCommit\n                                // from being called between preSoft and\n                                // postSoft... see postSoft comments.\n            if (ulog != null) ulog.preCommit(cmd);\n          }\n          \n          // SolrCore.verbose(\"writer.commit() start writer=\",writer);\n\n          if (writer.hasUncommittedChanges()) {\n            SolrIndexWriter.setCommitData(writer, cmd.getVersion());\n            writer.commit();\n          } else {\n            log.debug(\"No uncommitted changes. Skipping IW.commit.\");\n          }\n\n          // SolrCore.verbose(\"writer.commit() end\");\n          numDocsPending.reset();\n          callPostCommitCallbacks();\n        }\n      } finally {\n        iw.decref();\n      }\n\n\n      if (cmd.optimize) {\n        callPostOptimizeCallbacks();\n      }\n\n\n      if (cmd.softCommit) {\n        // ulog.preSoftCommit();\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          core.getSearcher(true, false, waitSearcher, true);\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        callPostSoftCommitCallbacks();\n      } else {\n        synchronized (solrCoreState.getUpdateLock()) {\n          if (ulog != null) ulog.preSoftCommit(cmd);\n          if (cmd.openSearcher) {\n            core.getSearcher(true, false, waitSearcher);\n          } else {\n            // force open a new realtime searcher so realtime-get and versioning code can see the latest\n            RefCounted<SolrIndexSearcher> searchHolder = core.openNewSearcher(true, true);\n            searchHolder.decref();\n          }\n          if (ulog != null) ulog.postSoftCommit(cmd);\n        }\n        if (ulog != null) ulog.postCommit(cmd); // postCommit currently means new searcher has\n                              // also been opened\n      }\n\n      // reset commit tracking\n\n      if (cmd.softCommit) {\n        softCommitTracker.didCommit();\n      } else {\n        commitTracker.didCommit();\n      }\n      \n      log.debug(\"end_commit_flush\");\n\n      error=false;\n    }\n    finally {\n      if (!cmd.softCommit) {\n        solrCoreState.getCommitLock().unlock();\n      }\n\n      addCommands.reset();\n      deleteByIdCommands.reset();\n      deleteByQueryCommands.reset();\n      if (error) {\n        numErrors.increment();\n        numErrorsCumulative.mark();\n      }\n    }\n\n    // if we are supposed to wait for the searcher to be registered, then we should do it\n    // outside any synchronized block so that other update operations can proceed.\n    if (waitSearcher!=null && waitSearcher[0] != null) {\n       try {\n        waitSearcher[0].get();\n      } catch (InterruptedException | ExecutionException e) {\n        SolrException.log(log,e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"740d649f013f07efbeb73ca854f106c60166e7c0":["482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["0cf25ac9828f9d484e626a18635422d10f8c9549","81e688bb6f5374e52abfd07d5a9d98e35ae025fa"],"34ce7c842452c79b12c45a8feb64e4597c7110e8":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"89424def13674ea17829b41c5883c54ecc31a132":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","13734b36bfd631ed6a46b961df376f679e8a3f57"],"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e":["98fa1aca20a29db3d3d1a867eeed78f65448febe"],"a229cb50768e988c50a2106bdae3a92154f428bf":["56bc8970b7a53775536a5fbc79b5715bbc9f0f7a","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"aba371508186796cc6151d8223a5b4e16d02e26e":["799dbf7b31f0667e6d3927ba742a910752688757","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"be320990bdc77e643388fa801e75017f19289c42":["e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e52c21eddb989aed5815d30ea4c8abf481ace8ad","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"13734b36bfd631ed6a46b961df376f679e8a3f57":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"81e688bb6f5374e52abfd07d5a9d98e35ae025fa":["0cf25ac9828f9d484e626a18635422d10f8c9549"],"d8d4043f61e1bb9e99e8008fed9a79c6478826e1":["bfd83e4021bd95c6db3a56f97db85525f1f206be"],"bfd83e4021bd95c6db3a56f97db85525f1f206be":["b09644855fe79c27cf261552509561b8ce34c4c7"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["8524650e878177081c15c0c5bccfae2c7dca772b","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"799dbf7b31f0667e6d3927ba742a910752688757":["b9c20614afe92acf4c134c6504cf31f8f7da079d"],"3f87154b8e1500ff46329ab450f45c5ecb3999af":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["0e8cb6e9df9d6fc873383924f02d9aacfffebf4e"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["799dbf7b31f0667e6d3927ba742a910752688757","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","1381b91b03f7409d8d548c7070dbc615931a0f50"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"b0dfcb99e767e8eafdede3faac6831984ac849fc":["740d649f013f07efbeb73ca854f106c60166e7c0"],"56bc8970b7a53775536a5fbc79b5715bbc9f0f7a":["be320990bdc77e643388fa801e75017f19289c42"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"8524650e878177081c15c0c5bccfae2c7dca772b":["34ce7c842452c79b12c45a8feb64e4597c7110e8"],"98fa1aca20a29db3d3d1a867eeed78f65448febe":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["8524650e878177081c15c0c5bccfae2c7dca772b","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","89424def13674ea17829b41c5883c54ecc31a132"],"0cf25ac9828f9d484e626a18635422d10f8c9549":["b47e1512544568a22b82c96169d466fae8a4b79e"],"5b6fdfce35d0adb18836cf8711abe487a934df33":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"c6e1dc1bb4254226c8d7151b596cc1be40671751":["3f87154b8e1500ff46329ab450f45c5ecb3999af"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["81e688bb6f5374e52abfd07d5a9d98e35ae025fa"],"b09644855fe79c27cf261552509561b8ce34c4c7":["c26f00b574427b55127e869b935845554afde1fa"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["56bc8970b7a53775536a5fbc79b5715bbc9f0f7a"],"b9c20614afe92acf4c134c6504cf31f8f7da079d":["0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"407687e67faf6e1f02a211ca078d8e3eed631027":["1381b91b03f7409d8d548c7070dbc615931a0f50","b47e1512544568a22b82c96169d466fae8a4b79e"],"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e":["d8d4043f61e1bb9e99e8008fed9a79c6478826e1"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["e87eadc19419fde5ec17d75c75adf9a9b32f5037"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["e87eadc19419fde5ec17d75c75adf9a9b32f5037","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["0d22ac6a4146774c1bc8400160fc0b6150294e92","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"e87eadc19419fde5ec17d75c75adf9a9b32f5037":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","1381b91b03f7409d8d548c7070dbc615931a0f50"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["8524650e878177081c15c0c5bccfae2c7dca772b"],"b47e1512544568a22b82c96169d466fae8a4b79e":["1381b91b03f7409d8d548c7070dbc615931a0f50"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e52c21eddb989aed5815d30ea4c8abf481ace8ad":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["799dbf7b31f0667e6d3927ba742a910752688757"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["08bcaef9e931052e4ca24133a89cc6aefaf61829"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["e87eadc19419fde5ec17d75c75adf9a9b32f5037","bc0fbfa191179ae7a0081ee1cf7da0464bcd8078"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bd25fa3647fa73152703b8dccb4fb5f43633de20"]},"commit2Childs":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["bd25fa3647fa73152703b8dccb4fb5f43633de20"],"740d649f013f07efbeb73ca854f106c60166e7c0":["b0dfcb99e767e8eafdede3faac6831984ac849fc"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"34ce7c842452c79b12c45a8feb64e4597c7110e8":["8524650e878177081c15c0c5bccfae2c7dca772b"],"89424def13674ea17829b41c5883c54ecc31a132":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"a229cb50768e988c50a2106bdae3a92154f428bf":[],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"be320990bdc77e643388fa801e75017f19289c42":["56bc8970b7a53775536a5fbc79b5715bbc9f0f7a"],"ab68488225b6a6c357dda72ed11dedca9914a192":[],"13734b36bfd631ed6a46b961df376f679e8a3f57":["89424def13674ea17829b41c5883c54ecc31a132"],"81e688bb6f5374e52abfd07d5a9d98e35ae025fa":["37a0f60745e53927c4c876cfe5b5a58170f0646c","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"d8d4043f61e1bb9e99e8008fed9a79c6478826e1":["0e8cb6e9df9d6fc873383924f02d9aacfffebf4e"],"bfd83e4021bd95c6db3a56f97db85525f1f206be":["d8d4043f61e1bb9e99e8008fed9a79c6478826e1"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["5b6fdfce35d0adb18836cf8711abe487a934df33"],"799dbf7b31f0667e6d3927ba742a910752688757":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","08bcaef9e931052e4ca24133a89cc6aefaf61829"],"1381b91b03f7409d8d548c7070dbc615931a0f50":["d6f074e73200c07d54f242d3880a8da5a35ff97b","407687e67faf6e1f02a211ca078d8e3eed631027","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","b47e1512544568a22b82c96169d466fae8a4b79e"],"3f87154b8e1500ff46329ab450f45c5ecb3999af":["c6e1dc1bb4254226c8d7151b596cc1be40671751"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"bd0ef6574805f3cb9880e0983b7548a6aa933508":["98fa1aca20a29db3d3d1a867eeed78f65448febe"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["e87eadc19419fde5ec17d75c75adf9a9b32f5037"],"b0dfcb99e767e8eafdede3faac6831984ac849fc":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"56bc8970b7a53775536a5fbc79b5715bbc9f0f7a":["a229cb50768e988c50a2106bdae3a92154f428bf","482ca6c86d7073e3c19096bdc74fe0e73da4554a"],"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["5b6fdfce35d0adb18836cf8711abe487a934df33","817882884229bace7dc5d1b75f6b0e4aa1e47122","0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"c26f00b574427b55127e869b935845554afde1fa":["b09644855fe79c27cf261552509561b8ce34c4c7"],"98fa1aca20a29db3d3d1a867eeed78f65448febe":["7a3554ff15950ad0e3bcbb4e4e2ddb45b0b0f27e"],"8524650e878177081c15c0c5bccfae2c7dca772b":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["34ce7c842452c79b12c45a8feb64e4597c7110e8"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["817882884229bace7dc5d1b75f6b0e4aa1e47122"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e52c21eddb989aed5815d30ea4c8abf481ace8ad"],"0cf25ac9828f9d484e626a18635422d10f8c9549":["37a0f60745e53927c4c876cfe5b5a58170f0646c","81e688bb6f5374e52abfd07d5a9d98e35ae025fa"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"bd25fa3647fa73152703b8dccb4fb5f43633de20":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b09644855fe79c27cf261552509561b8ce34c4c7":["bfd83e4021bd95c6db3a56f97db85525f1f206be"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["3f87154b8e1500ff46329ab450f45c5ecb3999af"],"c6e1dc1bb4254226c8d7151b596cc1be40671751":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"482ca6c86d7073e3c19096bdc74fe0e73da4554a":["740d649f013f07efbeb73ca854f106c60166e7c0","a229cb50768e988c50a2106bdae3a92154f428bf"],"b9c20614afe92acf4c134c6504cf31f8f7da079d":["799dbf7b31f0667e6d3927ba742a910752688757"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"0e8cb6e9df9d6fc873383924f02d9aacfffebf4e":["bd0ef6574805f3cb9880e0983b7548a6aa933508"],"bc0fbfa191179ae7a0081ee1cf7da0464bcd8078":["89424def13674ea17829b41c5883c54ecc31a132","13734b36bfd631ed6a46b961df376f679e8a3f57","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["b9c20614afe92acf4c134c6504cf31f8f7da079d"],"e87eadc19419fde5ec17d75c75adf9a9b32f5037":["bc0fbfa191179ae7a0081ee1cf7da0464bcd8078","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","c01638f4dd94981c1d3d52c4f7991246a5a24aba","0d22ac6a4146774c1bc8400160fc0b6150294e92"],"b47e1512544568a22b82c96169d466fae8a4b79e":["0cf25ac9828f9d484e626a18635422d10f8c9549","407687e67faf6e1f02a211ca078d8e3eed631027"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"e52c21eddb989aed5815d30ea4c8abf481ace8ad":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"08bcaef9e931052e4ca24133a89cc6aefaf61829":["fe33227f6805edab2036cbb80645cc4e2d1fa424","c9767265f21f7d1246b13dd7e73e8a4ad88b4384"],"c9767265f21f7d1246b13dd7e73e8a4ad88b4384":["aba371508186796cc6151d8223a5b4e16d02e26e","1381b91b03f7409d8d548c7070dbc615931a0f50","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a229cb50768e988c50a2106bdae3a92154f428bf","ab68488225b6a6c357dda72ed11dedca9914a192","d6f074e73200c07d54f242d3880a8da5a35ff97b","5b6fdfce35d0adb18836cf8711abe487a934df33","407687e67faf6e1f02a211ca078d8e3eed631027","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","817882884229bace7dc5d1b75f6b0e4aa1e47122","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","a258fbb26824fd104ed795e5d9033d2d040049ee","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}