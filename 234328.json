{"path":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","commits":[{"id":"fcf710a8fcd590cf55c855d422c7a10fce3e6117","date":1485842253,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"/dev/null","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3523a0ab04c3002eee3896c75ea5f10f388bcc","date":1485968422,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"/dev/null","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b989cb26c9ed789ced31e1d784d08cf539269a09","date":1487118246,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"897b06b1364bd1f658a8be7591e43f0851458e7f","date":1487123008,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"624045c71f6ae24ee5b8ad5aaaae433e98fcf074","date":1487123232,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ab788212d72a7c436e5ef349ca99fe3c8fc78b","date":1489203052,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(3);//strip off '/v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5174b677b2536f97776e6b67e8c10ae5c66e6fa2","date":1496916595,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af6e3b131b22b455c53cd15b9345442651eeba30","date":1497238365,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a37f42fd3acf60bcf683cbfad43433f1c259ef7","date":1497239198,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556","date":1497937593,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0) {\n        prefix = \"c\";\n        path = \"/c\";\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(ApiBag.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(ApiBag.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PASSTHROUGH;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8d39fcd7f71f88fccadc3742f62b1f7fe4f983b2","date":1500670021,"type":3,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"936cdd5882761db3b844afd6f84ab81cbb011a75","date":1500973524,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a52341299179de5479672f7cf518bf4b173f34b3","date":1501079746,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://cwiki.apache.org/confluence/display/solr/v2+API\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, origCorename));\n        String collectionName = collectionsList.get(0); // first\n        //TODO try the other collections if can't find a local replica of the first?\n\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(collectionName, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        String collectionName = origCorename = corename = pieces.get(1);\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n           if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = false;\n          if (path.endsWith(\"/update\") || path.contains(\"/update/\")) {\n            isPreferLeader = true;\n          }\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(corename, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = corename = pieces.get(1);\n        core = cores.getCore(corename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + corename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      if (usingAliases) {\n        processAliases(aliases, collectionsList);\n      }\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9125399a2b1542e8303716ed9020cb6cd4a7aa93","date":1510160069,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, origCorename));\n        String collectionName = collectionsList.get(0); // first\n        //TODO try the other collections if can't find a local replica of the first?\n\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              this.path = path = path.substring(prefix.length() + origCorename.length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, origCorename));\n        String collectionName = collectionsList.get(0); // first\n        //TODO try the other collections if can't find a local replica of the first?\n\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            //todo find a better way to compute remote\n            extractRemotePath(collectionName, origCorename, 0);\n            return;\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":["2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556","fcf710a8fcd590cf55c855d422c7a10fce3e6117","6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e81b6aab54e3749e1502c221e0bc9dbd3f91e15","date":1525806607,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), origCorename);\n            if (action == REMOTEQUERY) {\n              this.path = path = path.substring(prefix.length() + origCorename.length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        collectionsList = resolveCollectionListOrAlias(queryParams.get(COLLECTION_PROP, origCorename));\n        String collectionName = collectionsList.get(0); // first\n        //TODO try the other collections if can't find a local replica of the first?\n\n        DocCollection collection = getDocCollection(collectionName);\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collectionName, origCorename);\n            if (action == REMOTEQUERY) {\n              this.path = path = path.substring(prefix.length() + origCorename.length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06162402a4b5a56531e9bd52e5e05f51b86ccfea","date":1540518645,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), origCorename);\n            if (action == REMOTEQUERY) {\n              this.path = path = path.substring(prefix.length() + origCorename.length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      MDCLoggingContext.setCore(core);\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '{}'\", path);\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '\" + path + \"'\");\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"650b520f2a4daa4b0712e2393dc29ae7f21f10ac","date":1593054531,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","pathOld":"solr/core/src/java/org/apache/solr/api/V2HttpCall#init().mjava","sourceNew":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      } else {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if(api != null) {\n          //custom plugin\n          initAdminRequest(path);\n          return;\n        }\n      }\n      if (core == null) {\n        log.error(\">> path: '{}'\", path);\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","sourceOld":"  protected void init() throws Exception {\n    String path = this.path;\n    final String fullPath = path = path.substring(7);//strip off '/____v2'\n    try {\n      pieces = getPathSegments(path);\n      if (pieces.size() == 0 || (pieces.size() == 1 && path.endsWith(CommonParams.INTROSPECT))) {\n        api = new Api(null) {\n          @Override\n          public void call(SolrQueryRequest req, SolrQueryResponse rsp) {\n            rsp.add(\"documentation\", \"https://lucene.apache.org/solr/guide/v2-api.html\");\n            rsp.add(\"description\", \"V2 API root path\");\n          }\n        };\n        initAdminRequest(path);\n        return;\n      } else {\n        prefix = pieces.get(0);\n      }\n\n      boolean isCompositeApi = false;\n      if (knownPrefixes.contains(prefix)) {\n        api = getApiInfo(cores.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n        if (api != null) {\n          isCompositeApi = api instanceof CompositeApi;\n          if (!isCompositeApi) {\n            initAdminRequest(path);\n            return;\n          }\n        }\n      }\n\n      if (\"c\".equals(prefix) || \"collections\".equals(prefix)) {\n        origCorename = pieces.get(1);\n\n        DocCollection collection = resolveDocCollection(queryParams.get(COLLECTION_PROP, origCorename));\n\n        if (collection == null) {\n          if ( ! path.endsWith(CommonParams.INTROSPECT)) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"no such collection or alias\");\n          }\n        } else {\n          boolean isPreferLeader = (path.endsWith(\"/update\") || path.contains(\"/update/\"));\n          core = getCoreByCollection(collection.getName(), isPreferLeader);\n          if (core == null) {\n            //this collection exists , but this node does not have a replica for that collection\n            extractRemotePath(collection.getName(), collection.getName());\n            if (action == REMOTEQUERY) {\n              coreUrl = coreUrl.replace(\"/solr/\", \"/solr/____v2/c/\");\n              this.path = path = path.substring(prefix.length() + collection.getName().length() + 2);\n              return;\n            }\n          }\n        }\n      } else if (\"cores\".equals(prefix)) {\n        origCorename = pieces.get(1);\n        core = cores.getCore(origCorename);\n      }\n      if (core == null) {\n        log.error(\">> path: '{}'\", path);\n        if (path.endsWith(CommonParams.INTROSPECT)) {\n          initAdminRequest(path);\n          return;\n        } else {\n          throw new SolrException(SolrException.ErrorCode.NOT_FOUND, \"no core retrieved for \" + origCorename);\n        }\n      }\n\n      this.path = path = path.substring(prefix.length() + pieces.get(1).length() + 2);\n      Api apiInfo = getApiInfo(core.getRequestHandlers(), path, req.getMethod(), fullPath, parts);\n      if (isCompositeApi && apiInfo instanceof CompositeApi) {\n        ((CompositeApi) this.api).add(apiInfo);\n      } else {\n        api = apiInfo == null ? api : apiInfo;\n      }\n      parseRequest();\n\n      addCollectionParamIfNeeded(getCollectionsList());\n\n      action = PROCESS;\n      // we are done with a valid handler\n    } catch (RuntimeException rte) {\n      log.error(\"Error in init()\", rte);\n      throw rte;\n    } finally {\n      if (action == null && api == null) action = PROCESS;\n      if (solrReq != null) solrReq.getContext().put(CommonParams.PATH, path);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"06162402a4b5a56531e9bd52e5e05f51b86ccfea":["8e81b6aab54e3749e1502c221e0bc9dbd3f91e15"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["a52341299179de5479672f7cf518bf4b173f34b3"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["b989cb26c9ed789ced31e1d784d08cf539269a09"],"b989cb26c9ed789ced31e1d784d08cf539269a09":["fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"624045c71f6ae24ee5b8ad5aaaae433e98fcf074":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","fcf710a8fcd590cf55c855d422c7a10fce3e6117"],"ed5005b977107bba28c700351216f1595e7abe4f":["06162402a4b5a56531e9bd52e5e05f51b86ccfea"],"936cdd5882761db3b844afd6f84ab81cbb011a75":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","8d39fcd7f71f88fccadc3742f62b1f7fe4f983b2"],"2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556":["2a37f42fd3acf60bcf683cbfad43433f1c259ef7"],"9125399a2b1542e8303716ed9020cb6cd4a7aa93":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"28288370235ed02234a64753cdbf0c6ec096304a":["a8ab788212d72a7c436e5ef349ca99fe3c8fc78b","2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556"],"af6e3b131b22b455c53cd15b9345442651eeba30":["5174b677b2536f97776e6b67e8c10ae5c66e6fa2"],"a52341299179de5479672f7cf518bf4b173f34b3":["28288370235ed02234a64753cdbf0c6ec096304a","8d39fcd7f71f88fccadc3742f62b1f7fe4f983b2"],"8e81b6aab54e3749e1502c221e0bc9dbd3f91e15":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"8d39fcd7f71f88fccadc3742f62b1f7fe4f983b2":["28288370235ed02234a64753cdbf0c6ec096304a"],"a8ab788212d72a7c436e5ef349ca99fe3c8fc78b":["624045c71f6ae24ee5b8ad5aaaae433e98fcf074"],"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["140be51d03394488536f4aacedace29f9b318347"],"140be51d03394488536f4aacedace29f9b318347":["ed5005b977107bba28c700351216f1595e7abe4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2a37f42fd3acf60bcf683cbfad43433f1c259ef7":["af6e3b131b22b455c53cd15b9345442651eeba30"],"5174b677b2536f97776e6b67e8c10ae5c66e6fa2":["a8ab788212d72a7c436e5ef349ca99fe3c8fc78b"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a8ab788212d72a7c436e5ef349ca99fe3c8fc78b","2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"]},"commit2Childs":{"06162402a4b5a56531e9bd52e5e05f51b86ccfea":["ed5005b977107bba28c700351216f1595e7abe4f"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["9125399a2b1542e8303716ed9020cb6cd4a7aa93"],"897b06b1364bd1f658a8be7591e43f0851458e7f":["624045c71f6ae24ee5b8ad5aaaae433e98fcf074"],"b989cb26c9ed789ced31e1d784d08cf539269a09":["897b06b1364bd1f658a8be7591e43f0851458e7f"],"624045c71f6ae24ee5b8ad5aaaae433e98fcf074":["a8ab788212d72a7c436e5ef349ca99fe3c8fc78b"],"fcf710a8fcd590cf55c855d422c7a10fce3e6117":["b989cb26c9ed789ced31e1d784d08cf539269a09","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"7c3523a0ab04c3002eee3896c75ea5f10f388bcc":[],"ed5005b977107bba28c700351216f1595e7abe4f":["140be51d03394488536f4aacedace29f9b318347"],"936cdd5882761db3b844afd6f84ab81cbb011a75":[],"2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"9125399a2b1542e8303716ed9020cb6cd4a7aa93":["8e81b6aab54e3749e1502c221e0bc9dbd3f91e15"],"28288370235ed02234a64753cdbf0c6ec096304a":["a52341299179de5479672f7cf518bf4b173f34b3","8d39fcd7f71f88fccadc3742f62b1f7fe4f983b2"],"af6e3b131b22b455c53cd15b9345442651eeba30":["2a37f42fd3acf60bcf683cbfad43433f1c259ef7"],"a52341299179de5479672f7cf518bf4b173f34b3":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"8e81b6aab54e3749e1502c221e0bc9dbd3f91e15":["06162402a4b5a56531e9bd52e5e05f51b86ccfea"],"8d39fcd7f71f88fccadc3742f62b1f7fe4f983b2":["936cdd5882761db3b844afd6f84ab81cbb011a75","a52341299179de5479672f7cf518bf4b173f34b3"],"a8ab788212d72a7c436e5ef349ca99fe3c8fc78b":["28288370235ed02234a64753cdbf0c6ec096304a","5174b677b2536f97776e6b67e8c10ae5c66e6fa2","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fcf710a8fcd590cf55c855d422c7a10fce3e6117","7c3523a0ab04c3002eee3896c75ea5f10f388bcc"],"650b520f2a4daa4b0712e2393dc29ae7f21f10ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"140be51d03394488536f4aacedace29f9b318347":["650b520f2a4daa4b0712e2393dc29ae7f21f10ac"],"2a37f42fd3acf60bcf683cbfad43433f1c259ef7":["2479a9c66c0c9b8a0ab8e314f035cd9e8e75d556"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["936cdd5882761db3b844afd6f84ab81cbb011a75"],"5174b677b2536f97776e6b67e8c10ae5c66e6fa2":["af6e3b131b22b455c53cd15b9345442651eeba30"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c3523a0ab04c3002eee3896c75ea5f10f388bcc","936cdd5882761db3b844afd6f84ab81cbb011a75","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}