{"path":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c518d12136e15c9de6fa3d2c4bf5add07311a685","date":1313718511,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount.incrementAndGet();\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit.get() > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount++;\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4b0203706833d89696e68ebfc15ecdc12ff58acd"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b0203706833d89696e68ebfc15ecdc12ff58acd","date":1315510060,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public synchronized void run() {\n    long started = System.currentTimeMillis();\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n      core.getUpdateHandler().commit(command);\n      autoCommitCount.incrementAndGet();\n    } catch (Exception e) {\n      log.error(\"auto commit error...\");\n      e.printStackTrace();\n    } finally {\n      pending = null;\n      req.close();\n    }\n    \n    // check if docs have been submitted since the commit started\n    if (lastAddedTime > started) {\n      if (docsUpperBound > 0 && docsSinceCommit.get() > docsUpperBound) {\n        pending = scheduler.schedule(this, 100, TimeUnit.MILLISECONDS);\n      } else if (timeUpperBound > 0) {\n        pending = scheduler.schedule(this, timeUpperBound,\n            TimeUnit.MILLISECONDS);\n      }\n    }\n  }\n\n","bugFix":["7a71a0b2d4be2299a163f60626729852d81a8e02","c518d12136e15c9de6fa3d2c4bf5add07311a685"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad31de9d3b830bc174d4c41df9f80f4cac82576","date":1328107867,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5de502b5478255493125e7e801411ba17a6682ec","date":1490974101,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = WAIT_SEARCHER;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f20fd35e3055a0c5b387df0b986a68d65d86441","date":1491045405,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = WAIT_SEARCHER;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = waitSearcher;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b1c3da93fb6b925181d6873b7c004f025e826d0","date":1589417887,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CommitTracker#run().mjava","sourceNew":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    MDCLoggingContext.setCore(core);\n    try (SolrQueryRequest req = new LocalSolrQueryRequest(core, new ModifiableSolrParams())) {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = WAIT_SEARCHER;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      MDCLoggingContext.clear();\n    }\n    // log.info(\"###done committing\");\n  }\n\n","sourceOld":"  /** This is the worker part for the ScheduledFuture **/\n  @Override\n  public void run() {\n    synchronized (this) {\n      // log.info(\"###start commit. pending=null\");\n      pending = null;  // allow a new commit to be scheduled\n    }\n\n    SolrQueryRequest req = new LocalSolrQueryRequest(core,\n        new ModifiableSolrParams());\n    try {\n      CommitUpdateCommand command = new CommitUpdateCommand(req, false);\n      command.openSearcher = openSearcher;\n      command.waitSearcher = WAIT_SEARCHER;\n      command.softCommit = softCommit;\n      if (core.getCoreDescriptor().getCloudDescriptor() != null\n          && core.getCoreDescriptor().getCloudDescriptor().isLeader()\n          && !softCommit) {\n        command.version = core.getUpdateHandler().getUpdateLog().getVersionInfo().getNewClock();\n      }\n      // no need for command.maxOptimizeSegments = 1; since it is not optimizing\n\n      // we increment this *before* calling commit because it was causing a race\n      // in the tests (the new searcher was registered and the test proceeded\n      // to check the commit count before we had incremented it.)\n      autoCommitCount.incrementAndGet();\n\n      core.getUpdateHandler().commit(command);\n    } catch (Exception e) {\n      SolrException.log(log, \"auto commit error...\", e);\n    } finally {\n      // log.info(\"###done committing\");\n      req.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["0ad31de9d3b830bc174d4c41df9f80f4cac82576","7530de27b87b961b51f01bd1299b7004d46e8823"],"5de502b5478255493125e7e801411ba17a6682ec":["be320990bdc77e643388fa801e75017f19289c42"],"4b0203706833d89696e68ebfc15ecdc12ff58acd":["c518d12136e15c9de6fa3d2c4bf5add07311a685"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":["ab68488225b6a6c357dda72ed11dedca9914a192"],"6b1c3da93fb6b925181d6873b7c004f025e826d0":["5de502b5478255493125e7e801411ba17a6682ec"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["7530de27b87b961b51f01bd1299b7004d46e8823"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["4b0203706833d89696e68ebfc15ecdc12ff58acd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c518d12136e15c9de6fa3d2c4bf5add07311a685":["c26f00b574427b55127e869b935845554afde1fa"],"be320990bdc77e643388fa801e75017f19289c42":["7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"ab68488225b6a6c357dda72ed11dedca9914a192":["7530de27b87b961b51f01bd1299b7004d46e8823","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6b1c3da93fb6b925181d6873b7c004f025e826d0"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"5de502b5478255493125e7e801411ba17a6682ec":["6b1c3da93fb6b925181d6873b7c004f025e826d0"],"4b0203706833d89696e68ebfc15ecdc12ff58acd":["0ad31de9d3b830bc174d4c41df9f80f4cac82576"],"c26f00b574427b55127e869b935845554afde1fa":["c518d12136e15c9de6fa3d2c4bf5add07311a685"],"6f20fd35e3055a0c5b387df0b986a68d65d86441":[],"6b1c3da93fb6b925181d6873b7c004f025e826d0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"0ad31de9d3b830bc174d4c41df9f80f4cac82576":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"c518d12136e15c9de6fa3d2c4bf5add07311a685":["4b0203706833d89696e68ebfc15ecdc12ff58acd"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","f996f8177b9204bdc92f7164460c6cefad9ac99a","be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192"],"be320990bdc77e643388fa801e75017f19289c42":["5de502b5478255493125e7e801411ba17a6682ec"],"ab68488225b6a6c357dda72ed11dedca9914a192":["6f20fd35e3055a0c5b387df0b986a68d65d86441"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","6f20fd35e3055a0c5b387df0b986a68d65d86441","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}