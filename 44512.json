{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState, cloudConfig,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\"})\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode is a required param\");\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (target != null && !clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n    try {\n      for (ZkNodeProps sourceReplica : sourceReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList nl = new NamedList();\n        String sourceCollection = sourceReplica.getStr(COLLECTION_PROP);\n        if (log.isInfoEnabled()) {\n          log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n        }\n        String targetNode = target;\n        if (targetNode == null) {\n          Replica.Type replicaType = Replica.Type.get(sourceReplica.getStr(ZkStateReader.REPLICA_TYPE));\n          int numNrtReplicas = replicaType == Replica.Type.NRT ? 1 : 0;\n          int numTlogReplicas = replicaType == Replica.Type.TLOG ? 1 : 0;\n          int numPullReplicas = replicaType == Replica.Type.PULL ? 1 : 0;\n          Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()\n              .forCollection(sourceCollection)\n              .forShard(Collections.singletonList(sourceReplica.getStr(SHARD_ID_PROP)))\n              .assignNrtReplicas(numNrtReplicas)\n              .assignTlogReplicas(numTlogReplicas)\n              .assignPullReplicas(numPullReplicas)\n              .onNodes(new ArrayList<>(ocmh.cloudManager.getClusterStateProvider().getLiveNodes()))\n              .build();\n          Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(ocmh.cloudManager);\n          Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(clusterState, cloudConfig, clusterState.getCollection(sourceCollection));\n          targetNode = assignStrategy.assign(ocmh.cloudManager, assignRequest).get(0).node;\n        }\n        ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, targetNode);\n        if (async != null) msg.getProperties().put(ASYNC, async);\n        final ZkNodeProps addedReplica = ocmh.addReplica(clusterState, cloudConfig,\n            msg, nl, () -> {\n              countDownLatch.countDown();\n              if (nl.get(\"failure\") != null) {\n                String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                    \" on node=%s\", sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                log.warn(errorString);\n                // one replica creation failed. Make the best attempt to\n                // delete all the replicas created so far in the target\n                // and exit\n                synchronized (results) {\n                  results.add(\"failure\", errorString);\n                  anyOneFailed.set(true);\n                }\n              } else {\n                if (log.isDebugEnabled()) {\n                  log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                      sourceCollection, sourceReplica.getStr(SHARD_ID_PROP), target);\n                }\n              }\n            }).get(0);\n\n        if (addedReplica != null) {\n          createdReplicas.add(addedReplica);\n          if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n            String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n            String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n            String collectionName = sourceCollection;\n            String key = collectionName + \"_\" + replicaName;\n            CollectionStateWatcher watcher;\n            if (waitForFinalState) {\n              watcher = new ActiveReplicaWatcher(collectionName, null,\n                  Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n            } else {\n              watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                  addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n            }\n            watchers.put(key, watcher);\n            log.debug(\"--- adding {}, {}\", key, watcher);\n            zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n          } else {\n            log.debug(\"--- not waiting for {}\", addedReplica);\n          }\n        }\n      }\n\n      log.debug(\"Waiting for replicas to be added\");\n      if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n        log.info(\"Timed out waiting for replicas to be added\");\n        anyOneFailed.set(true);\n      } else {\n        log.debug(\"Finished waiting for replicas to be added\");\n      }\n    } finally {\n    }\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for {} leader replicas to recover\", numLeaders);\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      if (log.isInfoEnabled()) {\n        log.info(\"Timed out waiting for {} leader replicas to recover\", replicasToRecover.getCount());\n      }\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        @SuppressWarnings({\"rawtypes\"})\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}