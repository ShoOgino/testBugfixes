{"path":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","commits":[{"id":"f653aecb322b74d99e6ecdb93765e453a3d7aa71","date":1082107025,"type":0,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"/dev/null","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return new SegmentReader(infos, infos.info(0), closeDirectory);\n            } else {\n              IndexReader[] readers = new IndexReader[infos.size()];\n              for (int i = 0; i < infos.size(); i++)\n                readers[i] = new SegmentReader(infos.info(i));\n              return new MultiReader(directory, infos, closeDirectory, readers);\n            }\n          }\n        }.run();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e5d88b55f1b57feab6da94a5c635a224539bd2a","date":1095877947,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return SegmentReader.get(infos, infos.info(0), closeDirectory);\n            } else {\n              IndexReader[] readers = new IndexReader[infos.size()];\n              for (int i = 0; i < infos.size(); i++)\n                readers[i] = SegmentReader.get(infos.info(i));\n              return new MultiReader(directory, infos, closeDirectory, readers);\n            }\n          }\n        }.run();\n    }\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return new SegmentReader(infos, infos.info(0), closeDirectory);\n            } else {\n              IndexReader[] readers = new IndexReader[infos.size()];\n              for (int i = 0; i < infos.size(); i++)\n                readers[i] = new SegmentReader(infos.info(i));\n              return new MultiReader(directory, infos, closeDirectory, readers);\n            }\n          }\n        }.run();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c687c6cd32bfdceab8fd653a483592265774d97","date":1104356145,"type":3,"author":"Bernhard Messer","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return SegmentReader.get(infos, infos.info(0), closeDirectory);\n            }\n            IndexReader[] readers = new IndexReader[infos.size()];\n            for (int i = 0; i < infos.size(); i++)\n              readers[i] = SegmentReader.get(infos.info(i));\n            return new MultiReader(directory, infos, closeDirectory, readers);\n            \n          }\n        }.run();\n    }\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return SegmentReader.get(infos, infos.info(0), closeDirectory);\n            } else {\n              IndexReader[] readers = new IndexReader[infos.size()];\n              for (int i = 0; i < infos.size(); i++)\n                readers[i] = SegmentReader.get(infos.info(i));\n              return new MultiReader(directory, infos, closeDirectory, readers);\n            }\n          }\n        }.run();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12d40284fd9481f79444bc63bc5d13847caddd3d","date":1149902602,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return SegmentReader.get(infos, infos.info(0), closeDirectory);\n            }\n            IndexReader[] readers = new IndexReader[infos.size()];\n            for (int i = 0; i < infos.size(); i++)\n              readers[i] = SegmentReader.get(infos.info(i));\n            return new MultiReader(directory, infos, closeDirectory, readers);\n\n          }\n        }.run();\n    }\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return SegmentReader.get(infos, infos.info(0), closeDirectory);\n            }\n            IndexReader[] readers = new IndexReader[infos.size()];\n            for (int i = 0; i < infos.size(); i++)\n              readers[i] = SegmentReader.get(infos.info(i));\n            return new MultiReader(directory, infos, closeDirectory, readers);\n            \n          }\n        }.run();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      public Object doBody(String segmentFileName) throws IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          return SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          return new MultiReader(directory, infos, closeDirectory, readers);\n        }\n      }\n    }.run();\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n    synchronized (directory) {\t\t\t  // in- & inter-process sync\n      return (IndexReader)new Lock.With(\n          directory.makeLock(IndexWriter.COMMIT_LOCK_NAME),\n          IndexWriter.COMMIT_LOCK_TIMEOUT) {\n          public Object doBody() throws IOException {\n            SegmentInfos infos = new SegmentInfos();\n            infos.read(directory);\n            if (infos.size() == 1) {\t\t  // index is optimized\n              return SegmentReader.get(infos, infos.info(0), closeDirectory);\n            }\n            IndexReader[] readers = new IndexReader[infos.size()];\n            for (int i = 0; i < infos.size(); i++)\n              readers[i] = SegmentReader.get(infos.info(i));\n            return new MultiReader(directory, infos, closeDirectory, readers);\n\n          }\n        }.run();\n    }\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws CorruptIndexException, IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      public Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          return SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          return new MultiReader(directory, infos, closeDirectory, readers);\n        }\n      }\n    }.run();\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      public Object doBody(String segmentFileName) throws IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          return SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          return new MultiReader(directory, infos, closeDirectory, readers);\n        }\n      }\n    }.run();\n  }\n\n","bugFix":["f653aecb322b74d99e6ecdb93765e453a3d7aa71","284c1d3c8b19931bf6f312fae7470487f5d9e580"],"bugIntro":["a8a6f0cea0d6b50602e9b67dbf17eb1fb8ecf14a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8a6f0cea0d6b50602e9b67dbf17eb1fb8ecf14a","date":1172364225,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws CorruptIndexException, IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          return SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          return new MultiReader(directory, infos, closeDirectory, readers);\n        }\n      }\n    }.run();\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws CorruptIndexException, IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      public Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          return SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          return new MultiReader(directory, infos, closeDirectory, readers);\n        }\n      }\n    }.run();\n  }\n\n","bugFix":["1b54a9bc667895a2095a886184bf69a3179e63df"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean,IndexDeletionPolicy).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  private static IndexReader open(final Directory directory, final boolean closeDirectory, final IndexDeletionPolicy deletionPolicy) throws CorruptIndexException, IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        IndexReader reader;\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          reader = SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          reader = new MultiReader(directory, infos, closeDirectory, readers);\n        }\n        reader.deletionPolicy = deletionPolicy;\n        return reader;\n      }\n    }.run();\n  }\n\n","sourceOld":"  private static IndexReader open(final Directory directory, final boolean closeDirectory) throws CorruptIndexException, IOException {\n\n    return (IndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        if (infos.size() == 1) {\t\t  // index is optimized\n          return SegmentReader.get(infos, infos.info(0), closeDirectory);\n        } else {\n\n          // To reduce the chance of hitting FileNotFound\n          // (and having to retry), we open segments in\n          // reverse because IndexWriter merges & deletes\n          // the newest segments first.\n\n          IndexReader[] readers = new IndexReader[infos.size()];\n          for (int i = infos.size()-1; i >= 0; i--) {\n            try {\n              readers[i] = SegmentReader.get(infos.info(i));\n            } catch (IOException e) {\n              // Close all readers we had opened:\n              for(i++;i<infos.size();i++) {\n                readers[i].close();\n              }\n              throw e;\n            }\n          }\n\n          return new MultiReader(directory, infos, closeDirectory, readers);\n        }\n      }\n    }.run();\n  }\n\n","bugFix":null,"bugIntro":["f7f2552b9f13037c62acd400d263d1e9262d6e4e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5712975970a595c28f1988efd007e1b8a617a92f","date":1219499238,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Returns a read/write or read only IndexReader reading the index in the given Directory.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, false, null, null, readOnly);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0dabcca520e81aeff96f5c937b7ffb5617ee69d1","date":1243458018,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, false, null, null, readOnly);\n  }\n\n","sourceOld":"  /** Returns a read/write or read only IndexReader reading the index in the given Directory.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, false, null, null, readOnly);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4e54e4a9a2442944e55f58e835877841cdac1271","date":1244628560,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, null, null, readOnly);\n  }\n\n","sourceOld":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, false, null, null, readOnly);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"961159f13aece73fbb30aea720e77a2237e8bafd","date":1247258916,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, null, null, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, null, null, readOnly);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","pathOld":"src/java/org/apache/lucene/index/IndexReader#open(Directory,boolean).mjava","sourceNew":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, null, null, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","sourceOld":"  /** Returns an IndexReader reading the index in the given\n   *  Directory.  You should pass readOnly=true, since it\n   *  gives much better concurrent performance, unless you\n   *  intend to do write operations (delete documents or\n   *  change norms) with the reader.\n   * @param directory the index directory\n   * @param readOnly true if no changes (deletions, norms) will be made with this IndexReader\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public static IndexReader open(final Directory directory, boolean readOnly) throws CorruptIndexException, IOException {\n    return open(directory, null, null, readOnly, DEFAULT_TERMS_INDEX_DIVISOR);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5712975970a595c28f1988efd007e1b8a617a92f":["8b6187898fc4413ccd18229711786550a280383c"],"1b54a9bc667895a2095a886184bf69a3179e63df":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"4e54e4a9a2442944e55f58e835877841cdac1271":["0dabcca520e81aeff96f5c937b7ffb5617ee69d1"],"a8a6f0cea0d6b50602e9b67dbf17eb1fb8ecf14a":["1b54a9bc667895a2095a886184bf69a3179e63df"],"0dabcca520e81aeff96f5c937b7ffb5617ee69d1":["5712975970a595c28f1988efd007e1b8a617a92f"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"12d40284fd9481f79444bc63bc5d13847caddd3d":["7c687c6cd32bfdceab8fd653a483592265774d97"],"7c687c6cd32bfdceab8fd653a483592265774d97":["6e5d88b55f1b57feab6da94a5c635a224539bd2a"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["12d40284fd9481f79444bc63bc5d13847caddd3d"],"961159f13aece73fbb30aea720e77a2237e8bafd":["4e54e4a9a2442944e55f58e835877841cdac1271"],"6e5d88b55f1b57feab6da94a5c635a224539bd2a":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8b6187898fc4413ccd18229711786550a280383c":["a8a6f0cea0d6b50602e9b67dbf17eb1fb8ecf14a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["961159f13aece73fbb30aea720e77a2237e8bafd"]},"commit2Childs":{"5712975970a595c28f1988efd007e1b8a617a92f":["0dabcca520e81aeff96f5c937b7ffb5617ee69d1"],"1b54a9bc667895a2095a886184bf69a3179e63df":["a8a6f0cea0d6b50602e9b67dbf17eb1fb8ecf14a"],"4e54e4a9a2442944e55f58e835877841cdac1271":["961159f13aece73fbb30aea720e77a2237e8bafd"],"a8a6f0cea0d6b50602e9b67dbf17eb1fb8ecf14a":["8b6187898fc4413ccd18229711786550a280383c"],"0dabcca520e81aeff96f5c937b7ffb5617ee69d1":["4e54e4a9a2442944e55f58e835877841cdac1271"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["6e5d88b55f1b57feab6da94a5c635a224539bd2a"],"12d40284fd9481f79444bc63bc5d13847caddd3d":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"7c687c6cd32bfdceab8fd653a483592265774d97":["12d40284fd9481f79444bc63bc5d13847caddd3d"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["1b54a9bc667895a2095a886184bf69a3179e63df"],"6e5d88b55f1b57feab6da94a5c635a224539bd2a":["7c687c6cd32bfdceab8fd653a483592265774d97"],"961159f13aece73fbb30aea720e77a2237e8bafd":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"8b6187898fc4413ccd18229711786550a280383c":["5712975970a595c28f1988efd007e1b8a617a92f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}