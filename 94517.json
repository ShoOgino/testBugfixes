{"path":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e919043fa85ee891123768dd655a98edbbf63c","date":1322225413,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, new BytesRef(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0445bcd8433e331f296f5502fc089b336cbac3a6","date":1322630375,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        DocsEnum.BulkReadResult bulk = sub.docsEnum.getBulkResult();\n        int base = sub.slice.start;\n\n        for (;;) {\n          int nDocs = sub.docsEnum.read();\n          if (nDocs == 0) break;\n          int[] docArr = bulk.docs.ints;\n          int end = bulk.docs.offset + nDocs;\n          if (upto + nDocs > docs.length) {\n            if (obs == null) obs = new OpenBitSet(maxDoc());\n            for (int i=bulk.docs.offset; i<end; i++) {\n              obs.fastSet(docArr[i]+base);\n            }\n            bitsSet += nDocs;\n          } else {\n            for (int i=bulk.docs.offset; i<end; i++) {\n              docs[upto++] = docArr[i]+base;\n            }\n          }\n        }\n      }\n    } else {\n      DocsEnum.BulkReadResult bulk = docsEnum.getBulkResult();\n      for (;;) {\n        int nDocs = docsEnum.read();\n        if (nDocs == 0) break;\n        int[] docArr = bulk.docs.ints;\n        int end = bulk.docs.offset + nDocs;\n\n        if (upto + nDocs > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          for (int i=bulk.docs.offset; i<end; i++) {\n            obs.fastSet(docArr[i]);\n          }\n          bitsSet += nDocs;\n        } else {\n          for (int i=bulk.docs.offset; i<end; i++) {\n            docs[upto++] = docArr[i];\n          }\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"872cff1d3a554e0cd64014cd97f88d3002b0f491","date":1323024658,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, false);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":["02331260bb246364779cb6f04919ca47900d01bb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b65b350ca9588f9fc76ce7d6804160d06c45ff42","date":1323026297,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, false);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"02331260bb246364779cb6f04919ca47900d01bb","date":1343749884,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, 0);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, false);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":["872cff1d3a554e0cd64014cd97f88d3002b0f491"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, 0);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, false);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, 0);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, false);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, DocsEnum.FLAG_NONE);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, 0);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, DocsEnum.FLAG_NONE);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, 0);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1","date":1392536197,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, DocsEnum.FLAG_NONE);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    OpenBitSet obs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, DocsEnum.FLAG_NONE);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (obs == null) obs = new OpenBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            obs.fastSet(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (obs == null) obs = new OpenBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          obs.fastSet(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (obs != null) {\n      for (int i=0; i<upto; i++) {\n        obs.fastSet(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(obs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.FLAG_NONE);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    DocsEnum docsEnum = deState.termsEnum.docs(deState.liveDocs, deState.docsEnum, DocsEnum.FLAG_NONE);\n    if (deState.docsEnum == null) {\n      deState.docsEnum = docsEnum;\n    }\n\n    if (docsEnum instanceof MultiDocsEnum) {\n      MultiDocsEnum.EnumWithSlice[] subs = ((MultiDocsEnum)docsEnum).getSubs();\n      int numSubs = ((MultiDocsEnum)docsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiDocsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.docsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.NONE);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.FLAG_NONE);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5311f0bff57ce15a23909f4cfb953773630534","date":1424827033,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.NONE);\n    // nocommit: check\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.NONE);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb77aeaebb451427f825381042f68a6916417d1d","date":1427819930,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.NONE);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.NONE);\n    // nocommit: check\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.liveDocs, deState.postingsEnum, PostingsEnum.NONE);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0","date":1442027674,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = maxDoc()>>6;\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38b5bd3ae837751f57f363e9a41b833794222814","date":1445342257,"type":3,"author":"Tommaso Teofili","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, deState.termsEnum.term()));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, BytesRef.deepCopyOf(deState.termsEnum.term())));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac9de183adbc9483681f275ac1e2d92ed19f52e1","date":1452414626,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** @lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, deState.termsEnum.term()));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize) deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex < numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n\n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i = 0; i < upto; i++) {\n        fbs.set(docs[i]);\n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto == 0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, deState.termsEnum.term()));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize)\n      deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex<numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n        \n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        if (fbs == null) fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i=0; i<upto; i++) {\n        fbs.set(docs[i]);  \n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto==0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n    \n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d67f43c293f81a92c10131e75761f4e4e968b06c","date":1584534689,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/SolrIndexSearcher#getDocSet(DocsEnumState).mjava","sourceNew":"  /** @lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, deState.termsEnum.term()));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize) deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex < numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n\n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i = 0; i < upto; i++) {\n        fbs.set(docs[i]);\n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto == 0 ? DocSet.empty() : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n\n    return result;\n  }\n\n","sourceOld":"  /** @lucene.internal */\n  public DocSet getDocSet(DocsEnumState deState) throws IOException {\n    int largestPossible = deState.termsEnum.docFreq();\n    boolean useCache = filterCache != null && largestPossible >= deState.minSetSizeCached;\n    TermQuery key = null;\n\n    if (useCache) {\n      key = new TermQuery(new Term(deState.fieldName, deState.termsEnum.term()));\n      DocSet result = filterCache.get(key);\n      if (result != null) return result;\n    }\n\n    int smallSetSize = DocSetUtil.smallSetSize(maxDoc());\n    int scratchSize = Math.min(smallSetSize, largestPossible);\n    if (deState.scratch == null || deState.scratch.length < scratchSize) deState.scratch = new int[scratchSize];\n\n    final int[] docs = deState.scratch;\n    int upto = 0;\n    int bitsSet = 0;\n    FixedBitSet fbs = null;\n\n    PostingsEnum postingsEnum = deState.termsEnum.postings(deState.postingsEnum, PostingsEnum.NONE);\n    postingsEnum = BitsFilteredPostingsEnum.wrap(postingsEnum, deState.liveDocs);\n    if (deState.postingsEnum == null) {\n      deState.postingsEnum = postingsEnum;\n    }\n\n    if (postingsEnum instanceof MultiPostingsEnum) {\n      MultiPostingsEnum.EnumWithSlice[] subs = ((MultiPostingsEnum) postingsEnum).getSubs();\n      int numSubs = ((MultiPostingsEnum) postingsEnum).getNumSubs();\n      for (int subindex = 0; subindex < numSubs; subindex++) {\n        MultiPostingsEnum.EnumWithSlice sub = subs[subindex];\n        if (sub.postingsEnum == null) continue;\n        int base = sub.slice.start;\n        int docid;\n\n        if (largestPossible > docs.length) {\n          if (fbs == null) fbs = new FixedBitSet(maxDoc());\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            fbs.set(docid + base);\n            bitsSet++;\n          }\n        } else {\n          while ((docid = sub.postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n            docs[upto++] = docid + base;\n          }\n        }\n      }\n    } else {\n      int docid;\n      if (largestPossible > docs.length) {\n        fbs = new FixedBitSet(maxDoc());\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          fbs.set(docid);\n          bitsSet++;\n        }\n      } else {\n        while ((docid = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {\n          docs[upto++] = docid;\n        }\n      }\n    }\n\n    DocSet result;\n    if (fbs != null) {\n      for (int i = 0; i < upto; i++) {\n        fbs.set(docs[i]);\n      }\n      bitsSet += upto;\n      result = new BitDocSet(fbs, bitsSet);\n    } else {\n      result = upto == 0 ? DocSet.EMPTY : new SortedIntDocSet(Arrays.copyOf(docs, upto));\n    }\n\n    if (useCache) {\n      filterCache.put(key, result);\n    }\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["02331260bb246364779cb6f04919ca47900d01bb","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"0445bcd8433e331f296f5502fc089b336cbac3a6":["e6e919043fa85ee891123768dd655a98edbbf63c"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["0445bcd8433e331f296f5502fc089b336cbac3a6"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["38b5bd3ae837751f57f363e9a41b833794222814"],"51f5280f31484820499077f41fcdfe92d527d9dc":["a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"cb5311f0bff57ce15a23909f4cfb953773630534":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["02331260bb246364779cb6f04919ca47900d01bb"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":["0445bcd8433e331f296f5502fc089b336cbac3a6","872cff1d3a554e0cd64014cd97f88d3002b0f491"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["872cff1d3a554e0cd64014cd97f88d3002b0f491","02331260bb246364779cb6f04919ca47900d01bb"],"38b5bd3ae837751f57f363e9a41b833794222814":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["872cff1d3a554e0cd64014cd97f88d3002b0f491","02331260bb246364779cb6f04919ca47900d01bb"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cb77aeaebb451427f825381042f68a6916417d1d":["cb5311f0bff57ce15a23909f4cfb953773630534"],"e6e919043fa85ee891123768dd655a98edbbf63c":["c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d67f43c293f81a92c10131e75761f4e4e968b06c"],"d67f43c293f81a92c10131e75761f4e4e968b06c":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"02331260bb246364779cb6f04919ca47900d01bb":["872cff1d3a554e0cd64014cd97f88d3002b0f491"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"0445bcd8433e331f296f5502fc089b336cbac3a6":["872cff1d3a554e0cd64014cd97f88d3002b0f491","b65b350ca9588f9fc76ce7d6804160d06c45ff42"],"c26f00b574427b55127e869b935845554afde1fa":["e6e919043fa85ee891123768dd655a98edbbf63c"],"ca0cc2f173b07ff75ca951e017f5dd1f319fdad0":["38b5bd3ae837751f57f363e9a41b833794222814"],"872cff1d3a554e0cd64014cd97f88d3002b0f491":["b65b350ca9588f9fc76ce7d6804160d06c45ff42","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","02331260bb246364779cb6f04919ca47900d01bb"],"ac9de183adbc9483681f275ac1e2d92ed19f52e1":["d67f43c293f81a92c10131e75761f4e4e968b06c"],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"cb5311f0bff57ce15a23909f4cfb953773630534":["cb77aeaebb451427f825381042f68a6916417d1d"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["ca0cc2f173b07ff75ca951e017f5dd1f319fdad0"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["cb5311f0bff57ce15a23909f4cfb953773630534","0f4464508ee83288c8c4585b533f9faaa93aa314"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","a69cf7f1b4cac5d5b1363402b565cd535f13e6a1"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a69cf7f1b4cac5d5b1363402b565cd535f13e6a1":["51f5280f31484820499077f41fcdfe92d527d9dc"],"b65b350ca9588f9fc76ce7d6804160d06c45ff42":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"38b5bd3ae837751f57f363e9a41b833794222814":["ac9de183adbc9483681f275ac1e2d92ed19f52e1"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cb77aeaebb451427f825381042f68a6916417d1d":[],"e6e919043fa85ee891123768dd655a98edbbf63c":["0445bcd8433e331f296f5502fc089b336cbac3a6"],"02331260bb246364779cb6f04919ca47900d01bb":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d67f43c293f81a92c10131e75761f4e4e968b06c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b65b350ca9588f9fc76ce7d6804160d06c45ff42","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","a258fbb26824fd104ed795e5d9033d2d040049ee","cb77aeaebb451427f825381042f68a6916417d1d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}