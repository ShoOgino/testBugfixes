{"path":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/DimensionalPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        DimensionalValues values = reader.getDimensionalValues();\n        if (values == null) {\n          // No docs in this segment had any dimensional fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = DimensionalLatLonField.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = DimensionalLatLonField.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04995b00da1e08edb88b14c5a9789d741de5c51d","date":1453863716,"type":3,"author":"Nick Knize","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":["33bb6bd7295e66f93f182556f5353b97243e62ba"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPoly(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f226a8b088dd9c8f6ab287a77237c4aa00a238e5","date":1456187572,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, 1));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, 1));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, 1));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2b63007489248c99b5cdc766ce55938891f5d969","date":1456737032,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["b89d71e0157fcc66ac45395765150cc85ee28aec","b89d71e0157fcc66ac45395765150cc85ee28aec"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        int[] hitCount = new int[1];\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             hitCount[0]++;\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               hitCount[0]++;\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        // NOTE: hitCount[0] will be over-estimate in multi-valued case\n        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94ee361295fb38310ac4d53cb4773d1622423d68","date":1456833885,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":["b89d71e0157fcc66ac45395765150cc85ee28aec","b89d71e0157fcc66ac45395765150cc85ee28aec"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/LatLonPointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/search/PointInPolygonQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);\n        if (fieldInfo == null) {\n          // No docs in this segment indexed this field at all\n          return null;\n        }\n        LatLonPoint.checkCompatible(fieldInfo);\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLatitude(packedValue, 0);\n                             double lon = LatLonPoint.decodeLongitude(packedValue, Integer.BYTES);\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLatitude(minPackedValue, 0);\n                             double cellMinLon = LatLonPoint.decodeLongitude(minPackedValue, Integer.BYTES);\n                             double cellMaxLat = LatLonPoint.decodeLatitude(maxPackedValue, 0);\n                             double cellMaxLon = LatLonPoint.decodeLongitude(maxPackedValue, Integer.BYTES);\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n\n    // I don't use RandomAccessWeight here: it's no good to approximate with \"match all docs\"; this is an inverted structure and should be\n    // used in the first pass:\n\n    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should\n    // then check the polygon\n\n    return new ConstantScoreWeight(this) {\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        LeafReader reader = context.reader();\n        PointValues values = reader.getPointValues();\n        if (values == null) {\n          // No docs in this segment had any points fields\n          return null;\n        }\n\n        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());\n        values.intersect(field,\n                         new IntersectVisitor() {\n                           @Override\n                           public void visit(int docID) {\n                             result.add(docID);\n                           }\n\n                           @Override\n                           public void visit(int docID, byte[] packedValue) {\n                             assert packedValue.length == 8;\n                             double lat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(packedValue, 0));\n                             double lon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(packedValue, Integer.BYTES));\n                             if (GeoRelationUtils.pointInPolygon(polyLons, polyLats, lat, lon)) {\n                               result.add(docID);\n                             }\n                           }\n\n                           @Override\n                           public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                             double cellMinLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(minPackedValue, 0));\n                             double cellMinLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(minPackedValue, Integer.BYTES));\n                             double cellMaxLat = LatLonPoint.decodeLat(NumericUtils.bytesToInt(maxPackedValue, 0));\n                             double cellMaxLon = LatLonPoint.decodeLon(NumericUtils.bytesToInt(maxPackedValue, Integer.BYTES));\n\n                             if (cellMinLat <= minLat && cellMaxLat >= maxLat && cellMinLon <= minLon && cellMaxLon >= maxLon) {\n                               // Cell fully encloses the query\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else  if (GeoRelationUtils.rectWithinPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_INSIDE_QUERY;\n                             } else if (GeoRelationUtils.rectCrossesPolyPrecise(cellMinLon, cellMinLat, cellMaxLon, cellMaxLat,\n                                                                 polyLons, polyLats,\n                                                                 minLon, minLat, maxLon, maxLat)) {\n                               return Relation.CELL_CROSSES_QUERY;\n                             } else {\n                               return Relation.CELL_OUTSIDE_QUERY;\n                             }\n                           }\n                         });\n\n        return new ConstantScoreScorer(this, score(), result.build().iterator());\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"af2638813028b254a88b418ebeafb541afb49653":["419a8f52c6635419beb951255cacbbb281044c57","2b63007489248c99b5cdc766ce55938891f5d969"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b63007489248c99b5cdc766ce55938891f5d969":["419a8f52c6635419beb951255cacbbb281044c57"],"94ee361295fb38310ac4d53cb4773d1622423d68":["2b63007489248c99b5cdc766ce55938891f5d969"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","04995b00da1e08edb88b14c5a9789d741de5c51d"],"419a8f52c6635419beb951255cacbbb281044c57":["04995b00da1e08edb88b14c5a9789d741de5c51d","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["04995b00da1e08edb88b14c5a9789d741de5c51d"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"04995b00da1e08edb88b14c5a9789d741de5c51d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"af2638813028b254a88b418ebeafb541afb49653":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","04995b00da1e08edb88b14c5a9789d741de5c51d"],"2b63007489248c99b5cdc766ce55938891f5d969":["af2638813028b254a88b418ebeafb541afb49653","94ee361295fb38310ac4d53cb4773d1622423d68"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"94ee361295fb38310ac4d53cb4773d1622423d68":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"419a8f52c6635419beb951255cacbbb281044c57":["af2638813028b254a88b418ebeafb541afb49653","2b63007489248c99b5cdc766ce55938891f5d969"],"f226a8b088dd9c8f6ab287a77237c4aa00a238e5":["419a8f52c6635419beb951255cacbbb281044c57"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"04995b00da1e08edb88b14c5a9789d741de5c51d":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","419a8f52c6635419beb951255cacbbb281044c57","f226a8b088dd9c8f6ab287a77237c4aa00a238e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}