{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","commits":[{"id":"3eaeb36333664e8cb92108ef03f68a7b90beb759","date":1480015298,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"/dev/null","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"/dev/null","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ea13f0ffd30b65fc1e59ce96948fc1db68ddd4cf","date":1491191579,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd7cebd53a1b7af73c5ca163a8a64808c9cf159d","date":1491310508,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a513b6a92751e54c76fb5447948c9e7d437163a7","date":1496136565,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74aea047dff7f7c38a2d766827bd20d356f98c6a","date":1496721416,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shoulRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shoulRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0544142c22eb88b6d8b3817f2e1190156aa4f9af","date":1551692505,"type":5,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#getDocCollection(String,Integer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/CloudSolrClient#getDocCollection(String,Integer).mjava","sourceNew":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    ClusterState.CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","sourceOld":"  protected DocCollection getDocCollection(String collection, Integer expectedVersion) throws SolrException {\n    if (expectedVersion == null) expectedVersion = -1;\n    if (collection == null) return null;\n    ExpiringCachedDocCollection cacheEntry = collectionStateCache.get(collection);\n    DocCollection col = cacheEntry == null ? null : cacheEntry.cached;\n    if (col != null) {\n      if (expectedVersion <= col.getZNodeVersion()\n          && !cacheEntry.shouldRetry()) return col;\n    }\n\n    CollectionRef ref = getCollectionRef(collection);\n    if (ref == null) {\n      //no such collection exists\n      return null;\n    }\n    if (!ref.isLazilyLoaded()) {\n      //it is readily available just return it\n      return ref.get();\n    }\n    List locks = this.locks;\n    final Object lock = locks.get(Math.abs(Hash.murmurhash3_x86_32(collection, 0, collection.length(), 0) % locks.size()));\n    DocCollection fetchedCol = null;\n    synchronized (lock) {\n      /*we have waited for sometime just check once again*/\n      cacheEntry = collectionStateCache.get(collection);\n      col = cacheEntry == null ? null : cacheEntry.cached;\n      if (col != null) {\n        if (expectedVersion <= col.getZNodeVersion()\n            && !cacheEntry.shouldRetry()) return col;\n      }\n      // We are going to fetch a new version\n      // we MUST try to get a new version\n      fetchedCol = ref.get();//this is a call to ZK\n      if (fetchedCol == null) return null;// this collection no more exists\n      if (col != null && fetchedCol.getZNodeVersion() == col.getZNodeVersion()) {\n        cacheEntry.setRetriedAt();//we retried and found that it is the same version\n        cacheEntry.maybeStale = false;\n      } else {\n        if (fetchedCol.getStateFormat() > 1)\n          collectionStateCache.put(collection, new ExpiringCachedDocCollection(fetchedCol));\n      }\n      return fetchedCol;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["cd7cebd53a1b7af73c5ca163a8a64808c9cf159d","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["28288370235ed02234a64753cdbf0c6ec096304a"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"727bb765ff2542275f6d31f67be18d7104bae148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["3eaeb36333664e8cb92108ef03f68a7b90beb759","a513b6a92751e54c76fb5447948c9e7d437163a7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a513b6a92751e54c76fb5447948c9e7d437163a7":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd7cebd53a1b7af73c5ca163a8a64808c9cf159d":["ea13f0ffd30b65fc1e59ce96948fc1db68ddd4cf"],"ea13f0ffd30b65fc1e59ce96948fc1db68ddd4cf":["3eaeb36333664e8cb92108ef03f68a7b90beb759"],"28288370235ed02234a64753cdbf0c6ec096304a":["3eaeb36333664e8cb92108ef03f68a7b90beb759","74aea047dff7f7c38a2d766827bd20d356f98c6a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["0544142c22eb88b6d8b3817f2e1190156aa4f9af"],"0544142c22eb88b6d8b3817f2e1190156aa4f9af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"74aea047dff7f7c38a2d766827bd20d356f98c6a":["e9017cf144952056066919f1ebc7897ff9bd71b1","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["727bb765ff2542275f6d31f67be18d7104bae148","3eaeb36333664e8cb92108ef03f68a7b90beb759"],"a513b6a92751e54c76fb5447948c9e7d437163a7":["74aea047dff7f7c38a2d766827bd20d356f98c6a"],"3eaeb36333664e8cb92108ef03f68a7b90beb759":["727bb765ff2542275f6d31f67be18d7104bae148","74aea047dff7f7c38a2d766827bd20d356f98c6a","a513b6a92751e54c76fb5447948c9e7d437163a7","ea13f0ffd30b65fc1e59ce96948fc1db68ddd4cf","28288370235ed02234a64753cdbf0c6ec096304a"],"cd7cebd53a1b7af73c5ca163a8a64808c9cf159d":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"ea13f0ffd30b65fc1e59ce96948fc1db68ddd4cf":["cd7cebd53a1b7af73c5ca163a8a64808c9cf159d"],"28288370235ed02234a64753cdbf0c6ec096304a":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}