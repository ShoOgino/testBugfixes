{"path":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","commits":[{"id":"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa","date":1349450075,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","pathOld":"/dev/null","sourceNew":"  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9ee663728a95682ffb5dee37517ac9e863cd0820","date":1352758633,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","sourceNew":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput)}, this method is slower,\n   * uses more memory (~ 256KB), but should provide better compression ratios\n   * (especially on large inputs) because it chooses the best match among up to\n   * 256 candidates and then performs trade-offs to fix overlapping matches.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","sourceOld":"  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69","date":1352818449,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","sourceNew":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput)}, this method is slower,\n   * uses more memory (~ 256KB), but should provide better compression ratios\n   * (especially on large inputs) because it chooses the best match among up to\n   * 256 candidates and then performs trade-offs to fix overlapping matches.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","sourceOld":"  /**\n   * Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to\n   * {@link LZ4#compress(byte[], int, int, DataOutput)}, this method is slower,\n   * uses more memory (~ 256KB), but should provide better compression ratios\n   * (especially on large inputs) because it chooses the best match among up to\n   * 256 candidates and then performs trade-offs to fix overlapping matches.\n   */\n  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/codecs/src/java/org/apache/lucene/codecs/compressing/LZ4#compressHC(byte[],int,int,DataOutput).mjava","sourceNew":null,"sourceOld":"  public static void compressHC(byte[] src, int srcOff, int srcLen, DataOutput out) throws IOException {\n\n    final int srcEnd = srcOff + srcLen;\n    final int matchLimit = srcEnd - LAST_LITERALS;\n\n    int sOff = srcOff;\n    int anchor = sOff++;\n\n    final HashTable ht = new HashTable(srcOff);\n    final Match match0 = new Match();\n    final Match match1 = new Match();\n    final Match match2 = new Match();\n    final Match match3 = new Match();\n\n    main:\n    while (sOff < matchLimit) {\n      if (!ht.insertAndFindBestMatch(src, sOff, matchLimit, match1)) {\n        ++sOff;\n        continue;\n      }\n\n      // saved, in case we would skip too much\n      copyTo(match1, match0);\n\n      search2:\n      while (true) {\n        assert match1.start >= anchor;\n        if (match1.end() >= matchLimit\n            || !ht.insertAndFindWiderMatch(src, match1.end() - 2, match1.start + 1, matchLimit, match1.len, match2)) {\n          // no better match\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n          continue main;\n        }\n\n        if (match0.start < match1.start) {\n          if (match2.start < match1.start + match0.len) { // empirical\n            copyTo(match0, match1);\n          }\n        }\n        assert match2.start > match1.start;\n\n        if (match2.start - match1.start < 3) { // First Match too small : removed\n          copyTo(match2, match1);\n          continue search2;\n        }\n\n        search3:\n        while (true) {\n          if (match2.start - match1.start < OPTIMAL_ML) {\n            int newMatchLen = match1.len;\n            if (newMatchLen > OPTIMAL_ML) {\n              newMatchLen = OPTIMAL_ML;\n            }\n            if (match1.start + newMatchLen > match2.end() - MIN_MATCH) {\n              newMatchLen = match2.start - match1.start + match2.len - MIN_MATCH;\n            }\n            final int correction = newMatchLen - (match2.start - match1.start);\n            if (correction > 0) {\n              match2.fix(correction);\n            }\n          }\n\n          if (match2.start + match2.len >= matchLimit\n              || !ht.insertAndFindWiderMatch(src, match2.end() - 3, match2.start, matchLimit, match2.len, match3)) {\n            // no better match -> 2 sequences to encode\n            if (match2.start < match1.end()) {\n              if (match2.start - match1.start < OPTIMAL_ML) {\n                if (match1.len > OPTIMAL_ML) {\n                  match1.len = OPTIMAL_ML;\n                }\n                if (match1.end() > match2.end() - MIN_MATCH) {\n                  match1.len = match2.end() - match1.start - MIN_MATCH;\n                }\n                final int correction = match1.len - (match2.start - match1.start);\n                if (correction > 0) {\n                  match2.fix(correction);\n                }\n              } else {\n                match1.len = match2.start - match1.start;\n              }\n            }\n            // encode seq 1\n            encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n            anchor = sOff = match1.end();\n            // encode seq 2\n            encodeSequence(src, anchor, match2.ref, match2.start, match2.len, out);\n            anchor = sOff = match2.end();\n            continue main;\n          }\n\n          if (match3.start < match1.end() + 3) { // Not enough space for match 2 : remove it\n            if (match3.start >= match1.end()) { // // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n              if (match2.start < match1.end()) {\n                final int correction = match1.end() - match2.start;\n                match2.fix(correction);\n                if (match2.len < MIN_MATCH) {\n                  copyTo(match3, match2);\n                }\n              }\n\n              encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n              anchor = sOff = match1.end();\n\n              copyTo(match3, match1);\n              copyTo(match2, match0);\n\n              continue search2;\n            }\n\n            copyTo(match3, match2);\n            continue search3;\n          }\n\n          // OK, now we have 3 ascending matches; let's write at least the first one\n          if (match2.start < match1.end()) {\n            if (match2.start - match1.start < 0x0F) {\n              if (match1.len > OPTIMAL_ML) {\n                match1.len = OPTIMAL_ML;\n              }\n              if (match1.end() > match2.end() - MIN_MATCH) {\n                match1.len = match2.end() - match1.start - MIN_MATCH;\n              }\n              final int correction = match1.end() - match2.start;\n              match2.fix(correction);\n            } else {\n              match1.len = match2.start - match1.start;\n            }\n          }\n\n          encodeSequence(src, anchor, match1.ref, match1.start, match1.len, out);\n          anchor = sOff = match1.end();\n\n          copyTo(match2, match1);\n          copyTo(match3, match2);\n\n          continue search3;\n        }\n\n      }\n\n    }\n\n    encodeLastLiterals(src, anchor, srcEnd - anchor, out);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ee663728a95682ffb5dee37517ac9e863cd0820":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["9ee663728a95682ffb5dee37517ac9e863cd0820"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa","5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"]},"commit2Childs":{"9ee663728a95682ffb5dee37517ac9e863cd0820":["5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69"],"5e04b732c631a77cbbd25b6ce43c2a8abb1e9e69":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa":["9ee663728a95682ffb5dee37517ac9e863cd0820","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7d1467e0527cb2aeb9d7a05c26948ac9d82d81fa"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}