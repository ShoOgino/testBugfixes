{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          final int posLen;\n          if (chIDX == chEnd && lastStart == scratchChars.offset) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n            posLen = matchInputLength;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n            posLen = 1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen, endOffset, posLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","sourceOld":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          final int posLen;\n          if (chIDX == chEnd && lastStart == scratchChars.offset) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n            posLen = matchInputLength;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n            posLen = 1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen, endOffset, posLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3938e891050232a07c92a8acfa853c5a5e2a8259","date":1348763107,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          final int posLen;\n          if (chIDX == chEnd && lastStart == scratchChars.offset) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n            posLen = keepOrig ? matchInputLength : 1;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n            posLen = 1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen, endOffset, posLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","sourceOld":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          final int posLen;\n          if (chIDX == chEnd && lastStart == scratchChars.offset) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n            posLen = matchInputLength;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n            posLen = 1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen, endOffset, posLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/synonym/SynonymFilter#addOutput(BytesRef,int,int).mjava","sourceNew":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      scratchChars.copyUTF8Bytes(scratchBytes);\n      int lastStart = 0;\n      final int chEnd = lastStart + scratchChars.length();\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.charAt(chIDX) == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          final int posLen;\n          if (chIDX == chEnd && lastStart == 0) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n            posLen = keepOrig ? matchInputLength : 1;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n            posLen = 1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars(), lastStart, outputLen, endOffset, posLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","sourceOld":"  // Interleaves all output tokens onto the futureOutputs:\n  private void addOutput(BytesRef bytes, int matchInputLength, int matchEndOffset) {\n    bytesReader.reset(bytes.bytes, bytes.offset, bytes.length);\n\n    final int code = bytesReader.readVInt();\n    final boolean keepOrig = (code & 0x1) == 0;\n    final int count = code >>> 1;\n    //System.out.println(\"  addOutput count=\" + count + \" keepOrig=\" + keepOrig);\n    for(int outputIDX=0;outputIDX<count;outputIDX++) {\n      synonyms.words.get(bytesReader.readVInt(),\n                         scratchBytes);\n      //System.out.println(\"    outIDX=\" + outputIDX + \" bytes=\" + scratchBytes.length);\n      UnicodeUtil.UTF8toUTF16(scratchBytes, scratchChars);\n      int lastStart = scratchChars.offset;\n      final int chEnd = lastStart + scratchChars.length;\n      int outputUpto = nextRead;\n      for(int chIDX=lastStart;chIDX<=chEnd;chIDX++) {\n        if (chIDX == chEnd || scratchChars.chars[chIDX] == SynonymMap.WORD_SEPARATOR) {\n          final int outputLen = chIDX - lastStart;\n          // Caller is not allowed to have empty string in\n          // the output:\n          assert outputLen > 0: \"output contains empty string: \" + scratchChars;\n          final int endOffset;\n          final int posLen;\n          if (chIDX == chEnd && lastStart == scratchChars.offset) {\n            // This rule had a single output token, so, we set\n            // this output's endOffset to the current\n            // endOffset (ie, endOffset of the last input\n            // token it matched):\n            endOffset = matchEndOffset;\n            posLen = keepOrig ? matchInputLength : 1;\n          } else {\n            // This rule has more than one output token; we\n            // can't pick any particular endOffset for this\n            // case, so, we inherit the endOffset for the\n            // input token which this output overlaps:\n            endOffset = -1;\n            posLen = 1;\n          }\n          futureOutputs[outputUpto].add(scratchChars.chars, lastStart, outputLen, endOffset, posLen);\n          //System.out.println(\"      \" + new String(scratchChars.chars, lastStart, outputLen) + \" outputUpto=\" + outputUpto);\n          lastStart = 1+chIDX;\n          //System.out.println(\"  slot=\" + outputUpto + \" keepOrig=\" + keepOrig);\n          outputUpto = rollIncr(outputUpto);\n          assert futureOutputs[outputUpto].posIncr == 1: \"outputUpto=\" + outputUpto + \" vs nextWrite=\" + nextWrite;\n        }\n      }\n    }\n\n    int upto = nextRead;\n    for(int idx=0;idx<matchInputLength;idx++) {\n      futureInputs[upto].keepOrig |= keepOrig;\n      futureInputs[upto].matched = true;\n      upto = rollIncr(upto);\n    }\n  }\n\n","bugFix":["44d6f0ab53c1962856b9f48dedb7a2a6cc18905c","ffbcd36aff3bb411177ed61f02fb3d3aa9588d27","865b7d0f8430a08d385370b6b87a89a737aa6145"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3938e891050232a07c92a8acfa853c5a5e2a8259":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["3938e891050232a07c92a8acfa853c5a5e2a8259"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["3938e891050232a07c92a8acfa853c5a5e2a8259"],"3938e891050232a07c92a8acfa853c5a5e2a8259":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}