{"path":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper#filterPostings(BytesRef,PostingsEnum,Spans).mjava","commits":[{"id":"1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2","date":1475611903,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper#filterPostings(BytesRef,PostingsEnum,Spans).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a filtered postings where the position must be in the given Spans.\n   * The Spans must be in a positioned state (not initial) and should not be shared between other terms.\n   * {@code postingsEnum} should be positioned at the\n   * document (the same one as the spans) but it hasn't iterated the positions yet.\n   * The Spans should be the result of a simple\n   * lookup from {@link #getTermToSpans(LeafReader, int)}, and so it could be null which could mean\n   * either it's completely filtered or that there should be no filtering; this class knows what to do.\n   * <p>\n   * Due to limitations in filtering, the {@link PostingsEnum#freq()} is un-changed even if some positions\n   * get filtered.  So when {@link PostingsEnum#nextPosition()} is called or {@code startOffset} or {@code\n   * endOffset} beyond the \"real\" positions, these methods returns {@link Integer#MAX_VALUE}.\n   * <p>\n   * <b>This will return null if it's completely filtered out (i.e. effectively has no postings).</b>\n   */\n  PostingsEnum filterPostings(BytesRef term, PostingsEnum postingsEnum, Spans spans)\n      throws IOException {\n    if (spans == null) {\n      if (hasPositionSensitivity() == false || positionInsensitiveTerms.contains(new Term(fieldName, term))) {\n        return postingsEnum; // no filtering\n      } else {\n        return null; // completely filtered out\n      }\n    }\n    if (postingsEnum.docID() != spans.docID()) {\n      throw new IllegalStateException(\"Spans & Postings doc ID misaligned or not positioned\");\n    }\n\n    return new FilterLeafReader.FilterPostingsEnum(postingsEnum) {\n      // freq() is max times nextPosition can be called. We'll set this var to -1 when exhausted.\n      int remainingPositions = postingsEnum.freq();\n\n      @Override\n      public String toString() {\n        String where;\n        try {\n          where = \"[\" + startOffset() + \":\" + endOffset() + \"]\";\n        } catch (IOException e) {\n          where = \"[\" + e + \"]\";\n        }\n        return \"'\" + term.utf8ToString() + \"'@\" + where + \" filtered by \" + spans;\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int nextPosition() throws IOException {\n        // loop over posting positions...\n        NEXT_POS_LOOP:\n        while (remainingPositions > 0) {\n          final int thisPos = super.nextPosition();\n          remainingPositions--;\n\n          // loop spans forward (if necessary) while the span end is behind thisPos\n          while (spans.endPosition() <= thisPos) {\n            if (spans.nextStartPosition() == Spans.NO_MORE_POSITIONS) { // advance\n              break NEXT_POS_LOOP;\n            }\n            assert spans.docID() == postingsEnum.docID();\n          }\n\n          // is this position within the span?\n          if (thisPos >= spans.startPosition()) {\n            assert thisPos < spans.endPosition(); // guaranteed by previous loop\n            return thisPos; // yay!\n          }\n          // else continue and try the next position\n        }\n        remainingPositions = -1; // signify done\n        return Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int startOffset() throws IOException {\n        return remainingPositions >= 0 ? super.startOffset() : Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int endOffset() throws IOException {\n        return remainingPositions >= 0 ? super.endOffset() : Integer.MAX_VALUE;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper#filterPostings(BytesRef,PostingsEnum,Spans).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a filtered postings where the position must be in the given Spans.\n   * The Spans must be in a positioned state (not initial) and should not be shared between other terms.\n   * {@code postingsEnum} should be positioned at the\n   * document (the same one as the spans) but it hasn't iterated the positions yet.\n   * The Spans should be the result of a simple\n   * lookup from {@link #getTermToSpans(LeafReader, int)}, and so it could be null which could mean\n   * either it's completely filtered or that there should be no filtering; this class knows what to do.\n   * <p>\n   * Due to limitations in filtering, the {@link PostingsEnum#freq()} is un-changed even if some positions\n   * get filtered.  So when {@link PostingsEnum#nextPosition()} is called or {@code startOffset} or {@code\n   * endOffset} beyond the \"real\" positions, these methods returns {@link Integer#MAX_VALUE}.\n   * <p>\n   * <b>This will return null if it's completely filtered out (i.e. effectively has no postings).</b>\n   */\n  PostingsEnum filterPostings(BytesRef term, PostingsEnum postingsEnum, Spans spans)\n      throws IOException {\n    if (spans == null) {\n      if (hasPositionSensitivity() == false || positionInsensitiveTerms.contains(new Term(fieldName, term))) {\n        return postingsEnum; // no filtering\n      } else {\n        return null; // completely filtered out\n      }\n    }\n    if (postingsEnum.docID() != spans.docID()) {\n      throw new IllegalStateException(\"Spans & Postings doc ID misaligned or not positioned\");\n    }\n\n    return new FilterLeafReader.FilterPostingsEnum(postingsEnum) {\n      // freq() is max times nextPosition can be called. We'll set this var to -1 when exhausted.\n      int remainingPositions = postingsEnum.freq();\n\n      @Override\n      public String toString() {\n        String where;\n        try {\n          where = \"[\" + startOffset() + \":\" + endOffset() + \"]\";\n        } catch (IOException e) {\n          where = \"[\" + e + \"]\";\n        }\n        return \"'\" + term.utf8ToString() + \"'@\" + where + \" filtered by \" + spans;\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int nextPosition() throws IOException {\n        // loop over posting positions...\n        NEXT_POS_LOOP:\n        while (remainingPositions > 0) {\n          final int thisPos = super.nextPosition();\n          remainingPositions--;\n\n          // loop spans forward (if necessary) while the span end is behind thisPos\n          while (spans.endPosition() <= thisPos) {\n            if (spans.nextStartPosition() == Spans.NO_MORE_POSITIONS) { // advance\n              break NEXT_POS_LOOP;\n            }\n            assert spans.docID() == postingsEnum.docID();\n          }\n\n          // is this position within the span?\n          if (thisPos >= spans.startPosition()) {\n            assert thisPos < spans.endPosition(); // guaranteed by previous loop\n            return thisPos; // yay!\n          }\n          // else continue and try the next position\n        }\n        remainingPositions = -1; // signify done\n        return Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int startOffset() throws IOException {\n        return remainingPositions >= 0 ? super.startOffset() : Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int endOffset() throws IOException {\n        return remainingPositions >= 0 ? super.endOffset() : Integer.MAX_VALUE;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eef54e3d232eae0e9fc18d75e9b0c3d9ce04b571","date":1515642580,"type":4,"author":"David Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper#filterPostings(BytesRef,PostingsEnum,Spans).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns a filtered postings where the position must be in the given Spans.\n   * The Spans must be in a positioned state (not initial) and should not be shared between other terms.\n   * {@code postingsEnum} should be positioned at the\n   * document (the same one as the spans) but it hasn't iterated the positions yet.\n   * The Spans should be the result of a simple\n   * lookup from {@link #getTermToSpans(LeafReader, int)}, and so it could be null which could mean\n   * either it's completely filtered or that there should be no filtering; this class knows what to do.\n   * <p>\n   * Due to limitations in filtering, the {@link PostingsEnum#freq()} is un-changed even if some positions\n   * get filtered.  So when {@link PostingsEnum#nextPosition()} is called or {@code startOffset} or {@code\n   * endOffset} beyond the \"real\" positions, these methods returns {@link Integer#MAX_VALUE}.\n   * <p>\n   * <b>This will return null if it's completely filtered out (i.e. effectively has no postings).</b>\n   */\n  PostingsEnum filterPostings(BytesRef term, PostingsEnum postingsEnum, Spans spans)\n      throws IOException {\n    if (spans == null) {\n      if (hasPositionSensitivity() == false || positionInsensitiveTerms.contains(new Term(fieldName, term))) {\n        return postingsEnum; // no filtering\n      } else {\n        return null; // completely filtered out\n      }\n    }\n    if (postingsEnum.docID() != spans.docID()) {\n      throw new IllegalStateException(\"Spans & Postings doc ID misaligned or not positioned\");\n    }\n\n    return new FilterLeafReader.FilterPostingsEnum(postingsEnum) {\n      // freq() is max times nextPosition can be called. We'll set this var to -1 when exhausted.\n      int remainingPositions = postingsEnum.freq();\n\n      @Override\n      public String toString() {\n        String where;\n        try {\n          where = \"[\" + startOffset() + \":\" + endOffset() + \"]\";\n        } catch (IOException e) {\n          where = \"[\" + e + \"]\";\n        }\n        return \"'\" + term.utf8ToString() + \"'@\" + where + \" filtered by \" + spans;\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int nextPosition() throws IOException {\n        // loop over posting positions...\n        NEXT_POS_LOOP:\n        while (remainingPositions > 0) {\n          final int thisPos = super.nextPosition();\n          remainingPositions--;\n\n          // loop spans forward (if necessary) while the span end is behind thisPos\n          while (spans.endPosition() <= thisPos) {\n            if (spans.nextStartPosition() == Spans.NO_MORE_POSITIONS) { // advance\n              break NEXT_POS_LOOP;\n            }\n            assert spans.docID() == postingsEnum.docID();\n          }\n\n          // is this position within the span?\n          if (thisPos >= spans.startPosition()) {\n            assert thisPos < spans.endPosition(); // guaranteed by previous loop\n            return thisPos; // yay!\n          }\n          // else continue and try the next position\n        }\n        remainingPositions = -1; // signify done\n        return Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int startOffset() throws IOException {\n        return remainingPositions >= 0 ? super.startOffset() : Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int endOffset() throws IOException {\n        return remainingPositions >= 0 ? super.endOffset() : Integer.MAX_VALUE;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/highlighter/src/java/org/apache/lucene/search/uhighlight/PhraseHelper#filterPostings(BytesRef,PostingsEnum,Spans).mjava","sourceNew":null,"sourceOld":"  /**\n   * Returns a filtered postings where the position must be in the given Spans.\n   * The Spans must be in a positioned state (not initial) and should not be shared between other terms.\n   * {@code postingsEnum} should be positioned at the\n   * document (the same one as the spans) but it hasn't iterated the positions yet.\n   * The Spans should be the result of a simple\n   * lookup from {@link #getTermToSpans(LeafReader, int)}, and so it could be null which could mean\n   * either it's completely filtered or that there should be no filtering; this class knows what to do.\n   * <p>\n   * Due to limitations in filtering, the {@link PostingsEnum#freq()} is un-changed even if some positions\n   * get filtered.  So when {@link PostingsEnum#nextPosition()} is called or {@code startOffset} or {@code\n   * endOffset} beyond the \"real\" positions, these methods returns {@link Integer#MAX_VALUE}.\n   * <p>\n   * <b>This will return null if it's completely filtered out (i.e. effectively has no postings).</b>\n   */\n  PostingsEnum filterPostings(BytesRef term, PostingsEnum postingsEnum, Spans spans)\n      throws IOException {\n    if (spans == null) {\n      if (hasPositionSensitivity() == false || positionInsensitiveTerms.contains(new Term(fieldName, term))) {\n        return postingsEnum; // no filtering\n      } else {\n        return null; // completely filtered out\n      }\n    }\n    if (postingsEnum.docID() != spans.docID()) {\n      throw new IllegalStateException(\"Spans & Postings doc ID misaligned or not positioned\");\n    }\n\n    return new FilterLeafReader.FilterPostingsEnum(postingsEnum) {\n      // freq() is max times nextPosition can be called. We'll set this var to -1 when exhausted.\n      int remainingPositions = postingsEnum.freq();\n\n      @Override\n      public String toString() {\n        String where;\n        try {\n          where = \"[\" + startOffset() + \":\" + endOffset() + \"]\";\n        } catch (IOException e) {\n          where = \"[\" + e + \"]\";\n        }\n        return \"'\" + term.utf8ToString() + \"'@\" + where + \" filtered by \" + spans;\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        throw new IllegalStateException(\"not expected\"); // don't need to implement; just used on one doc\n      }\n\n      @Override\n      public int nextPosition() throws IOException {\n        // loop over posting positions...\n        NEXT_POS_LOOP:\n        while (remainingPositions > 0) {\n          final int thisPos = super.nextPosition();\n          remainingPositions--;\n\n          // loop spans forward (if necessary) while the span end is behind thisPos\n          while (spans.endPosition() <= thisPos) {\n            if (spans.nextStartPosition() == Spans.NO_MORE_POSITIONS) { // advance\n              break NEXT_POS_LOOP;\n            }\n            assert spans.docID() == postingsEnum.docID();\n          }\n\n          // is this position within the span?\n          if (thisPos >= spans.startPosition()) {\n            assert thisPos < spans.endPosition(); // guaranteed by previous loop\n            return thisPos; // yay!\n          }\n          // else continue and try the next position\n        }\n        remainingPositions = -1; // signify done\n        return Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int startOffset() throws IOException {\n        return remainingPositions >= 0 ? super.startOffset() : Integer.MAX_VALUE;\n      }\n\n      @Override\n      public int endOffset() throws IOException {\n        return remainingPositions >= 0 ? super.endOffset() : Integer.MAX_VALUE;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2","eef54e3d232eae0e9fc18d75e9b0c3d9ce04b571"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"eef54e3d232eae0e9fc18d75e9b0c3d9ce04b571":["1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1f5ce59aaf4a055cc9ec62c15a89c263a05ff4b2":["b94236357aaa22b76c10629851fe4e376e0cea82","eef54e3d232eae0e9fc18d75e9b0c3d9ce04b571","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"eef54e3d232eae0e9fc18d75e9b0c3d9ce04b571":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}