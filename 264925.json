{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","date":1338430031,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9aec642a2f63c39e7553a5bbb73f38e0f68237f5","date":1349277480,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1e8b3369cb0169630bfadbcf2d16a26260bc967","date":1349304984,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5f24f21e70a092329fc6f920115592dc9529d379","date":1349391034,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (true || VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a761b207f161726214a84533bf56a78f6c21ff56","date":1354384027,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (true || VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"479fba77febd29e498fc4a430359e4cf88341da7","date":1357213856,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              if (i%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (true || VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d55763df1c6badbe23b44b735ca86273d27caed","date":1357229491,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              if (i%30 == 0) {\n                w.deleteAll();\n              } else if (i%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (i%3 == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, true);\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (i%40 == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              if (i%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad4fd10e8a24953e897d3f78bc0a7ee320c624d8","date":1357229879,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              if (i%30 == 0) {\n                w.deleteAll();\n              } else if (i%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (i%3 == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, true);\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (i%40 == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(\"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              if (i%30 == 0) {\n                w.deleteAll();\n              } else if (i%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (i%3 == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, true);\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (i%40 == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b39bf66f51d348a9ab3328df7bcf34da5362586c","date":1357230201,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              if (i%30 == 0) {\n                w.deleteAll();\n              } else if (i%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (i%3 == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, true);\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (i%40 == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08e1fdbfd3312b2871d8bc370b44e679921c0ca7","date":1357240215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                // TODO: deleteAll has bugs when dropping its readers! w.deleteAll();\n                // this is hiding the bugs to stop the jenkins madness!!!!\n                w.deleteDocuments(new MatchAllDocsQuery());\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["119ae5b0966bbb5d6948c7f86207613595764d2e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b671065145b97dc2aa825ac78c86f4a10ae0b46","date":1357243321,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                // TODO: deleteAll has bugs when dropping its readers! w.deleteAll();\n                // this is hiding the bugs to stop the jenkins madness!!!!\n                w.deleteDocuments(new MatchAllDocsQuery());\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  // TODO: more bugs!\n                  // if (random.nextBoolean() && r.maxDoc() > 0) {\n                  //  int docid = random.nextInt(r.maxDoc());\n                  //  w.tryDeleteDocument(r, docid);\n                  //}\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                // TODO: deleteAll has bugs when dropping its readers! w.deleteAll();\n                // this is hiding the bugs to stop the jenkins madness!!!!\n                w.deleteDocuments(new MatchAllDocsQuery());\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                boolean success = false;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  success = true;\n                } finally {\n                  if (success) {\n                    r.close();\n                  } else {\n                    IOUtils.closeWhileHandlingException(r);\n                  }\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["119ae5b0966bbb5d6948c7f86207613595764d2e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"119ae5b0966bbb5d6948c7f86207613595764d2e","date":1357249026,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                // TODO: deleteAll has bugs when dropping its readers! w.deleteAll();\n                // this is hiding the bugs to stop the jenkins madness!!!!\n                w.deleteDocuments(new MatchAllDocsQuery());\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  // TODO: more bugs!\n                  // if (random.nextBoolean() && r.maxDoc() > 0) {\n                  //  int docid = random.nextInt(r.maxDoc());\n                  //  w.tryDeleteDocument(r, docid);\n                  //}\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":["7b671065145b97dc2aa825ac78c86f4a10ae0b46","08e1fdbfd3312b2871d8bc370b44e679921c0ca7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c349a43f2ea69d6473d2f106b096791862a6c8d1","date":1357251193,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random(), new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5e6fb2e60a91ffb7a435aa2b085ecb942dd11446","date":1358780574,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new LongDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedBytesDocValuesField(\"sorteddv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new LongDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedBytesDocValuesField(\"sorteddv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81d695ea56e846db8af5ac4e15826d341ef894e1","date":1361067281,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ddbb72a33557d2b5bc22ee95daf3281c43560502","date":1361334582,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666","date":1381263930,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), when it's\n      // writing liveDocs, this can lead to double-write of\n      // _X_N.del:\n      //dir.setPreventDoubleWrite(false);\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), when it's\n      // writing liveDocs, this can lead to double-write of\n      // _X_N.del:\n      //dir.setPreventDoubleWrite(false);\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), when it's\n      // writing liveDocs, this can lead to double-write of\n      // _X_N.del:\n      //dir.setPreventDoubleWrite(false);\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cd4e13d997cf4fb810398a20a299c2c5a9f6b796","date":1395594336,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), when it's\n      // writing liveDocs, this can lead to double-write of\n      // _X_N.del:\n      //dir.setPreventDoubleWrite(false);\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), when it's\n      // writing liveDocs, this can lead to double-write of\n      // _X_N.del:\n      //dir.setPreventDoubleWrite(false);\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir, adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.shutdown(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.shutdown();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.shutdown();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), when it's\n      // writing liveDocs, this can lead to double-write of\n      // _X_N.del:\n      //dir.setPreventDoubleWrite(false);\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1f3bfdf2fbf9eb7c32953111625b8149f767900","date":1398169177,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.shutdown(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.shutdown();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.shutdown();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST: got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.shutdown(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.shutdown();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.shutdown();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518","date":1398331323,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.shutdown(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.shutdown();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.shutdown();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST: got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.shutdown(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.shutdown();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.shutdown();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          System.out.println(\"TEST: got interrupt\");\n          re.printStackTrace(System.out);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          System.out.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST: got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.shutdown(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.shutdown();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.shutdown();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST: got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST: got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad2a673349939e48652bf304cccf673c3412198f","date":1409585169,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402ad3ddc9da7b70da1b167667a60ece6a1381fb","date":1409656478,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            if (defaultCodecSupportsSortedSet()) {\n              doc.add(sortedSetDVField);\n            }\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":["81d695ea56e846db8af5ac4e15826d341ef894e1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ef28e085d0747a245bb0e34b72c45d7a05c95c0e","date":1409922824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6edb7cc5e3ecbbb0092c60f1aaf66e649adb80a6","date":1410380194,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57dea9cc0cdda318a986edb0250c26cee1e8bb19","date":1410398087,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"431452b6326a9c17ba5bb1e1a6d89e23a8932e73","date":1417113370,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean());\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11c6df42fb3eba174c3ca0d9a5194eaecd893b77","date":1465931757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a","d0ef034a4f10871667ae75181537775ddcf8ade4","431452b6326a9c17ba5bb1e1a6d89e23a8932e73"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // When interrupt arrives in w.close(), this can\n      // lead to double-write of files:\n      dir.setPreventDoubleWrite(false);\n      \n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d77dafd89756a5161d244985903e3487ca109182","date":1548679743,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new RAMDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n\n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n\n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n\n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      MockDirectoryWrapper dir = new MockDirectoryWrapper(random, new ByteBuffersDirectory());\n\n      // open/close slowly sometimes\n      dir.setUseSlowOpenClosers(true);\n      \n      // throttle a little\n      dir.setThrottling(MockDirectoryWrapper.Throttling.SOMETIMES);\n\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              // If interrupt arrives inside here, it's\n              // fine: we will cycle back and the first\n              // thing we do is try to close again,\n              // i.e. we'll never try to open a new writer\n              // until this one successfully closes:\n              // w.rollback();\n              try {\n                w.close();\n              } catch (AlreadyClosedException ace) {\n                // OK\n              }\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random,\n                                                          new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            if (conf.getMergeScheduler() instanceof ConcurrentMergeScheduler) {\n              conf.setMergeScheduler(new SuppressingConcurrentMergeScheduler() {\n                  @Override\n                  protected boolean isOK(Throwable th) {\n                    return th instanceof AlreadyClosedException ||\n                      (th instanceof IllegalStateException && th.getMessage().contains(\"this writer hit an unrecoverable error\"));\n                  }\n                });\n            }\n            //conf.setInfoStream(log);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            Field idField = newStringField(random, \"id\", \"\", Field.Store.NO);\n            Field binaryDVField = new BinaryDocValuesField(\"binarydv\", new BytesRef());\n            Field numericDVField = new NumericDocValuesField(\"numericdv\", 0);\n            Field sortedDVField = new SortedDocValuesField(\"sorteddv\", new BytesRef());\n            Field sortedSetDVField = new SortedSetDocValuesField(\"sortedsetdv\", new BytesRef());\n            doc.add(idField);\n            doc.add(newField(random, \"field\", \"some text contents\", storedTextType));\n            doc.add(binaryDVField);\n            doc.add(numericDVField);\n            doc.add(sortedDVField);\n            doc.add(sortedSetDVField);\n            for(int i=0;i<100;i++) {\n              //log.println(\"\\nTEST: i=\" + i);\n              idField.setStringValue(Integer.toString(i));\n              binaryDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              numericDVField.setLongValue(i);\n              sortedDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              sortedSetDVField.setBytesValue(new BytesRef(idField.stringValue()));\n              int action = random.nextInt(100);\n              if (action == 17) {\n                w.addIndexes(adder);\n              } else if (action%30 == 0) {\n                w.deleteAll();\n              } else if (action%2 == 0) {\n                w.updateDocument(new Term(\"id\", idField.stringValue()), doc);\n              } else {\n                w.addDocument(doc);\n              }\n              if (random.nextInt(3) == 0) {\n                IndexReader r = null;\n                try {\n                  r = DirectoryReader.open(w, random.nextBoolean(), false);\n                  if (random.nextBoolean() && r.maxDoc() > 0) {\n                    int docid = random.nextInt(r.maxDoc());\n                    w.tryDeleteDocument(r, docid);\n                  }\n                } finally {\n                  IOUtils.closeWhileHandlingException(r);\n                }\n              }\n              if (i%10 == 0) {\n                w.commit();\n              }\n              if (random.nextInt(50) == 0) {\n                w.forceMerge(1);\n              }\n            }\n            w.close();\n            w = null;\n            DirectoryReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          // NOTE: important to leave this verbosity/noise\n          // on!!  This test doesn't repro easily so when\n          // Jenkins hits a fail we need to study where the\n          // interrupts struck!\n          log.println(\"TEST thread \" + id + \": got interrupt\");\n          re.printStackTrace(log);\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          log.println(\"thread \" + id + \" FAILED; unexpected exception\");\n          t.printStackTrace(log);\n          listIndexFiles(log, dir);\n          failed = true;\n          break;\n        }\n      }\n\n      if (VERBOSE) {\n        log.println(\"TEST: thread \" + id + \": now finish failed=\" + failed);\n      }\n      if (!failed) {\n        if (VERBOSE) {\n          log.println(\"TEST: thread \" + id + \": now rollback\");\n        }\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n        try {\n          IndexReader r = DirectoryReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          log.println(\"thread \" + id + \": DirectoryReader.open FAILED: unexpected exception\");\n          e.printStackTrace(log);\n          listIndexFiles(log, dir);\n        }\n      }\n      try {\n        IOUtils.close(dir);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n      try {\n        IOUtils.close(adder);\n      } catch (IOException e) {\n        failed = true;\n        throw new RuntimeException(\"thread \" + id, e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a761b207f161726214a84533bf56a78f6c21ff56","c349a43f2ea69d6473d2f106b096791862a6c8d1"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["68496c2200e559fb7802f7575427b7a482659afb"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"f1f3bfdf2fbf9eb7c32953111625b8149f767900":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"479fba77febd29e498fc4a430359e4cf88341da7":["5f24f21e70a092329fc6f920115592dc9529d379"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["d4d69c535930b5cce125cff868d40f6373dc27d4","81d695ea56e846db8af5ac4e15826d341ef894e1"],"b39bf66f51d348a9ab3328df7bcf34da5362586c":["ad4fd10e8a24953e897d3f78bc0a7ee320c624d8"],"81d695ea56e846db8af5ac4e15826d341ef894e1":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"08e1fdbfd3312b2871d8bc370b44e679921c0ca7":["b39bf66f51d348a9ab3328df7bcf34da5362586c"],"0d55763df1c6badbe23b44b735ca86273d27caed":["479fba77febd29e498fc4a430359e4cf88341da7"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"ef28e085d0747a245bb0e34b72c45d7a05c95c0e":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68496c2200e559fb7802f7575427b7a482659afb":["9299079153fd7895bf3cf6835cf7019af2ba89b3","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"57dea9cc0cdda318a986edb0250c26cee1e8bb19":["6edb7cc5e3ecbbb0092c60f1aaf66e649adb80a6"],"5f24f21e70a092329fc6f920115592dc9529d379":["e1e8b3369cb0169630bfadbcf2d16a26260bc967"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"a761b207f161726214a84533bf56a78f6c21ff56":["5f24f21e70a092329fc6f920115592dc9529d379"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["6613659748fe4411a7dcf85266e55db1f95f7315"],"6613659748fe4411a7dcf85266e55db1f95f7315":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"d77dafd89756a5161d244985903e3487ca109182":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["d77dafd89756a5161d244985903e3487ca109182"],"431452b6326a9c17ba5bb1e1a6d89e23a8932e73":["57dea9cc0cdda318a986edb0250c26cee1e8bb19"],"7b671065145b97dc2aa825ac78c86f4a10ae0b46":["08e1fdbfd3312b2871d8bc370b44e679921c0ca7"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"9aec642a2f63c39e7553a5bbb73f38e0f68237f5":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","ad2a673349939e48652bf304cccf673c3412198f"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"6edb7cc5e3ecbbb0092c60f1aaf66e649adb80a6":["ef28e085d0747a245bb0e34b72c45d7a05c95c0e"],"e1e8b3369cb0169630bfadbcf2d16a26260bc967":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f","9aec642a2f63c39e7553a5bbb73f38e0f68237f5"],"ad4fd10e8a24953e897d3f78bc0a7ee320c624d8":["0d55763df1c6badbe23b44b735ca86273d27caed"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["c349a43f2ea69d6473d2f106b096791862a6c8d1","423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["f1f3bfdf2fbf9eb7c32953111625b8149f767900"],"119ae5b0966bbb5d6948c7f86207613595764d2e":["7b671065145b97dc2aa825ac78c86f4a10ae0b46"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["431452b6326a9c17ba5bb1e1a6d89e23a8932e73"],"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["5e6fb2e60a91ffb7a435aa2b085ecb942dd11446"],"ad2a673349939e48652bf304cccf673c3412198f":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"c349a43f2ea69d6473d2f106b096791862a6c8d1":["119ae5b0966bbb5d6948c7f86207613595764d2e"],"5e6fb2e60a91ffb7a435aa2b085ecb942dd11446":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["9299079153fd7895bf3cf6835cf7019af2ba89b3"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["5e6fb2e60a91ffb7a435aa2b085ecb942dd11446"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["d77dafd89756a5161d244985903e3487ca109182","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["402ad3ddc9da7b70da1b167667a60ece6a1381fb","ad2a673349939e48652bf304cccf673c3412198f"],"f1f3bfdf2fbf9eb7c32953111625b8149f767900":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"479fba77febd29e498fc4a430359e4cf88341da7":["0d55763df1c6badbe23b44b735ca86273d27caed"],"ddbb72a33557d2b5bc22ee95daf3281c43560502":["8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666"],"b39bf66f51d348a9ab3328df7bcf34da5362586c":["08e1fdbfd3312b2871d8bc370b44e679921c0ca7"],"81d695ea56e846db8af5ac4e15826d341ef894e1":["ddbb72a33557d2b5bc22ee95daf3281c43560502"],"08e1fdbfd3312b2871d8bc370b44e679921c0ca7":["7b671065145b97dc2aa825ac78c86f4a10ae0b46"],"0d55763df1c6badbe23b44b735ca86273d27caed":["ad4fd10e8a24953e897d3f78bc0a7ee320c624d8"],"e7e8d6f15900ee22ac3cb0a503f15dc952a3580f":["9aec642a2f63c39e7553a5bbb73f38e0f68237f5","e1e8b3369cb0169630bfadbcf2d16a26260bc967"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"ef28e085d0747a245bb0e34b72c45d7a05c95c0e":["6edb7cc5e3ecbbb0092c60f1aaf66e649adb80a6"],"68496c2200e559fb7802f7575427b7a482659afb":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["f1f3bfdf2fbf9eb7c32953111625b8149f767900","e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518"],"57dea9cc0cdda318a986edb0250c26cee1e8bb19":["431452b6326a9c17ba5bb1e1a6d89e23a8932e73"],"5f24f21e70a092329fc6f920115592dc9529d379":["479fba77febd29e498fc4a430359e4cf88341da7","a761b207f161726214a84533bf56a78f6c21ff56"],"8da3c22a3b1a00ae6e2664f3ac0d82cfa3a8f666":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a761b207f161726214a84533bf56a78f6c21ff56":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"d77dafd89756a5161d244985903e3487ca109182":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"431452b6326a9c17ba5bb1e1a6d89e23a8932e73":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"7b671065145b97dc2aa825ac78c86f4a10ae0b46":["119ae5b0966bbb5d6948c7f86207613595764d2e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"402ad3ddc9da7b70da1b167667a60ece6a1381fb":["ef28e085d0747a245bb0e34b72c45d7a05c95c0e"],"9aec642a2f63c39e7553a5bbb73f38e0f68237f5":["e1e8b3369cb0169630bfadbcf2d16a26260bc967"],"6edb7cc5e3ecbbb0092c60f1aaf66e649adb80a6":["57dea9cc0cdda318a986edb0250c26cee1e8bb19"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e1e8b3369cb0169630bfadbcf2d16a26260bc967":["5f24f21e70a092329fc6f920115592dc9529d379"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["ddbb72a33557d2b5bc22ee95daf3281c43560502","81d695ea56e846db8af5ac4e15826d341ef894e1"],"ad4fd10e8a24953e897d3f78bc0a7ee320c624d8":["b39bf66f51d348a9ab3328df7bcf34da5362586c"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"119ae5b0966bbb5d6948c7f86207613595764d2e":["c349a43f2ea69d6473d2f106b096791862a6c8d1"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["e7e8d6f15900ee22ac3cb0a503f15dc952a3580f"],"ad2a673349939e48652bf304cccf673c3412198f":["402ad3ddc9da7b70da1b167667a60ece6a1381fb"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"c349a43f2ea69d6473d2f106b096791862a6c8d1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","d4d69c535930b5cce125cff868d40f6373dc27d4"],"5e6fb2e60a91ffb7a435aa2b085ecb942dd11446":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e0d0750f8e3774f13e9bd9f7f9fcb51f7114d518","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}