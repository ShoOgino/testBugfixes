{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","commits":[{"id":"565296447d99a85df5ca1d36d443e971021e932a","date":1506060060,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_ANGULAR_RESOLUTION && ++iterations < 200);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d874df4c49c3dbad31bb261d8ddd02ffb295d","date":1506091045,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","sourceNew":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_RESOLUTION && ++iterations < 40);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","sourceOld":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_ANGULAR_RESOLUTION && ++iterations < 200);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62f22e14715933c1b1b4535049f6a64173e36068","date":1506122941,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","sourceNew":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","sourceOld":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) > Vector.MINIMUM_RESOLUTION && ++iterations < 40);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","pathOld":"/dev/null","sourceNew":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e4218e96184b4af9d31258a45a87da597ea58ac7","date":1512293271,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","sourceNew":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * inverseScale * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * inverseScale * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","sourceOld":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/PlanetModel#surfacePointOnBearing(GeoPoint,double,double).mjava","sourceNew":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - scaledFlattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (zScaling * inverseScale * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (zScaling * inverseScale * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - scaledFlattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = scaledFlattening / 16.0 * cosSqα * (4.0 + scaledFlattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * scaledFlattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","sourceOld":"  /** Compute new point given original point, a bearing direction, and an adjusted angle (as would be computed by\n   * the surfaceDistance() method above).  The original point can be anywhere on the globe.  The bearing direction\n   * ranges from 0 (due east at the equator) to pi/2 (due north) to pi (due west at the equator) to 3 pi/4 (due south)\n   * to 2 pi.\n   * @param from is the starting point.\n   * @param dist is the adjusted angle.\n   * @param bearing is the direction to proceed.\n   * @return the new point, consistent with the bearing direction and distance.\n   */\n  public GeoPoint surfacePointOnBearing(final GeoPoint from, final double dist, final double bearing) {\n    // Algorithm using Vincenty's formulae (https://en.wikipedia.org/wiki/Vincenty%27s_formulae)\n    // which takes into account that planets may not be spherical.\n    //Code adaptation from http://www.movable-type.co.uk/scripts/latlong-vincenty.html\n\n    double lat = from.getLatitude();\n    double lon = from.getLongitude();\n    double sinα1 = Math.sin(bearing);\n    double cosα1 = Math.cos(bearing);\n\n    double tanU1 = (1.0 - flattening) * Math.tan(lat);\n    double cosU1 = 1.0 / Math.sqrt((1.0 + tanU1 * tanU1));\n    double sinU1 = tanU1 * cosU1;\n\n    double σ1 = Math.atan2(tanU1, cosα1);\n    double sinα = cosU1 * sinα1;\n    double cosSqα = 1.0 - sinα * sinα;\n    double uSq = cosSqα * squareRatio;\n    double A = 1.0 + uSq / 16384.0 * (4096.0 + uSq * (-768.0 + uSq * (320.0 - 175.0 * uSq)));\n    double B = uSq / 1024.0 * (256.0 + uSq * (-128.0 + uSq * (74.0 - 47.0 * uSq)));\n\n    double cos2σM;\n    double sinσ;\n    double cosσ;\n    double Δσ;\n\n    double σ = dist / (c * inverseScale * A);\n    double σʹ;\n    double iterations = 0;\n    do {\n      cos2σM = Math.cos(2.0 * σ1 + σ);\n      sinσ = Math.sin(σ);\n      cosσ = Math.cos(σ);\n      Δσ = B * sinσ * (cos2σM + B / 4.0 * (cosσ * (-1.0 + 2.0 * cos2σM * cos2σM) -\n          B / 6.0 * cos2σM * (-3.0 + 4.0 * sinσ * sinσ) * (-3.0 + 4.0 * cos2σM * cos2σM)));\n      σʹ = σ;\n      σ = dist / (c * inverseScale * A) + Δσ;\n    } while (Math.abs(σ - σʹ) >= Vector.MINIMUM_RESOLUTION && ++iterations < 100);\n    double x = sinU1 * sinσ - cosU1 * cosσ * cosα1;\n    double φ2 = Math.atan2(sinU1 * cosσ + cosU1 * sinσ * cosα1, (1.0 - flattening) * Math.sqrt(sinα * sinα + x * x));\n    double λ = Math.atan2(sinσ * sinα1, cosU1 * cosσ - sinU1 * sinσ * cosα1);\n    double C = flattening / 16.0 * cosSqα * (4.0 + flattening * (4.0 - 3.0 * cosSqα));\n    double L = λ - (1.0 - C) * flattening * sinα *\n        (σ + C * sinσ * (cos2σM + C * cosσ * (-1.0 + 2.0 * cos2σM * cos2σM)));\n    double λ2 = (lon + L + 3.0 * Math.PI) % (2.0 * Math.PI) - Math.PI;  // normalise to -180..+180\n\n    return new GeoPoint(this, φ2, λ2);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"302d874df4c49c3dbad31bb261d8ddd02ffb295d":["565296447d99a85df5ca1d36d443e971021e932a"],"e4218e96184b4af9d31258a45a87da597ea58ac7":["62f22e14715933c1b1b4535049f6a64173e36068"],"565296447d99a85df5ca1d36d443e971021e932a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","62f22e14715933c1b1b4535049f6a64173e36068"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"62f22e14715933c1b1b4535049f6a64173e36068":["302d874df4c49c3dbad31bb261d8ddd02ffb295d"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["e4218e96184b4af9d31258a45a87da597ea58ac7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"]},"commit2Childs":{"302d874df4c49c3dbad31bb261d8ddd02ffb295d":["62f22e14715933c1b1b4535049f6a64173e36068"],"565296447d99a85df5ca1d36d443e971021e932a":["302d874df4c49c3dbad31bb261d8ddd02ffb295d"],"e4218e96184b4af9d31258a45a87da597ea58ac7":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["565296447d99a85df5ca1d36d443e971021e932a","6240b74b884c5587f2a4062dd27d6c32bf228889"],"62f22e14715933c1b1b4535049f6a64173e36068":["e4218e96184b4af9d31258a45a87da597ea58ac7","6240b74b884c5587f2a4062dd27d6c32bf228889"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}