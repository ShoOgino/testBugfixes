{"path":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","commits":[{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestDimensionalRangeQuery#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestPointRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestDimensionalRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new DimensionalBinaryField(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new DimensionalRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestPointRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"34d6426cef006e0c3625cabe7a7ec1c2b08bc501","date":1454683374,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestPointRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestPointRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = noVirusChecker(newFSDirectory(createTempDir(\"TestPointRangeQuery\")));\n    } else {\n      dir = getDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3104a6ba367dfb690806b227c5ef17c42c6107b","date":1456265035,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7f36bbdca4e65638f33c3e8f2fbe46a64dd06cd5","date":1456265720,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22793feecc51e10824f76d03a09048482816dba5","date":1456267148,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5296efc4b319f5647b606629c093a94b23692c6","date":1456267155,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","date":1456306182,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = new PointRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","date":1456321728,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    // int numThreads = TestUtil.nextInt(random(), 2, 5);\n    int numThreads = 1;\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"12bfdc932307442b651432f92845942f9041ace8","date":1456860728,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":["1800b996d8677670482a071dcb7a48b08c423ace"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","date":1456936072,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":["d3104a6ba367dfb690806b227c5ef17c42c6107b","1904709ea0185dc04e3d77ea01c79e909caf2796","12bfdc932307442b651432f92845942f9041ace8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              boolean[] includeUpper = new boolean[numDims];\n              boolean[] includeLower = new boolean[numDims];\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                if (random().nextInt(5) != 1) {\n                  lower[dim] = new byte[bytesPerDim];\n                  random().nextBytes(lower[dim]);\n                } else {\n                  // open-ended on the lower bound\n                }\n                if (random().nextInt(5) != 1) {\n                  upper[dim] = new byte[bytesPerDim];\n                  random().nextBytes(upper[dim]);\n                } else {\n                  // open-ended on the upper bound\n                }\n\n                if (lower[dim] != null && upper[dim] != null && NumericUtils.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n\n                includeLower[dim] = random().nextBoolean();\n                includeUpper[dim] = random().nextBoolean();\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" (inclusive?=\" + includeLower[dim] + \") TO \" +\n                                     bytesToString(upper[dim]) +\n                                     \" (inclusive?=\" + includeUpper[dim] + \")\");\n                }\n              }\n\n              Query query = BinaryPoint.newMultiRangeQuery(\"value\", lower, includeLower, upper, includeUpper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, includeLower, upper, includeUpper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" (inclusive?=\" + includeLower[dim] + \") TO \" + bytesToString(upper[dim]) + \" (inclusive?=\" + includeUpper[dim] + \")\");\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                int id = (int) docIDToID.get(docID);\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public boolean needsScores() {\n                    return false;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (FutureArrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (StringHelper.compare(bytesPerDim, lower[dim], 0, upper[dim], 0) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbf46f22bc7fee423e8a0b7e50148c91b57c9d6e","date":1547471565,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for (int ord = 0; ord < numValues; ord++) {\n      if (ord % 1000 == 0) {\n        if (VERBOSE) {\n          System.out.println(\"Adding docs: \" + ord);\n        }\n      }\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for (int i = 0; i < numThreads; i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (FutureArrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for (int ord = 0; ord < numValues; ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for(int ord=0;ord<numValues;ord++) {\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (FutureArrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for(int ord=0;ord<numValues;ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5e2673c41503db59fb58c2e183343e434cf4204e","date":1547550135,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for (int ord = 0; ord < numValues; ord++) {\n      if (ord % 1000 == 0) {\n        if (VERBOSE) {\n          System.out.println(\"Adding docs: \" + ord);\n        }\n      }\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for (int i = 0; i < numThreads; i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (FutureArrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for (int ord = 0; ord < numValues; ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for (int ord = 0; ord < numValues; ord++) {\n      if (ord % 1000 == 0) {\n        if (VERBOSE) {\n          System.out.println(\"Adding docs: \" + ord);\n        }\n      }\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = w.getReader();\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for (int i = 0; i < numThreads; i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (FutureArrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for (int ord = 0; ord < numValues; ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":["1904709ea0185dc04e3d77ea01c79e909caf2796"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestPointQueries#verifyBinary(byte[][][],int[],int).mjava","sourceNew":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for (int ord = 0; ord < numValues; ord++) {\n      if (ord % 1000 == 0) {\n        if (VERBOSE) {\n          System.out.println(\"Adding docs: \" + ord);\n        }\n      }\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for (int i = 0; i < numThreads; i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (Arrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for (int ord = 0; ord < numValues; ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  // verify for byte[][] values\n  private void verifyBinary(byte[][][] docValues, int[] ids, int numBytesPerDim) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n\n    int numDims = docValues[0].length;\n    int bytesPerDim = docValues[0][0].length;\n\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < docValues.length/100) {\n      iwc.setMaxBufferedDocs(docValues.length/100);\n    }\n    iwc.setCodec(getCodec());\n\n    Directory dir;\n    if (docValues.length > 100000) {\n      dir = newFSDirectory(createTempDir(\"TestPointQueries\"));\n    } else {\n      dir = newDirectory();\n    }\n\n    IndexWriter w = new IndexWriter(dir, iwc);\n\n    int numValues = docValues.length;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numValues=\" + numValues + \" numDims=\" + numDims + \" numBytesPerDim=\" + numBytesPerDim);\n    }\n\n    int missingPct = random().nextInt(100);\n    int deletedPct = random().nextInt(100);\n    if (VERBOSE) {\n      System.out.println(\"  missingPct=\" + missingPct);\n      System.out.println(\"  deletedPct=\" + deletedPct);\n    }\n\n    BitSet missing = new BitSet();\n    BitSet deleted = new BitSet();\n\n    Document doc = null;\n    int lastID = -1;\n\n    for (int ord = 0; ord < numValues; ord++) {\n      if (ord % 1000 == 0) {\n        if (VERBOSE) {\n          System.out.println(\"Adding docs: \" + ord);\n        }\n      }\n      int id = ids[ord];\n      if (id != lastID) {\n        if (random().nextInt(100) < missingPct) {\n          missing.set(id);\n          if (VERBOSE) {\n            System.out.println(\"  missing id=\" + id);\n          }\n        }\n\n        if (doc != null) {\n          w.addDocument(doc);\n          if (random().nextInt(100) < deletedPct) {\n            int idToDelete = random().nextInt(id);\n            w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n            deleted.set(idToDelete);\n            if (VERBOSE) {\n              System.out.println(\"  delete id=\" + idToDelete);\n            }\n          }\n        }\n\n        doc = new Document();\n        doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n        doc.add(new NumericDocValuesField(\"id\", id));\n        lastID = id;\n      }\n\n      if (missing.get(id) == false) {\n        doc.add(new BinaryPoint(\"value\", docValues[ord]));\n        if (VERBOSE) {\n          System.out.println(\"id=\" + id);\n          for(int dim=0;dim<numDims;dim++) {\n            System.out.println(\"  dim=\" + dim + \" value=\" + bytesToString(docValues[ord][dim]));\n          }\n        }\n      }\n    }\n\n    w.addDocument(doc);\n\n    if (random().nextBoolean()) {\n      if (VERBOSE) {\n        System.out.println(\"  forceMerge(1)\");\n      }\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    IndexSearcher s = newSearcher(r, false);\n\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: use \" + numThreads + \" query threads; searcher=\" + s);\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(100);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for (int i = 0; i < numThreads; i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              byte[][] lower = new byte[numDims][];\n              byte[][] upper = new byte[numDims][];\n              for(int dim=0;dim<numDims;dim++) {\n                lower[dim] = new byte[bytesPerDim];\n                random().nextBytes(lower[dim]);\n\n                upper[dim] = new byte[bytesPerDim];\n                random().nextBytes(upper[dim]);\n\n                if (FutureArrays.compareUnsigned(lower[dim], 0, bytesPerDim, upper[dim], 0, bytesPerDim) > 0) {\n                  byte[] x = lower[dim];\n                  lower[dim] = upper[dim];\n                  upper[dim] = x;\n                }\n              }\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter);\n                for(int dim=0;dim<numDims;dim++) {\n                  System.out.println(\"  dim=\" + dim + \" \" +\n                                     bytesToString(lower[dim]) +\n                                     \" TO \" +\n                                     bytesToString(upper[dim]));\n                }\n              }\n\n              Query query = BinaryPoint.newRangeQuery(\"value\", lower, upper);\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  using query: \" + query);\n              }\n\n              final BitSet hits = new BitSet();\n              s.search(query, new SimpleCollector() {\n\n                  private int docBase;\n\n                  @Override\n                  public ScoreMode scoreMode() {\n                    return ScoreMode.COMPLETE_NO_SCORES;\n                  }\n\n                  @Override\n                  protected void doSetNextReader(LeafReaderContext context) throws IOException {\n                    docBase = context.docBase;\n                  }\n\n                  @Override\n                  public void collect(int doc) {\n                    hits.set(docBase+doc);\n                  }\n                });\n\n              if (VERBOSE) {\n                System.out.println(Thread.currentThread().getName() + \":  hitCount: \" + hits.cardinality());\n              }\n\n              BitSet expected = new BitSet();\n              for (int ord = 0; ord < numValues; ord++) {\n                int id = ids[ord];\n                if (missing.get(id) == false && deleted.get(id) == false && matches(bytesPerDim, lower, upper, docValues[ord])) {\n                  expected.set(id);\n                }\n              }\n\n              NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n              int failCount = 0;\n              for(int docID=0;docID<r.maxDoc();docID++) {\n                assertEquals(docID, docIDToID.nextDoc());\n                int id = (int) docIDToID.longValue();\n                if (hits.get(docID) != expected.get(id)) {\n                  System.out.println(\"FAIL: iter=\" + iter + \" id=\" + id + \" docID=\" + docID + \" expected=\" + expected.get(id) + \" but got \" + hits.get(docID) + \" deleted?=\" + deleted.get(id) + \" missing?=\" + missing.get(id));\n                  for(int dim=0;dim<numDims;dim++) {\n                    System.out.println(\"  dim=\" + dim + \" range: \" + bytesToString(lower[dim]) + \" TO \" + bytesToString(upper[dim]));\n                    failCount++;\n                  }\n                }\n              }\n              if (failCount != 0) {\n                fail(failCount + \" hits were wrong\");\n              }\n            }\n          }\n        };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n\n    startingGun.countDown();\n    for (Thread thread : threads) {\n      thread.join();\n    }\n\n    IOUtils.close(r, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5a207d19eac354d649c3f0e2cce070017c78125e":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","b470f36a9372c97283360b1304eacbde22df6c0d"],"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6":["5a207d19eac354d649c3f0e2cce070017c78125e","a5296efc4b319f5647b606629c093a94b23692c6"],"5e2673c41503db59fb58c2e183343e434cf4204e":["dbf46f22bc7fee423e8a0b7e50148c91b57c9d6e"],"c422e924212367b334b4938f1fd3e44438e88c40":["adc9dc8ef0ce617b940a039fd12f79e8b098cc7f","1800b996d8677670482a071dcb7a48b08c423ace"],"12bfdc932307442b651432f92845942f9041ace8":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"7f36bbdca4e65638f33c3e8f2fbe46a64dd06cd5":["5a207d19eac354d649c3f0e2cce070017c78125e","d3104a6ba367dfb690806b227c5ef17c42c6107b"],"a5296efc4b319f5647b606629c093a94b23692c6":["22793feecc51e10824f76d03a09048482816dba5","d3104a6ba367dfb690806b227c5ef17c42c6107b"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"22793feecc51e10824f76d03a09048482816dba5":["5a207d19eac354d649c3f0e2cce070017c78125e"],"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6":["7f36bbdca4e65638f33c3e8f2fbe46a64dd06cd5","1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","b470f36a9372c97283360b1304eacbde22df6c0d"],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["12bfdc932307442b651432f92845942f9041ace8"],"1800b996d8677670482a071dcb7a48b08c423ace":["adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"417142ff08fda9cf0b72d5133e63097a166c6458":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","9fc47cb7b4346802411bb432f501ed0673d7119e"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["5e2673c41503db59fb58c2e183343e434cf4204e"],"d3104a6ba367dfb690806b227c5ef17c42c6107b":["5a207d19eac354d649c3f0e2cce070017c78125e"],"b470f36a9372c97283360b1304eacbde22df6c0d":["cab7a79353f33d1a94cd307bf33aa5148601ebe6","34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","c422e924212367b334b4938f1fd3e44438e88c40"],"dbf46f22bc7fee423e8a0b7e50148c91b57c9d6e":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b88a121b875f9ae2ac50f85cf46dcb680f126357"]},"commit2Childs":{"5a207d19eac354d649c3f0e2cce070017c78125e":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6","7f36bbdca4e65638f33c3e8f2fbe46a64dd06cd5","22793feecc51e10824f76d03a09048482816dba5","d3104a6ba367dfb690806b227c5ef17c42c6107b"],"1ff4a3d0540c1b0f828f19adccd01d1b33c996a6":["12bfdc932307442b651432f92845942f9041ace8","1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"5e2673c41503db59fb58c2e183343e434cf4204e":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"c422e924212367b334b4938f1fd3e44438e88c40":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"12bfdc932307442b651432f92845942f9041ace8":["adc9dc8ef0ce617b940a039fd12f79e8b098cc7f"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["dbf46f22bc7fee423e8a0b7e50148c91b57c9d6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["9fc47cb7b4346802411bb432f501ed0673d7119e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","417142ff08fda9cf0b72d5133e63097a166c6458"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["34d6426cef006e0c3625cabe7a7ec1c2b08bc501"],"7f36bbdca4e65638f33c3e8f2fbe46a64dd06cd5":["1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6"],"a5296efc4b319f5647b606629c093a94b23692c6":["1ff4a3d0540c1b0f828f19adccd01d1b33c996a6"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"22793feecc51e10824f76d03a09048482816dba5":["a5296efc4b319f5647b606629c093a94b23692c6"],"1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6":[],"34d6426cef006e0c3625cabe7a7ec1c2b08bc501":["b470f36a9372c97283360b1304eacbde22df6c0d"],"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["5a207d19eac354d649c3f0e2cce070017c78125e","6bfe104fc023fadc9e709f8d17403d2cc61133fe","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"adc9dc8ef0ce617b940a039fd12f79e8b098cc7f":["c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d3104a6ba367dfb690806b227c5ef17c42c6107b":["7f36bbdca4e65638f33c3e8f2fbe46a64dd06cd5","a5296efc4b319f5647b606629c093a94b23692c6"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"dbf46f22bc7fee423e8a0b7e50148c91b57c9d6e":["5e2673c41503db59fb58c2e183343e434cf4204e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1af4bde3de13aa03ab458c2b7adb1c088fcf7ad6","1e6acbaae7af722f17204ceccf0f7db5753eccf3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}