{"path":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","commits":[{"id":"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3","date":1556831715,"type":1,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb","date":1561824429,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          SolrParams params = new ModifiableSolrParams();\n          try (SolrQueryRequest request = new LocalSolrQueryRequest(searcher.getCore(), params)) {\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (SyntaxError e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new IOException(\"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          LocalSolrQueryRequest request = null;\n          try {\n            SolrParams params = new ModifiableSolrParams();\n            request = new LocalSolrQueryRequest(searcher.getCore(), params);\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (Exception e) {\n            throw new IOException(e);\n          } finally {\n            request.close();\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new IOException(\"64 bit numeric collapse fields are not supported\");\n        }\n        \n      }\n    }\n\n","bugFix":["0325de99180d346d61d36938843a5c8451fe26ae","8ced52befdc8d88d90766aadbaac496f3fd0e4ee"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ece7e3f03c890461bce71fb45142b75807c28a4e","date":1583713564,"type":3,"author":"Joel Bernstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          SolrParams params = new ModifiableSolrParams();\n          try (SolrQueryRequest request = new LocalSolrQueryRequest(searcher.getCore(), params)) {\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (SyntaxError e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs, searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs, searcher);\n\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          SolrParams params = new ModifiableSolrParams();\n          try (SolrQueryRequest request = new LocalSolrQueryRequest(searcher.getCore(), params)) {\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (SyntaxError e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs);\n\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3575e61fd7df2bbcce8b977a23d3d67aa423ce62","date":1586507050,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/CollapsingQParserPlugin.CollectorFactory#getCollector(String,GroupHeadSelector,SortSpec,int,String,boolean,boolean,int,IntIntHashMap,SolrIndexSearcher).mjava","sourceNew":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          SolrParams params = new ModifiableSolrParams();\n          try (SolrQueryRequest request = new LocalSolrQueryRequest(searcher.getCore(), params)) {\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (SyntaxError e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs, searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs, searcher);\n\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n\n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n\n      }\n    }\n\n","sourceOld":"    public DelegatingCollector getCollector(String collapseField,\n                                            GroupHeadSelector groupHeadSelector,\n                                            SortSpec sortSpec,\n                                            int nullPolicy,\n                                            String hint,\n                                            boolean needsScores4Collapsing,\n                                            boolean needsScores,\n                                            int size,\n                                            IntIntHashMap boostDocs,\n                                            SolrIndexSearcher searcher) throws IOException {\n\n      DocValuesProducer docValuesProducer = null;\n      FunctionQuery funcQuery = null;\n\n      FieldType collapseFieldType = searcher.getSchema().getField(collapseField).getType();\n      String defaultValue = searcher.getSchema().getField(collapseField).getDefaultValue();\n\n      if(collapseFieldType instanceof StrField) {\n        if(HINT_TOP_FC.equals(hint)) {\n          @SuppressWarnings(\"resource\")\n          final LeafReader uninvertingReader = getTopFieldCacheReader(searcher, collapseField);\n\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return uninvertingReader.getSortedDocValues(collapseField);\n              }\n            };\n        } else {\n          docValuesProducer = new EmptyDocValuesProducer() {\n              @Override\n              public SortedDocValues getSorted(FieldInfo ignored) throws IOException {\n                return DocValues.getSorted(searcher.getSlowAtomicReader(), collapseField);\n              }\n            };\n        }\n      } else {\n        if(HINT_TOP_FC.equals(hint)) {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"top_fc hint is only supported when collapsing on String Fields\");\n        }\n      }\n\n      FieldType minMaxFieldType = null;\n      if (GroupHeadSelectorType.MIN_MAX.contains(groupHeadSelector.type)) {\n        final String text = groupHeadSelector.selectorText;\n        if (text.indexOf(\"(\") == -1) {\n          minMaxFieldType = searcher.getSchema().getField(text).getType();\n        } else {\n          SolrParams params = new ModifiableSolrParams();\n          try (SolrQueryRequest request = new LocalSolrQueryRequest(searcher.getCore(), params)) {\n            FunctionQParser functionQParser = new FunctionQParser(text, null, null,request);\n            funcQuery = (FunctionQuery)functionQParser.parse();\n          } catch (SyntaxError e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n        }\n      }\n\n      int maxDoc = searcher.maxDoc();\n      int leafCount = searcher.getTopReaderContext().leaves().size();\n\n      if (GroupHeadSelectorType.SCORE.equals(groupHeadSelector.type)) {\n        \n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdScoreCollector(maxDoc, leafCount, docValuesProducer, nullPolicy, boostDocs, searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntScoreCollector(maxDoc, leafCount, nullValue, nullPolicy, size, collapseField, boostDocs, searcher);\n\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      } else { // min, max, sort, etc.. something other then just \"score\"\n\n        if (collapseFieldType instanceof StrField) {\n\n          return new OrdFieldValueCollector(maxDoc,\n                                            leafCount,\n                                            docValuesProducer,\n                                            nullPolicy,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n\n        } else if (isNumericCollapsible(collapseFieldType)) {\n\n          int nullValue = 0;\n\n          // must be non-null at this point\n          if (collapseFieldType.getNumberType().equals(NumberType.FLOAT)) {\n            if (defaultValue != null) {\n              nullValue = Float.floatToIntBits(Float.parseFloat(defaultValue));\n            } else {\n              nullValue = Float.floatToIntBits(0.0f);\n            }\n          } else {\n            if (defaultValue != null) {\n              nullValue = Integer.parseInt(defaultValue);\n            }\n          }\n\n          return new IntFieldValueCollector(maxDoc,\n                                            size,\n                                            leafCount,\n                                            nullValue,\n                                            nullPolicy,\n                                            collapseField,\n                                            groupHeadSelector,\n                                            sortSpec,\n                                            needsScores4Collapsing,\n                                            needsScores,\n                                            minMaxFieldType,\n                                            boostDocs,\n                                            funcQuery,\n                                            searcher);\n        } else {\n          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n              \"Collapsing field should be of either String, Int or Float type\");\n        }\n        \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["ece7e3f03c890461bce71fb45142b75807c28a4e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ece7e3f03c890461bce71fb45142b75807c28a4e":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62"]},"commit2Childs":{"432fdfa612cbca5b4cf9125a2c6aa055cd53cadb":["ece7e3f03c890461bce71fb45142b75807c28a4e"],"3575e61fd7df2bbcce8b977a23d3d67aa423ce62":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3"],"446ec69a32a7e8cb8bf6eb8be693e96ab5f5a0d3":["432fdfa612cbca5b4cf9125a2c6aa055cd53cadb"],"ece7e3f03c890461bce71fb45142b75807c28a4e":["3575e61fd7df2bbcce8b977a23d3d67aa423ce62"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}