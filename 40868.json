{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","commits":[{"id":"fa76b98015a97f0eca94f0f11fd1b6975838c3ee","date":1461000501,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"99b0a9e4d18bb364d2546e5230cc61abcd2d366b","date":1461241852,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      throw new IllegalStateException(\"Ending edge buffer had only \"+edgeBuffer.size()+\" edges\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7fe5373303e11ed8f999dbf1e4017b39a551dd92","date":1521903795,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    // It is possible that the polygon is degenerate and all points are colinear.  If that's the case, a concave polygon cannot be produced,\n    // in which case trying to construct it will generate IllegalArgumentExceptions here. \n    try {\n      if (testPoint != null && holes != null && holes.size() > 0) {\n        // No holes, for test\n        final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n        if (testPolygon.isWithin(testPoint)) {\n          return false;\n        }\n      }\n      \n      final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n      if (testPoint != null && (holes == null || holes.size() == 0)) {\n        if (realPolygon.isWithin(testPoint)) {\n          return false;\n        }\n      }\n      \n      rval.addShape(realPolygon);\n      return true;\n    } catch (IllegalArgumentException e) {\n      final StringBuilder sb = new StringBuilder(\"Could not construct GeoConcavePolygon due to colinearity of points: \");\n      for (final GeoPoint point : points) {\n        sb.append(\" \").append(point.toString());\n      }\n      throw new IllegalArgumentException(sb.toString(), e);\n    }\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n    \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ef3779f3001aaf18181e07c9791e22c0adc6717","date":1521963968,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    // Since we attempt to prevent the addition of any edge that shows up as colinear, and we filter out colinear edge parts\n    // beforehand, it isn't possible to have a colinear edge at this point.\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n      \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n      \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    // It is possible that the polygon is degenerate and all points are colinear.  If that's the case, a concave polygon cannot be produced,\n    // in which case trying to construct it will generate IllegalArgumentExceptions here. \n    try {\n      if (testPoint != null && holes != null && holes.size() > 0) {\n        // No holes, for test\n        final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n        if (testPolygon.isWithin(testPoint)) {\n          return false;\n        }\n      }\n      \n      final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n      if (testPoint != null && (holes == null || holes.size() == 0)) {\n        if (realPolygon.isWithin(testPoint)) {\n          return false;\n        }\n      }\n      \n      rval.addShape(realPolygon);\n      return true;\n    } catch (IllegalArgumentException e) {\n      final StringBuilder sb = new StringBuilder(\"Could not construct GeoConcavePolygon due to colinearity of points: \");\n      for (final GeoPoint point : points) {\n        sb.append(\" \").append(point.toString());\n      }\n      throw new IllegalArgumentException(sb.toString(), e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["0384fe767a50d9d16907ca6924a3227c24a5c98c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0384fe767a50d9d16907ca6924a3227c24a5c98c","date":1522059634,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#makeConcavePolygon(PlanetModel,GeoCompositePolygon,MutableBoolean,EdgeBuffer,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    try {\n      if (testPoint != null && holes != null && holes.size() > 0) {\n        // No holes, for test\n        final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n        if (testPolygon.isWithin(testPoint)) {\n          return false;\n        }\n      }\n        \n      final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n      if (testPoint != null && (holes == null || holes.size() == 0)) {\n        if (realPolygon.isWithin(testPoint)) {\n          return false;\n        }\n      }\n        \n      rval.addShape(realPolygon);\n      return true;\n    } catch (IllegalArgumentException e) {\n      throw new TileException(e.getMessage());\n    }\n  }\n\n","sourceOld":"  /** Look for a concave polygon in the remainder of the edgebuffer.\n   * By this point, if there are any edges in the edgebuffer, they represent a concave polygon.\n   * @param planetModel is the planet model.\n   * @param rval is the composite polygon we're building.\n   * @param seenConcave is true if we've already seen a concave polygon.\n   * @param edgeBuffer is the edge buffer.\n   * @param holes is the optional list of holes.\n   * @param testPoint is the optional test point.\n   * @return true unless the testPoint caused failure.\n   */\n  private static boolean makeConcavePolygon(final PlanetModel planetModel,\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final EdgeBuffer edgeBuffer,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n      \n    if (edgeBuffer.size() == 0) {\n      return true;\n    }\n    \n    if (seenConcave.value) {\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n\n    seenConcave.value = true;\n    \n    // If there are less than three edges, something got messed up somehow.  Don't know how this\n    // can happen but check.\n    if (edgeBuffer.size() < 3) {\n      // Linear...\n      // Here we can emit GeoWorld, but probably this means we had a broken poly to start with.\n      throw new IllegalArgumentException(\"Illegal polygon; polygon edges intersect each other\");\n    }\n    \n    // Create the list of points\n    final List<GeoPoint> points = new ArrayList<GeoPoint>(edgeBuffer.size());\n    final BitSet internalEdges = new BitSet(edgeBuffer.size()-1);\n\n    //System.out.println(\"Concave polygon points:\");\n    Edge edge = edgeBuffer.pickOne();\n    boolean isInternal = false;\n    for (int i = 0; i < edgeBuffer.size(); i++) {\n      //System.out.println(\" \"+edge.plane+\": \"+edge.startPoint+\"->\"+edge.endPoint+\"; previous? \"+(edge.plane.isWithin(edgeBuffer.getPrevious(edge).startPoint)?\"in\":\"out\")+\" next? \"+(edge.plane.isWithin(edgeBuffer.getNext(edge).endPoint)?\"in\":\"out\"));\n      points.add(edge.startPoint);\n      if (i < edgeBuffer.size() - 1) {\n        internalEdges.set(i, edge.isInternal);\n      } else {\n        isInternal = edge.isInternal;\n      }\n      edge = edgeBuffer.getNext(edge);\n    }\n    \n    // Since we attempt to prevent the addition of any edge that shows up as colinear, and we filter out colinear edge parts\n    // beforehand, it isn't possible to have a colinear edge at this point.\n    if (testPoint != null && holes != null && holes.size() > 0) {\n      // No holes, for test\n      final GeoPolygon testPolygon = new GeoConcavePolygon(planetModel, points, null, internalEdges, isInternal);\n      if (testPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n      \n    final GeoPolygon realPolygon = new GeoConcavePolygon(planetModel, points, holes, internalEdges, isInternal);\n    if (testPoint != null && (holes == null || holes.size() == 0)) {\n      if (realPolygon.isWithin(testPoint)) {\n        return false;\n      }\n    }\n      \n    rval.addShape(realPolygon);\n    return true;\n  }\n\n","bugFix":["0ef3779f3001aaf18181e07c9791e22c0adc6717","40aa98241c87d86a0077beb8023713d93a0becfe"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7fe5373303e11ed8f999dbf1e4017b39a551dd92":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"0ef3779f3001aaf18181e07c9791e22c0adc6717":["7fe5373303e11ed8f999dbf1e4017b39a551dd92"],"0384fe767a50d9d16907ca6924a3227c24a5c98c":["0ef3779f3001aaf18181e07c9791e22c0adc6717"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0384fe767a50d9d16907ca6924a3227c24a5c98c"]},"commit2Childs":{"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["99b0a9e4d18bb364d2546e5230cc61abcd2d366b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"7fe5373303e11ed8f999dbf1e4017b39a551dd92":["0ef3779f3001aaf18181e07c9791e22c0adc6717"],"0ef3779f3001aaf18181e07c9791e22c0adc6717":["0384fe767a50d9d16907ca6924a3227c24a5c98c"],"0384fe767a50d9d16907ca6924a3227c24a5c98c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"99b0a9e4d18bb364d2546e5230cc61abcd2d366b":["7fe5373303e11ed8f999dbf1e4017b39a551dd92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}