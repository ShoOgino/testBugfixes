{"path":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","commits":[{"id":"c5ce7c704ca874aa623a99f2669737b52ec71cfc","date":1528728510,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @return Built Lucene document\n\n   */\n  public static Document toDocument( SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate )\n  {\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":0,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":0,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7b5b9bd55a953275a0efc3c5272ed76129541fb","date":1546921668,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          v = ByteArrayUtf8CharSequence.convertCharSeq(v);\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d9f201f4a83c0b998ddd639fb08a61da2313bfa","date":1547001881,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          v = ByteArrayUtf8CharSequence.convertCharSeq(v);\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"57273019d2938b9b30faae55f6983a2e71a56ec5","date":1550480608,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add default fields if this document is to be used for\n    // in-place updates, since this validation and population of default fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f47793eb80fc739be7036084303ca062ad7aa87d","date":1550661558,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstRawValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.getRawIterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        for( Object v : field ) {\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":["c5ce7c704ca874aa623a99f2669737b52ec71cfc","415bbbe7da8065dd3c477bdc3c703c6425622998"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5abd2ff03128d48bc2a44d2a17a11af87ce58b61","date":1566773837,"type":3,"author":"Chris Troullis","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstRawValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.getRawIterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstRawValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.getRawIterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof String && cf.getMaxChars() > 0 ) {\n                  val = cf.getLimitedValue((String)val);\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3665b66adafb1514bba04cd1d5c477fcaa93d592","date":1576153597,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.iterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstRawValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.getRawIterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"df724d84dab24a0cc54bec95a8680867adc7f171","date":1576156608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.iterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstRawValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.getRawIterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/DocumentBuilder#toDocument(SolrInputDocument,IndexSchema,boolean,boolean).mjava","sourceNew":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        @SuppressWarnings({\"rawtypes\"})\n        Iterator it = field.iterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","sourceOld":"  /**\n   * Convert a SolrInputDocument to a lucene Document.\n   * \n   * This function should go elsewhere.  This builds the Document without an\n   * extra Map&lt;&gt; checking for multiple values.  For more discussion, see:\n   * http://www.nabble.com/Re%3A-svn-commit%3A-r547493---in--lucene-solr-trunk%3A-.--src-java-org-apache-solr-common--src-java-org-apache-solr-schema--src-java-org-apache-solr-update--src-test-org-apache-solr-common--tf3931539.html\n   * \n   * TODO: /!\\ NOTE /!\\ This semantics of this function are still in flux.  \n   * Something somewhere needs to be able to fill up a SolrDocument from\n   * a lucene document - this is one place that may happen.  It may also be\n   * moved to an independent function\n   * \n   * @since solr 1.3\n   * \n   * @param doc SolrInputDocument from which the document has to be built\n   * @param schema Schema instance\n   * @param forInPlaceUpdate Whether the output document would be used for an in-place update or not. When this is true,\n   *        default fields values and copy fields targets are not populated.\n   * @param ignoreNestedDocs if nested child documents should be ignored.  If false then an exception will be thrown.\n   * @return Built Lucene document\n   */\n  public static Document toDocument(SolrInputDocument doc, IndexSchema schema, boolean forInPlaceUpdate, boolean ignoreNestedDocs) {\n    if (!ignoreNestedDocs && doc.hasChildDocuments()) {\n      throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n    }\n\n    final SchemaField uniqueKeyField = schema.getUniqueKeyField();\n    final String uniqueKeyFieldName = null == uniqueKeyField ? null : uniqueKeyField.getName();\n    \n    Document out = new Document();\n    Set<String> usedFields = Sets.newHashSet();\n    \n    // Load fields from SolrDocument to Document\n    for( SolrInputField field : doc ) {\n\n      if (field.getFirstValue() instanceof SolrDocumentBase) {\n        if (ignoreNestedDocs) {\n          continue;\n        }\n        throw unexpectedNestedDocException(schema, forInPlaceUpdate);\n      }\n\n      String name = field.getName();\n      SchemaField sfield = schema.getFieldOrNull(name);\n      boolean used = false;\n      \n      // Make sure it has the correct number\n      if( sfield!=null && !sfield.multiValued() && field.getValueCount() > 1 ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"multiple values encountered for non multiValued field \" + \n              sfield.getName() + \": \" +field.getValue() );\n      }\n\n      List<CopyField> copyFields = schema.getCopyFieldsList(name);\n      if( copyFields.size() == 0 ) copyFields = null;\n\n      // load each field value\n      boolean hasField = false;\n      try {\n        Iterator it = field.iterator();\n        while (it.hasNext()) {\n          Object v = it.next();\n          if( v == null ) {\n            continue;\n          }\n          hasField = true;\n          if (sfield != null) {\n            used = true;\n            addField(out, sfield, v,\n                     name.equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n            // record the field as having a value\n            usedFields.add(sfield.getName());\n          }\n  \n          // Check if we should copy this field value to any other fields.\n          // This could happen whether it is explicit or not.\n          if (copyFields != null) {\n            // Do not copy this field if this document is to be used for an in-place update,\n            // and this is the uniqueKey field (because the uniqueKey can't change so no need to \"update\" the copyField).\n            if ( ! (forInPlaceUpdate && name.equals(uniqueKeyFieldName)) ) {\n              for (CopyField cf : copyFields) {\n                SchemaField destinationField = cf.getDestination();\n\n                final boolean destHasValues = usedFields.contains(destinationField.getName());\n\n                // check if the copy field is a multivalued or not\n                if (!destinationField.multiValued() && destHasValues) {\n                  throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n                      \"Multiple values encountered for non multiValued copy field \" +\n                      destinationField.getName() + \": \" + v);\n                }\n\n                used = true;\n\n                // Perhaps trim the length of a copy field\n                Object val = v;\n                if( val instanceof CharSequence && cf.getMaxChars() > 0 ) {\n                    val = cf.getLimitedValue(val.toString());\n                }\n\n                addField(out, destinationField, val,\n                         destinationField.getName().equals(uniqueKeyFieldName) ? false : forInPlaceUpdate);\n                // record the field as having a value\n                usedFields.add(destinationField.getName());\n              }\n            }\n          }\n        }\n      }\n      catch( SolrException ex ) {\n        throw new SolrException(SolrException.ErrorCode.getErrorCode(ex.code()),\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      catch( Exception ex ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"Error adding field '\" + \n              field.getName() + \"'='\" +field.getValue()+\"' msg=\" + ex.getMessage(), ex );\n      }\n      \n      // make sure the field was used somehow...\n      if( !used && hasField ) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\n            \"ERROR: \"+getID(doc, schema)+\"unknown field '\" +name + \"'\");\n      }\n    }\n    \n        \n    // Now validate required fields or add default values\n    // fields with default values are defacto 'required'\n\n    // Note: We don't need to add required fields if this document is to be used for\n    // in-place updates, since this validation and population of required fields would've happened\n    // during the full indexing initially.\n    if (!forInPlaceUpdate) {\n      for (SchemaField field : schema.getRequiredFields()) {\n        if (out.getField(field.getName() ) == null) {\n          if (field.getDefaultValue() != null) {\n            addField(out, field, field.getDefaultValue(), false);\n          } \n          else {\n            String msg = getID(doc, schema) + \"missing required field: \" + field.getName();\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, msg );\n          }\n        }\n      }\n    }\n\n    if (!forInPlaceUpdate) {\n      moveLargestFieldLast(out);\n    }\n    \n    return out;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["3665b66adafb1514bba04cd1d5c477fcaa93d592"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["5abd2ff03128d48bc2a44d2a17a11af87ce58b61"],"4d9f201f4a83c0b998ddd639fb08a61da2313bfa":["b7b5b9bd55a953275a0efc3c5272ed76129541fb"],"df724d84dab24a0cc54bec95a8680867adc7f171":["5abd2ff03128d48bc2a44d2a17a11af87ce58b61","3665b66adafb1514bba04cd1d5c477fcaa93d592"],"b7b5b9bd55a953275a0efc3c5272ed76129541fb":["c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5ce7c704ca874aa623a99f2669737b52ec71cfc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5abd2ff03128d48bc2a44d2a17a11af87ce58b61":["f47793eb80fc739be7036084303ca062ad7aa87d"],"57273019d2938b9b30faae55f6983a2e71a56ec5":["4d9f201f4a83c0b998ddd639fb08a61da2313bfa"],"f47793eb80fc739be7036084303ca062ad7aa87d":["57273019d2938b9b30faae55f6983a2e71a56ec5"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c5ce7c704ca874aa623a99f2669737b52ec71cfc"]},"commit2Childs":{"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3665b66adafb1514bba04cd1d5c477fcaa93d592":["018a36ff4088cb91ab12cbe44f696d81d1fadd77","df724d84dab24a0cc54bec95a8680867adc7f171"],"4d9f201f4a83c0b998ddd639fb08a61da2313bfa":["57273019d2938b9b30faae55f6983a2e71a56ec5"],"df724d84dab24a0cc54bec95a8680867adc7f171":[],"b7b5b9bd55a953275a0efc3c5272ed76129541fb":["4d9f201f4a83c0b998ddd639fb08a61da2313bfa"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","c5ce7c704ca874aa623a99f2669737b52ec71cfc","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"5abd2ff03128d48bc2a44d2a17a11af87ce58b61":["3665b66adafb1514bba04cd1d5c477fcaa93d592","df724d84dab24a0cc54bec95a8680867adc7f171"],"57273019d2938b9b30faae55f6983a2e71a56ec5":["f47793eb80fc739be7036084303ca062ad7aa87d"],"f47793eb80fc739be7036084303ca062ad7aa87d":["5abd2ff03128d48bc2a44d2a17a11af87ce58b61"],"c5ce7c704ca874aa623a99f2669737b52ec71cfc":["b7b5b9bd55a953275a0efc3c5272ed76129541fb","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["df724d84dab24a0cc54bec95a8680867adc7f171","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}