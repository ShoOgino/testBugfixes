{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#buildUrlMap(DocCollection,ReplicaListTransformer).mjava","commits":[{"id":"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839","date":1575929518,"type":1,"author":"Houston Putman","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#buildUrlMap(DocCollection,ReplicaListTransformer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#buildUrlMap(DocCollection).mjava","sourceNew":"  private Map<String,List<String>> buildUrlMap(DocCollection col, ReplicaListTransformer replicaListTransformer) {\n    Map<String, List<String>> urlMap = new HashMap<>();\n    Slice[] slices = col.getActiveSlicesArr();\n    for (Slice slice : slices) {\n      String name = slice.getName();\n      List<Replica> sortedReplicas = new ArrayList<>();\n      Replica leader = slice.getLeader();\n      if (directUpdatesToLeadersOnly && leader == null) {\n        for (Replica replica : slice.getReplicas(\n            replica -> replica.isActive(getClusterStateProvider().getLiveNodes())\n                && replica.getType() == Replica.Type.NRT)) {\n          leader = replica;\n          break;\n        }\n      }\n      if (leader == null) {\n        if (directUpdatesToLeadersOnly) {\n          continue;\n        }\n        // take unoptimized general path - we cannot find a leader yet\n        return null;\n      }\n\n      if (!directUpdatesToLeadersOnly) {\n        for (Replica replica : slice.getReplicas()) {\n          if (!replica.equals(leader)) {\n            sortedReplicas.add(replica);\n          }\n        }\n      }\n\n      // Sort the non-leader replicas according to the request parameters\n      replicaListTransformer.transform(sortedReplicas);\n\n      // put the leaderUrl first.\n      sortedReplicas.add(0, leader);\n\n      urlMap.put(name, sortedReplicas.stream().map(Replica::getCoreUrl).collect(Collectors.toList()));\n    }\n    return urlMap;\n  }\n\n","sourceOld":"  private Map<String,List<String>> buildUrlMap(DocCollection col) {\n    Map<String, List<String>> urlMap = new HashMap<>();\n    Slice[] slices = col.getActiveSlicesArr();\n    for (Slice slice : slices) {\n      String name = slice.getName();\n      List<String> urls = new ArrayList<>();\n      Replica leader = slice.getLeader();\n      if (directUpdatesToLeadersOnly && leader == null) {\n        for (Replica replica : slice.getReplicas(\n            replica -> replica.isActive(getClusterStateProvider().getLiveNodes())\n                && replica.getType() == Replica.Type.NRT)) {\n          leader = replica;\n          break;\n        }\n      }\n      if (leader == null) {\n        if (directUpdatesToLeadersOnly) {\n          continue;\n        }\n        // take unoptimized general path - we cannot find a leader yet\n        return null;\n      }\n      ZkCoreNodeProps zkProps = new ZkCoreNodeProps(leader);\n      String url = zkProps.getCoreUrl();\n      urls.add(url);\n      if (!directUpdatesToLeadersOnly) {\n        for (Replica replica : slice.getReplicas()) {\n          if (!replica.getNodeName().equals(leader.getNodeName()) &&\n              !replica.getName().equals(leader.getName())) {\n            ZkCoreNodeProps zkProps1 = new ZkCoreNodeProps(replica);\n            String url1 = zkProps1.getCoreUrl();\n            urls.add(url1);\n          }\n        }\n      }\n      urlMap.put(name, urls);\n    }\n    return urlMap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"993b0c7dda6341b437fe5685d35c6cc35eaac420","date":1575985950,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#buildUrlMap(DocCollection,ReplicaListTransformer).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/BaseCloudSolrClient#buildUrlMap(DocCollection).mjava","sourceNew":"  private Map<String,List<String>> buildUrlMap(DocCollection col, ReplicaListTransformer replicaListTransformer) {\n    Map<String, List<String>> urlMap = new HashMap<>();\n    Slice[] slices = col.getActiveSlicesArr();\n    for (Slice slice : slices) {\n      String name = slice.getName();\n      List<Replica> sortedReplicas = new ArrayList<>();\n      Replica leader = slice.getLeader();\n      if (directUpdatesToLeadersOnly && leader == null) {\n        for (Replica replica : slice.getReplicas(\n            replica -> replica.isActive(getClusterStateProvider().getLiveNodes())\n                && replica.getType() == Replica.Type.NRT)) {\n          leader = replica;\n          break;\n        }\n      }\n      if (leader == null) {\n        if (directUpdatesToLeadersOnly) {\n          continue;\n        }\n        // take unoptimized general path - we cannot find a leader yet\n        return null;\n      }\n\n      if (!directUpdatesToLeadersOnly) {\n        for (Replica replica : slice.getReplicas()) {\n          if (!replica.equals(leader)) {\n            sortedReplicas.add(replica);\n          }\n        }\n      }\n\n      // Sort the non-leader replicas according to the request parameters\n      replicaListTransformer.transform(sortedReplicas);\n\n      // put the leaderUrl first.\n      sortedReplicas.add(0, leader);\n\n      urlMap.put(name, sortedReplicas.stream().map(Replica::getCoreUrl).collect(Collectors.toList()));\n    }\n    return urlMap;\n  }\n\n","sourceOld":"  private Map<String,List<String>> buildUrlMap(DocCollection col) {\n    Map<String, List<String>> urlMap = new HashMap<>();\n    Slice[] slices = col.getActiveSlicesArr();\n    for (Slice slice : slices) {\n      String name = slice.getName();\n      List<String> urls = new ArrayList<>();\n      Replica leader = slice.getLeader();\n      if (directUpdatesToLeadersOnly && leader == null) {\n        for (Replica replica : slice.getReplicas(\n            replica -> replica.isActive(getClusterStateProvider().getLiveNodes())\n                && replica.getType() == Replica.Type.NRT)) {\n          leader = replica;\n          break;\n        }\n      }\n      if (leader == null) {\n        if (directUpdatesToLeadersOnly) {\n          continue;\n        }\n        // take unoptimized general path - we cannot find a leader yet\n        return null;\n      }\n      ZkCoreNodeProps zkProps = new ZkCoreNodeProps(leader);\n      String url = zkProps.getCoreUrl();\n      urls.add(url);\n      if (!directUpdatesToLeadersOnly) {\n        for (Replica replica : slice.getReplicas()) {\n          if (!replica.getNodeName().equals(leader.getNodeName()) &&\n              !replica.getName().equals(leader.getName())) {\n            ZkCoreNodeProps zkProps1 = new ZkCoreNodeProps(replica);\n            String url1 = zkProps1.getCoreUrl();\n            urls.add(url1);\n          }\n        }\n      }\n      urlMap.put(name, urls);\n    }\n    return urlMap;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"993b0c7dda6341b437fe5685d35c6cc35eaac420":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"]},"commit2Childs":{"993b0c7dda6341b437fe5685d35c6cc35eaac420":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["993b0c7dda6341b437fe5685d35c6cc35eaac420","ad2b6c2ec630dc0bf592b217af5cd07c62ac2839"],"ad2b6c2ec630dc0bf592b217af5cd07c62ac2839":["993b0c7dda6341b437fe5685d35c6cc35eaac420","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["993b0c7dda6341b437fe5685d35c6cc35eaac420","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}