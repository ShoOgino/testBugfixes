{"path":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts.CountOneSegment#call().mjava","commits":[{"id":"8cfd1df435f04d4287925cca73cf22120f723892","date":1493925365,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts.CountOneSegment#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Void call() throws IOException {\n      SortedSetDocValues segValues = leafReader.getSortedSetDocValues(field);\n      if (segValues == null) {\n        // nothing to count here\n        return null;\n      }\n\n      // TODO: yet another option is to count all segs\n      // first, only in seg-ord space, and then do a\n      // merge-sort-PQ in the end to only \"resolve to\n      // global\" those seg ords that can compete, if we know\n      // we just want top K?  ie, this is the same algo\n      // that'd be used for merging facets across shards\n      // (distributed faceting).  but this has much higher\n      // temp ram req'ts (sum of number of ords across all\n      // segs)\n      DocIdSetIterator it;\n      if (hits == null) {\n        // count all\n        it = segValues;\n      } else {\n        it = ConjunctionDISI.intersectIterators(Arrays.asList(hits.bits.iterator(), segValues));\n      }\n\n      if (ordinalMap != null) {\n        final LongValues ordMap = ordinalMap.getGlobalOrds(segOrd);\n\n        int numSegOrds = (int) segValues.getValueCount();\n\n        if (hits != null && hits.totalHits < numSegOrds/10) {\n          // Remap every ord to global ord as we iterate:\n          for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              counts.incrementAndGet((int) ordMap.get(term));\n              term = (int) segValues.nextOrd();\n            }\n          }\n        } else {\n\n          // First count in seg-ord space:\n          final int[] segCounts = new int[numSegOrds];\n          for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              segCounts[term]++;\n              term = (int) segValues.nextOrd();\n            }\n          }\n\n          // Then, migrate to global ords:\n          for(int ord=0;ord<numSegOrds;ord++) {\n            int count = segCounts[ord];\n            if (count != 0) {\n              counts.addAndGet((int) ordMap.get(ord), count);\n            }\n          }\n        }\n      } else {\n        // No ord mapping (e.g., single segment index):\n        // just aggregate directly into counts:\n        for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n          int term = (int) segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts.incrementAndGet(term);\n            term = (int) segValues.nextOrd();\n          }\n        }\n      }\n      \n      return null;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/sortedset/ConcurrentSortedSetDocValuesFacetCounts.CountOneSegment#call().mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public Void call() throws IOException {\n      SortedSetDocValues segValues = leafReader.getSortedSetDocValues(field);\n      if (segValues == null) {\n        // nothing to count here\n        return null;\n      }\n\n      // TODO: yet another option is to count all segs\n      // first, only in seg-ord space, and then do a\n      // merge-sort-PQ in the end to only \"resolve to\n      // global\" those seg ords that can compete, if we know\n      // we just want top K?  ie, this is the same algo\n      // that'd be used for merging facets across shards\n      // (distributed faceting).  but this has much higher\n      // temp ram req'ts (sum of number of ords across all\n      // segs)\n      DocIdSetIterator it;\n      if (hits == null) {\n        // count all\n        it = segValues;\n      } else {\n        it = ConjunctionDISI.intersectIterators(Arrays.asList(hits.bits.iterator(), segValues));\n      }\n\n      if (ordinalMap != null) {\n        final LongValues ordMap = ordinalMap.getGlobalOrds(segOrd);\n\n        int numSegOrds = (int) segValues.getValueCount();\n\n        if (hits != null && hits.totalHits < numSegOrds/10) {\n          // Remap every ord to global ord as we iterate:\n          for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              counts.incrementAndGet((int) ordMap.get(term));\n              term = (int) segValues.nextOrd();\n            }\n          }\n        } else {\n\n          // First count in seg-ord space:\n          final int[] segCounts = new int[numSegOrds];\n          for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n            int term = (int) segValues.nextOrd();\n            while (term != SortedSetDocValues.NO_MORE_ORDS) {\n              segCounts[term]++;\n              term = (int) segValues.nextOrd();\n            }\n          }\n\n          // Then, migrate to global ords:\n          for(int ord=0;ord<numSegOrds;ord++) {\n            int count = segCounts[ord];\n            if (count != 0) {\n              counts.addAndGet((int) ordMap.get(ord), count);\n            }\n          }\n        }\n      } else {\n        // No ord mapping (e.g., single segment index):\n        // just aggregate directly into counts:\n        for (int doc = it.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = it.nextDoc()) {\n          int term = (int) segValues.nextOrd();\n          while (term != SortedSetDocValues.NO_MORE_ORDS) {\n            counts.incrementAndGet(term);\n            term = (int) segValues.nextOrd();\n          }\n        }\n      }\n      \n      return null;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8cfd1df435f04d4287925cca73cf22120f723892":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","8cfd1df435f04d4287925cca73cf22120f723892"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8cfd1df435f04d4287925cca73cf22120f723892"]},"commit2Childs":{"8cfd1df435f04d4287925cca73cf22120f723892":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8cfd1df435f04d4287925cca73cf22120f723892","e9017cf144952056066919f1ebc7897ff9bd71b1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}