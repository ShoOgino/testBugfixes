{"path":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","commits":[{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":0,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    if (clauses.size() == 1)                      // optimize 1-clause case\n      return (clauses.get(0)).getSpans(context, acceptDocs, termContexts);\n\n    return new Spans() {\n        private SpanQueue queue = null;\n        private long cost;\n\n        private boolean initSpanQueue(int target) throws IOException {\n          queue = new SpanQueue(clauses.size());\n          Iterator<SpanQuery> i = clauses.iterator();\n          while (i.hasNext()) {\n            Spans spans = i.next().getSpans(context, acceptDocs, termContexts);\n            cost += spans.cost();\n            if (   ((target == -1) && spans.next())\n                || ((target != -1) && spans.skipTo(target))) {\n              queue.add(spans);\n            }\n          }\n          return queue.size() != 0;\n        }\n\n        @Override\n        public boolean next() throws IOException {\n          if (queue == null) {\n            return initSpanQueue(-1);\n          }\n\n          if (queue.size() == 0) { // all done\n            return false;\n          }\n\n          if (top().next()) { // move to next\n            queue.updateTop();\n            return true;\n          }\n\n          queue.pop();  // exhausted a clause\n          return queue.size() != 0;\n        }\n\n        private Spans top() { return queue.top(); }\n\n        @Override\n        public boolean skipTo(int target) throws IOException {\n          if (queue == null) {\n            return initSpanQueue(target);\n          }\n  \n          boolean skipCalled = false;\n          while (queue.size() != 0 && top().doc() < target) {\n            if (top().skipTo(target)) {\n              queue.updateTop();\n            } else {\n              queue.pop();\n            }\n            skipCalled = true;\n          }\n  \n          if (skipCalled) {\n            return queue.size() != 0;\n          }\n          return next();\n        }\n\n        @Override\n        public int doc() { return top().doc(); }\n        @Override\n        public int start() { return top().start(); }\n        @Override\n        public int end() { return top().end(); }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        Spans theTop = top();\n        if (theTop != null && theTop.isPayloadAvailable()) {\n          result = new ArrayList<>(theTop.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        Spans top = top();\n        return top != null && top.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\"+SpanOrQuery.this+\")@\"+\n            ((queue == null)?\"START\"\n             :(queue.size()>0?(doc()+\":\"+start()+\"-\"+end()):\"END\"));\n        }\n\n      @Override\n      public long cost() {\n        return cost;\n      }\n      \n      };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30de45e50bdc1a79a6797f34dca6271c8866cb6e","date":1427790465,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery seq : clauses) {\n      Spans subSpan = seq.getSpans(context, acceptDocs, termContexts);\n      if (subSpan != null) {\n        subSpans.add(subSpan);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    SpanQueue queue = new SpanQueue(clauses.size());\n    for (Spans spans : subSpans) {\n      queue.add(spans);\n    }\n\n    return new Spans() {\n\n      @Override\n      public int nextDoc() throws IOException {\n        if (queue.size() == 0) { // all done\n          return NO_MORE_DOCS;\n        }\n\n        int currentDoc = top().docID();\n\n        if (currentDoc == -1) { // initially\n          return advance(0);\n        }\n\n        do {\n          if (top().nextDoc() != NO_MORE_DOCS) { // move top to next doc\n            queue.updateTop();\n          } else {\n            queue.pop(); // exhausted a clause\n            if (queue.size() == 0) {\n              return NO_MORE_DOCS;\n            }\n          }\n          // assert queue.size() > 0;\n          int doc = top().docID();\n          if (doc > currentDoc) {\n            return doc;\n          }\n        } while (true);\n      }\n\n      private Spans top() {\n        return queue.top();\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n\n        while ((queue.size() > 0) && (top().docID() < target)) {\n          if (top().advance(target) != NO_MORE_DOCS) {\n            queue.updateTop();\n          } else {\n            queue.pop();\n          }\n        }\n\n        return (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;\n      }\n\n      @Override\n      public int docID() {\n        return (queue == null) ? -1\n              : (queue.size() > 0) ? top().docID()\n              : NO_MORE_DOCS;\n      }\n\n      @Override\n      public int nextStartPosition() throws IOException {\n        top().nextStartPosition();\n        queue.updateTop();\n        int startPos = top().startPosition();\n        while (startPos == -1) { // initially at this doc\n          top().nextStartPosition();\n          queue.updateTop();\n          startPos = top().startPosition();\n        }\n        return startPos;\n      }\n\n      @Override\n      public int startPosition() {\n        return top().startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return top().endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        Spans theTop = top();\n        if (theTop != null && theTop.isPayloadAvailable()) {\n          result = new ArrayList<>(theTop.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        Spans top = top();\n        return top != null && top.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\"+SpanOrQuery.this+\")@\"+\n            ((queue == null)?\"START\"\n             :(queue.size()>0?(docID()+\": \"+top().startPosition()+\" - \"+top().endPosition()):\"END\"));\n      }\n\n      private long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    if (clauses.size() == 1)                      // optimize 1-clause case\n      return (clauses.get(0)).getSpans(context, acceptDocs, termContexts);\n\n    return new Spans() {\n        private SpanQueue queue = null;\n        private long cost;\n\n        private boolean initSpanQueue(int target) throws IOException {\n          queue = new SpanQueue(clauses.size());\n          Iterator<SpanQuery> i = clauses.iterator();\n          while (i.hasNext()) {\n            Spans spans = i.next().getSpans(context, acceptDocs, termContexts);\n            cost += spans.cost();\n            if (   ((target == -1) && spans.next())\n                || ((target != -1) && spans.skipTo(target))) {\n              queue.add(spans);\n            }\n          }\n          return queue.size() != 0;\n        }\n\n        @Override\n        public boolean next() throws IOException {\n          if (queue == null) {\n            return initSpanQueue(-1);\n          }\n\n          if (queue.size() == 0) { // all done\n            return false;\n          }\n\n          if (top().next()) { // move to next\n            queue.updateTop();\n            return true;\n          }\n\n          queue.pop();  // exhausted a clause\n          return queue.size() != 0;\n        }\n\n        private Spans top() { return queue.top(); }\n\n        @Override\n        public boolean skipTo(int target) throws IOException {\n          if (queue == null) {\n            return initSpanQueue(target);\n          }\n  \n          boolean skipCalled = false;\n          while (queue.size() != 0 && top().doc() < target) {\n            if (top().skipTo(target)) {\n              queue.updateTop();\n            } else {\n              queue.pop();\n            }\n            skipCalled = true;\n          }\n  \n          if (skipCalled) {\n            return queue.size() != 0;\n          }\n          return next();\n        }\n\n        @Override\n        public int doc() { return top().doc(); }\n        @Override\n        public int start() { return top().start(); }\n        @Override\n        public int end() { return top().end(); }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        Spans theTop = top();\n        if (theTop != null && theTop.isPayloadAvailable()) {\n          result = new ArrayList<>(theTop.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        Spans top = top();\n        return top != null && top.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\"+SpanOrQuery.this+\")@\"+\n            ((queue == null)?\"START\"\n             :(queue.size()>0?(doc()+\":\"+start()+\"-\"+end()):\"END\"));\n        }\n\n      @Override\n      public long cost() {\n        return cost;\n      }\n      \n      };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fab172655716b96f7e42376116235017a922de3a","date":1427850611,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery seq : clauses) {\n      Spans subSpan = seq.getSpans(context, acceptDocs, termContexts);\n      if (subSpan != null) {\n        subSpans.add(subSpan);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    SpanQueue queue = new SpanQueue(clauses.size());\n    for (Spans spans : subSpans) {\n      queue.add(spans);\n    }\n\n    return new Spans() {\n\n      @Override\n      public int nextDoc() throws IOException {\n        if (queue.size() == 0) { // all done\n          return NO_MORE_DOCS;\n        }\n\n        int currentDoc = top().docID();\n\n        if (currentDoc == -1) { // initially\n          return advance(0);\n        }\n\n        do {\n          if (top().nextDoc() != NO_MORE_DOCS) { // move top to next doc\n            queue.updateTop();\n          } else {\n            queue.pop(); // exhausted a clause\n            if (queue.size() == 0) {\n              return NO_MORE_DOCS;\n            }\n          }\n          // assert queue.size() > 0;\n          int doc = top().docID();\n          if (doc > currentDoc) {\n            return doc;\n          }\n        } while (true);\n      }\n\n      private Spans top() {\n        return queue.top();\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n\n        while ((queue.size() > 0) && (top().docID() < target)) {\n          if (top().advance(target) != NO_MORE_DOCS) {\n            queue.updateTop();\n          } else {\n            queue.pop();\n          }\n        }\n\n        return (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;\n      }\n\n      @Override\n      public int docID() {\n        return (queue == null) ? -1\n              : (queue.size() > 0) ? top().docID()\n              : NO_MORE_DOCS;\n      }\n\n      @Override\n      public int nextStartPosition() throws IOException {\n        top().nextStartPosition();\n        queue.updateTop();\n        int startPos = top().startPosition();\n        while (startPos == -1) { // initially at this doc\n          top().nextStartPosition();\n          queue.updateTop();\n          startPos = top().startPosition();\n        }\n        return startPos;\n      }\n\n      @Override\n      public int startPosition() {\n        return top().startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return top().endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        Spans theTop = top();\n        if (theTop != null && theTop.isPayloadAvailable()) {\n          result = new ArrayList<>(theTop.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        Spans top = top();\n        return top != null && top.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\"+SpanOrQuery.this+\")@\"+\n            ((queue == null)?\"START\"\n             :(queue.size()>0?(docID()+\": \"+top().startPosition()+\" - \"+top().endPosition()):\"END\"));\n      }\n\n      private long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {\n    if (clauses.size() == 1)                      // optimize 1-clause case\n      return (clauses.get(0)).getSpans(context, acceptDocs, termContexts);\n\n    return new Spans() {\n        private SpanQueue queue = null;\n        private long cost;\n\n        private boolean initSpanQueue(int target) throws IOException {\n          queue = new SpanQueue(clauses.size());\n          Iterator<SpanQuery> i = clauses.iterator();\n          while (i.hasNext()) {\n            Spans spans = i.next().getSpans(context, acceptDocs, termContexts);\n            cost += spans.cost();\n            if (   ((target == -1) && spans.next())\n                || ((target != -1) && spans.skipTo(target))) {\n              queue.add(spans);\n            }\n          }\n          return queue.size() != 0;\n        }\n\n        @Override\n        public boolean next() throws IOException {\n          if (queue == null) {\n            return initSpanQueue(-1);\n          }\n\n          if (queue.size() == 0) { // all done\n            return false;\n          }\n\n          if (top().next()) { // move to next\n            queue.updateTop();\n            return true;\n          }\n\n          queue.pop();  // exhausted a clause\n          return queue.size() != 0;\n        }\n\n        private Spans top() { return queue.top(); }\n\n        @Override\n        public boolean skipTo(int target) throws IOException {\n          if (queue == null) {\n            return initSpanQueue(target);\n          }\n  \n          boolean skipCalled = false;\n          while (queue.size() != 0 && top().doc() < target) {\n            if (top().skipTo(target)) {\n              queue.updateTop();\n            } else {\n              queue.pop();\n            }\n            skipCalled = true;\n          }\n  \n          if (skipCalled) {\n            return queue.size() != 0;\n          }\n          return next();\n        }\n\n        @Override\n        public int doc() { return top().doc(); }\n        @Override\n        public int start() { return top().start(); }\n        @Override\n        public int end() { return top().end(); }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        Spans theTop = top();\n        if (theTop != null && theTop.isPayloadAvailable()) {\n          result = new ArrayList<>(theTop.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        Spans top = top();\n        return top != null && top.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\"+SpanOrQuery.this+\")@\"+\n            ((queue == null)?\"START\"\n             :(queue.size()>0?(doc()+\":\"+start()+\"-\"+end()):\"END\"));\n        }\n\n      @Override\n      public long cost() {\n        return cost;\n      }\n      \n      };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fd9a42c79cabbf7d82cc6081cf4dac1324c99e7","date":1429852340,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        assert topDocSpans.doc != NO_MORE_DOCS;\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        return topPositionSpans == null\n                ? null\n                : topPositionSpans.isPayloadAvailable()\n                ? new ArrayList<>(topPositionSpans.getPayload())\n                : null;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return (topPositionSpans != null) && topPositionSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery seq : clauses) {\n      Spans subSpan = seq.getSpans(context, acceptDocs, termContexts);\n      if (subSpan != null) {\n        subSpans.add(subSpan);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    SpanQueue queue = new SpanQueue(clauses.size());\n    for (Spans spans : subSpans) {\n      queue.add(spans);\n    }\n\n    return new Spans() {\n\n      @Override\n      public int nextDoc() throws IOException {\n        if (queue.size() == 0) { // all done\n          return NO_MORE_DOCS;\n        }\n\n        int currentDoc = top().docID();\n\n        if (currentDoc == -1) { // initially\n          return advance(0);\n        }\n\n        do {\n          if (top().nextDoc() != NO_MORE_DOCS) { // move top to next doc\n            queue.updateTop();\n          } else {\n            queue.pop(); // exhausted a clause\n            if (queue.size() == 0) {\n              return NO_MORE_DOCS;\n            }\n          }\n          // assert queue.size() > 0;\n          int doc = top().docID();\n          if (doc > currentDoc) {\n            return doc;\n          }\n        } while (true);\n      }\n\n      private Spans top() {\n        return queue.top();\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n\n        while ((queue.size() > 0) && (top().docID() < target)) {\n          if (top().advance(target) != NO_MORE_DOCS) {\n            queue.updateTop();\n          } else {\n            queue.pop();\n          }\n        }\n\n        return (queue.size() > 0) ? top().docID() : NO_MORE_DOCS;\n      }\n\n      @Override\n      public int docID() {\n        return (queue == null) ? -1\n              : (queue.size() > 0) ? top().docID()\n              : NO_MORE_DOCS;\n      }\n\n      @Override\n      public int nextStartPosition() throws IOException {\n        top().nextStartPosition();\n        queue.updateTop();\n        int startPos = top().startPosition();\n        while (startPos == -1) { // initially at this doc\n          top().nextStartPosition();\n          queue.updateTop();\n          startPos = top().startPosition();\n        }\n        return startPos;\n      }\n\n      @Override\n      public int startPosition() {\n        return top().startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return top().endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        ArrayList<byte[]> result = null;\n        Spans theTop = top();\n        if (theTop != null && theTop.isPayloadAvailable()) {\n          result = new ArrayList<>(theTop.getPayload());\n        }\n        return result;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        Spans top = top();\n        return top != null && top.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n          return \"spans(\"+SpanOrQuery.this+\")@\"+\n            ((queue == null)?\"START\"\n             :(queue.size()>0?(docID()+\": \"+top().startPosition()+\" - \"+top().endPosition()):\"END\"));\n      }\n\n      private long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eef808a48015f9491f99f680646fc74641dd6559","date":1430216787,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        return topPositionSpans == null\n                ? null\n                : topPositionSpans.isPayloadAvailable()\n                ? new ArrayList<>(topPositionSpans.getPayload())\n                : null;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return (topPositionSpans != null) && topPositionSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        assert topDocSpans.doc != NO_MORE_DOCS;\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        return topPositionSpans == null\n                ? null\n                : topPositionSpans.isPayloadAvailable()\n                ? new ArrayList<>(topPositionSpans.getPayload())\n                : null;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return (topPositionSpans != null) && topPositionSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d530e71ed32ab23b34ca3fc72b080a554a40404","date":1432026158,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext],SpanCollector).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/spans/SpanOrQuery#getSpans(LeafReaderContext,Bits,Map[Term,TermContext]).mjava","sourceNew":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts, SpanCollector collector)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts, collector);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public void collect(SpanCollector collector) throws IOException {\n        if (topPositionSpans != null)\n          topPositionSpans.collect(collector);\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts)\n  throws IOException {\n\n    ArrayList<Spans> subSpans = new ArrayList<>(clauses.size());\n\n    for (SpanQuery sq : clauses) {\n      Spans spans = sq.getSpans(context, acceptDocs, termContexts);\n      if (spans != null) {\n        subSpans.add(spans);\n      }\n    }\n\n    if (subSpans.size() == 0) {\n      return null;\n    } else if (subSpans.size() == 1) {\n      return subSpans.get(0);\n    }\n\n    DisiPriorityQueue<Spans> byDocQueue = new DisiPriorityQueue<>(subSpans.size());\n    for (Spans spans : subSpans) {\n      byDocQueue.add(new DisiWrapper<>(spans));\n    }\n\n    SpanPositionQueue byPositionQueue = new SpanPositionQueue(subSpans.size()); // when empty use -1\n\n    return new Spans() {\n      Spans topPositionSpans = null;\n\n      @Override\n      public int nextDoc() throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        int currentDoc = topDocSpans.doc;\n        do {\n          topDocSpans.doc = topDocSpans.iterator.nextDoc();\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc == currentDoc);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        topPositionSpans = null;\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        do {\n          topDocSpans.doc = topDocSpans.iterator.advance(target);\n          topDocSpans = byDocQueue.updateTop();\n        } while (topDocSpans.doc < target);\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public int docID() {\n        DisiWrapper<Spans> topDocSpans = byDocQueue.top();\n        return topDocSpans.doc;\n      }\n\n      @Override\n      public TwoPhaseIterator asTwoPhaseIterator() {\n        boolean hasApproximation = false;\n        for (DisiWrapper<Spans> w : byDocQueue) {\n          if (w.twoPhaseView != null) {\n            hasApproximation = true;\n            break;\n          }\n        }\n\n        if (! hasApproximation) { // none of the sub spans supports approximations\n          return null;\n        }\n\n        return new TwoPhaseIterator(new DisjunctionDISIApproximation<Spans>(byDocQueue)) {\n          @Override\n          public boolean matches() throws IOException {\n            return twoPhaseCurrentDocMatches();\n          }\n        };\n      }\n      \n      int lastDocTwoPhaseMatched = -1;\n\n      boolean twoPhaseCurrentDocMatches() throws IOException {\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        // remove the head of the list as long as it does not match\n        final int currentDoc = listAtCurrentDoc.doc;\n        while (listAtCurrentDoc.twoPhaseView != null) {\n          if (listAtCurrentDoc.twoPhaseView.matches()) {\n            // use this spans for positions at current doc:\n            listAtCurrentDoc.lastApproxMatchDoc = currentDoc;\n            break;\n          }\n          // do not use this spans for positions at current doc:\n          listAtCurrentDoc.lastApproxNonMatchDoc = currentDoc;\n          listAtCurrentDoc = listAtCurrentDoc.next;\n          if (listAtCurrentDoc == null) {\n            return false;\n          }\n        }\n        lastDocTwoPhaseMatched = currentDoc;\n        topPositionSpans = null;\n        return true;\n      }\n\n      void fillPositionQueue() throws IOException { // called at first nextStartPosition\n        assert byPositionQueue.size() == 0;\n        // add all matching Spans at current doc to byPositionQueue\n        DisiWrapper<Spans> listAtCurrentDoc = byDocQueue.topList();\n        while (listAtCurrentDoc != null) {\n          Spans spansAtDoc = listAtCurrentDoc.iterator;\n          if (lastDocTwoPhaseMatched == listAtCurrentDoc.doc) { // matched by DisjunctionDisiApproximation\n            if (listAtCurrentDoc.twoPhaseView != null) { // matched by approximation\n              if (listAtCurrentDoc.lastApproxNonMatchDoc == listAtCurrentDoc.doc) { // matches() returned false\n                spansAtDoc = null;\n              } else {\n                if (listAtCurrentDoc.lastApproxMatchDoc != listAtCurrentDoc.doc) {\n                  if (! listAtCurrentDoc.twoPhaseView.matches()) {\n                    spansAtDoc = null;\n                  }\n                }\n              } \n            }\n          }\n\n          if (spansAtDoc != null) {\n            assert spansAtDoc.docID() == listAtCurrentDoc.doc;\n            assert spansAtDoc.startPosition() == -1;\n            spansAtDoc.nextStartPosition();\n            assert spansAtDoc.startPosition() != NO_MORE_POSITIONS;\n            byPositionQueue.add(spansAtDoc);\n          }\n          listAtCurrentDoc = listAtCurrentDoc.next;\n        }\n        assert byPositionQueue.size() > 0;\n      }\n        \n      @Override\n      public int nextStartPosition() throws IOException {\n        if (topPositionSpans == null) {\n          byPositionQueue.clear();\n          fillPositionQueue(); // fills byPositionQueue at first position\n          topPositionSpans = byPositionQueue.top();\n        } else {\n          topPositionSpans.nextStartPosition();\n          topPositionSpans = byPositionQueue.updateTop();\n        }\n        return topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int startPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.startPosition();\n      }\n\n      @Override\n      public int endPosition() {\n        return topPositionSpans == null ? -1 : topPositionSpans.endPosition();\n      }\n\n      @Override\n      public Collection<byte[]> getPayload() throws IOException {\n        return topPositionSpans == null\n                ? null\n                : topPositionSpans.isPayloadAvailable()\n                ? new ArrayList<>(topPositionSpans.getPayload())\n                : null;\n      }\n\n      @Override\n      public boolean isPayloadAvailable() throws IOException {\n        return (topPositionSpans != null) && topPositionSpans.isPayloadAvailable();\n      }\n\n      @Override\n      public String toString() {\n        return \"spanOr(\"+SpanOrQuery.this+\")@\"+docID()+\": \"+startPosition()+\" - \"+endPosition();\n      }\n\n      long cost = -1;\n\n      @Override\n      public long cost() {\n        if (cost == -1) {\n          cost = 0;\n          for (Spans spans : subSpans) {\n            cost += spans.cost();\n          }\n        }\n        return cost;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7fd9a42c79cabbf7d82cc6081cf4dac1324c99e7":["30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["eef808a48015f9491f99f680646fc74641dd6559"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"fab172655716b96f7e42376116235017a922de3a":["c9fb5f46e264daf5ba3860defe623a89d202dd87","30de45e50bdc1a79a6797f34dca6271c8866cb6e"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2d530e71ed32ab23b34ca3fc72b080a554a40404"],"eef808a48015f9491f99f680646fc74641dd6559":["7fd9a42c79cabbf7d82cc6081cf4dac1324c99e7"]},"commit2Childs":{"7fd9a42c79cabbf7d82cc6081cf4dac1324c99e7":["eef808a48015f9491f99f680646fc74641dd6559"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"2d530e71ed32ab23b34ca3fc72b080a554a40404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"30de45e50bdc1a79a6797f34dca6271c8866cb6e":["7fd9a42c79cabbf7d82cc6081cf4dac1324c99e7","fab172655716b96f7e42376116235017a922de3a"],"fab172655716b96f7e42376116235017a922de3a":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["30de45e50bdc1a79a6797f34dca6271c8866cb6e","fab172655716b96f7e42376116235017a922de3a"],"eef808a48015f9491f99f680646fc74641dd6559":["2d530e71ed32ab23b34ca3fc72b080a554a40404"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fab172655716b96f7e42376116235017a922de3a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}