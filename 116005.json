{"path":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","sourceOld":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","sourceOld":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","sourceOld":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellingParams.SPELLCHECK_BUILD);\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","sourceOld":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellingParams.SPELLCHECK_BUILD);\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","sourceOld":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_BUILD);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellCheckComponent.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    String singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<String> collations = suggestions.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<String>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"\t@Test\n\tpublic void testExtendedCollate() throws Exception {\n\t\tSolrCore core = h.getCore();\n\t\tSearchComponent speller = core.getSearchComponent(\"spellcheck\");\n\t\tassertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n\t\tModifiableSolrParams params = new ModifiableSolrParams();\n\t\tparams.add(CommonParams.QT, \"spellCheckCompRH\");\n\t\tparams.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n\t\tparams.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n\t\tparams.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n\t\tparams.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n\t\tparams.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n\t\tparams.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n\t\t// Testing backwards-compatible behavior.\n\t\t// Returns 1 collation as a single string.\n\t\t// All words are \"correct\" per the dictionary, but this collation would\n\t\t// return no results if tried.\n\t\tSolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\tSolrQueryResponse rsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\tSolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tNamedList values = rsp.getValues();\n\t\tNamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tNamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tString singleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n\t\t// Testing backwards-compatible response format but will only return a\n\t\t// collation that would return results.\n\t\tparams.remove(SpellingParams.SPELLCHECK_BUILD);\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n    req.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tsingleCollation = (String) suggestions.get(\"collation\");\n\t\tassertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n\t\t// Testing returning multiple collations if more than one valid\n\t\t// combination exists.\n\t\tparams.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n\t\tparams.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n\t\tparams.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<String> collations = suggestions.getAll(\"collation\");\n\t\tassertTrue(collations.size() == 2);\n\t\tfor (String multipleCollation : collations) {\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t}\n\n\t\t// Testing return multiple collations with expanded collation response\n\t\t// format.\n\t\tparams.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n\t\thandler = core.getRequestHandler(\"spellCheckCompRH\");\n\t\trsp = new SolrQueryResponse();\n\t\trsp.add(\"responseHeader\", new SimpleOrderedMap());\n\t\treq = new LocalSolrQueryRequest(core, params);\n\t\thandler.handleRequest(req, rsp);\n\t\treq.close();\n\t\tvalues = rsp.getValues();\n\t\tspellCheck = (NamedList) values.get(\"spellcheck\");\n\t\tsuggestions = (NamedList) spellCheck.get(\"suggestions\");\n\t\tList<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n\t\tSet<String> usedcollations = new HashSet<String>();\n\t\tassertTrue(expandedCollationList.size() == 2);\n\t\tfor (NamedList expandedCollation : expandedCollationList) {\n\t\t\tString multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n\t\t\tassertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n\t\t\t\t\t|| multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n\t\t\tassertTrue(!usedcollations.contains(multipleCollation));\n\t\t\tusedcollations.add(multipleCollation);\n\n\t\t\tint hits = (Integer) expandedCollation.get(\"hits\");\n\t\t\tassertTrue(hits == 1);\n\n\t\t\tNamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n\t\t\tassertTrue(misspellingsAndCorrections.size() == 3);\n\n\t\t\tString correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n\t\t\tString correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n\t\t\tString correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n\t\t\tassertTrue(correctionForFauth.equals(\"faith\"));\n\t\t\tassertTrue(correctionForHome.equals(\"hope\"));\n\t\t\tassertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n\t\t}\n\t}\n\n","bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    String singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<String> collations = suggestions.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    String singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<String> collations = suggestions.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<String>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"343d2d9477b299075fa3a19a46e654b6c3bf552b","date":1407872410,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    String singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    singleCollation = (String) suggestions.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<String> collations = suggestions.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    suggestions = (NamedList) spellCheck.get(\"suggestions\");\n    List<NamedList> expandedCollationList = suggestions.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ecd75942508378ccc92c3a26f71db6cba9f25784","date":1450708761,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.add(\"responseHeader\", new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","date":1498031702,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ff704ef91e9ae30ca59babb23ece85720701b60","date":1498684964,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      int hits = (Integer) expandedCollation.get(\"hits\");\n      assertTrue(hits == 1);\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b6a269c1ddba3f8c9fa9a40572ecc538eddda41a","date":1528054850,"type":3,"author":"Michael Braun","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(1L, expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"628903f37b6c442da0d390db1c6af9a0e74d41a7","date":1531736685,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(1L, expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(1L, expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(new Long(1L), expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa2585c33d5d66a1c837c312221eb55ddb3c4300","date":1592493170,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","pathOld":"solr/core/src/test/org/apache/solr/spelling/SpellCheckCollatorTest#testExtendedCollate().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    @SuppressWarnings({\"rawtypes\"})\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(1L, expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testExtendedCollate() throws Exception {\n    SolrCore core = h.getCore();\n    SearchComponent speller = core.getSearchComponent(\"spellcheck\");\n    assertTrue(\"speller is null and it shouldn't be\", speller != null);\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.add(CommonParams.QT, \"spellCheckCompRH\");\n    params.add(CommonParams.Q, \"lowerfilt:(+fauth +home +loane)\");\n    params.add(SpellingParams.SPELLCHECK_EXTENDED_RESULTS, \"true\");\n    params.add(SpellCheckComponent.COMPONENT_NAME, \"true\");\n    params.add(SpellingParams.SPELLCHECK_BUILD, \"true\");\n    params.add(SpellingParams.SPELLCHECK_COUNT, \"10\");\n    params.add(SpellingParams.SPELLCHECK_COLLATE, \"true\");\n\n    // Testing backwards-compatible behavior.\n    // Returns 1 collation as a single string.\n    // All words are \"correct\" per the dictionary, but this collation would\n    // return no results if tried.\n    SolrRequestHandler handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    SolrQueryResponse rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    SolrQueryRequest req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    NamedList values = rsp.getValues();\n    NamedList spellCheck = (NamedList) values.get(\"spellcheck\");\n    NamedList collationHolder = (NamedList) spellCheck.get(\"collations\");\n    String singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +homer +loaves)\", singleCollation);\n\n    // Testing backwards-compatible response format but will only return a\n    // collation that would return results.\n    params.remove(SpellingParams.SPELLCHECK_BUILD);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"5\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"1\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    singleCollation = (String) collationHolder.get(\"collation\");\n    assertEquals(\"lowerfilt:(+faith +hope +loaves)\", singleCollation);\n\n    // Testing returning multiple collations if more than one valid\n    // combination exists.\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES);\n    params.remove(SpellingParams.SPELLCHECK_MAX_COLLATIONS);\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATION_TRIES, \"10\");\n    params.add(SpellingParams.SPELLCHECK_MAX_COLLATIONS, \"2\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<String> collations = collationHolder.getAll(\"collation\");\n    assertTrue(collations.size() == 2);\n    for (String multipleCollation : collations) {\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n    }\n\n    // Testing return multiple collations with expanded collation response\n    // format.\n    params.add(SpellingParams.SPELLCHECK_COLLATE_EXTENDED_RESULTS, \"true\");\n    handler = core.getRequestHandler(\"/spellCheckCompRH\");\n    rsp = new SolrQueryResponse();\n    rsp.addResponseHeader(new SimpleOrderedMap());\n    req = new LocalSolrQueryRequest(core, params);\n    handler.handleRequest(req, rsp);\n    req.close();\n    values = rsp.getValues();\n    spellCheck = (NamedList) values.get(\"spellcheck\");\n    collationHolder = (NamedList) spellCheck.get(\"collations\");\n    List<NamedList> expandedCollationList = collationHolder.getAll(\"collation\");\n    Set<String> usedcollations = new HashSet<>();\n    assertTrue(expandedCollationList.size() == 2);\n    for (NamedList expandedCollation : expandedCollationList) {\n      String multipleCollation = (String) expandedCollation.get(\"collationQuery\");\n      assertTrue(multipleCollation.equals(\"lowerfilt:(+faith +hope +love)\")\n          || multipleCollation.equals(\"lowerfilt:(+faith +hope +loaves)\"));\n      assertTrue(!usedcollations.contains(multipleCollation));\n      usedcollations.add(multipleCollation);\n\n      assertEquals(1L, expandedCollation.get(\"hits\"));\n\n      NamedList misspellingsAndCorrections = (NamedList) expandedCollation.get(\"misspellingsAndCorrections\");\n      assertTrue(misspellingsAndCorrections.size() == 3);\n\n      String correctionForFauth = (String) misspellingsAndCorrections.get(\"fauth\");\n      String correctionForHome = (String) misspellingsAndCorrections.get(\"home\");\n      String correctionForLoane = (String) misspellingsAndCorrections.get(\"loane\");\n      assertTrue(correctionForFauth.equals(\"faith\"));\n      assertTrue(correctionForHome.equals(\"hope\"));\n      assertTrue(correctionForLoane.equals(\"love\") || correctionForLoane.equals(\"loaves\"));\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"b6a269c1ddba3f8c9fa9a40572ecc538eddda41a":["28288370235ed02234a64753cdbf0c6ec096304a"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["c26f00b574427b55127e869b935845554afde1fa","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"343d2d9477b299075fa3a19a46e654b6c3bf552b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["ecd75942508378ccc92c3a26f71db6cba9f25784"],"30c8e5574b55d57947e989443dfde611646530ee":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["ecd75942508378ccc92c3a26f71db6cba9f25784","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"],"28288370235ed02234a64753cdbf0c6ec096304a":["ecd75942508378ccc92c3a26f71db6cba9f25784","5ff704ef91e9ae30ca59babb23ece85720701b60"],"628903f37b6c442da0d390db1c6af9a0e74d41a7":["28288370235ed02234a64753cdbf0c6ec096304a","b6a269c1ddba3f8c9fa9a40572ecc538eddda41a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["28288370235ed02234a64753cdbf0c6ec096304a","628903f37b6c442da0d390db1c6af9a0e74d41a7"],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["628903f37b6c442da0d390db1c6af9a0e74d41a7"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ecd75942508378ccc92c3a26f71db6cba9f25784":["343d2d9477b299075fa3a19a46e654b6c3bf552b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["343d2d9477b299075fa3a19a46e654b6c3bf552b"],"b6a269c1ddba3f8c9fa9a40572ecc538eddda41a":["628903f37b6c442da0d390db1c6af9a0e74d41a7"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"c26f00b574427b55127e869b935845554afde1fa":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"343d2d9477b299075fa3a19a46e654b6c3bf552b":["ecd75942508378ccc92c3a26f71db6cba9f25784"],"f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","5ff704ef91e9ae30ca59babb23ece85720701b60"],"30c8e5574b55d57947e989443dfde611646530ee":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["30c8e5574b55d57947e989443dfde611646530ee"],"28288370235ed02234a64753cdbf0c6ec096304a":["b6a269c1ddba3f8c9fa9a40572ecc538eddda41a","30c8e5574b55d57947e989443dfde611646530ee","628903f37b6c442da0d390db1c6af9a0e74d41a7","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5"],"628903f37b6c442da0d390db1c6af9a0e74d41a7":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","aa2585c33d5d66a1c837c312221eb55ddb3c4300"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"aa2585c33d5d66a1c837c312221eb55ddb3c4300":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ecd75942508378ccc92c3a26f71db6cba9f25784":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5ff704ef91e9ae30ca59babb23ece85720701b60":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","30c8e5574b55d57947e989443dfde611646530ee","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}