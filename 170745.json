{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","sourceNew":"  void waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","sourceOld":"  void waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","sourceNew":"  void waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","sourceOld":"  void waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1498cb4cd65cf2303ccde0e0d6edf5a5e1e8fd28","date":1571131262,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","sourceNew":"  ClusterState waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n      DocCollection collection = clusterState.getCollection(collectionName);\n\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return clusterState;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","sourceOld":"  void waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","bugFix":["4ddb837927b3de29503b68a05fec256665edab50","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","sourceNew":"  ClusterState waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n      DocCollection collection = clusterState.getCollection(collectionName);\n\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return clusterState;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","sourceOld":"  void waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      DocCollection collection = zkStateReader.getClusterState().getCollection(collectionName);\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/OverseerCollectionMessageHandler#waitForNewShard(String,String).mjava","sourceNew":"  ClusterState waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n      DocCollection collection = clusterState.getCollection(collectionName);\n\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n              timer.getTime(), sliceName, collectionName);\n        }\n        return clusterState;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","sourceOld":"  ClusterState waitForNewShard(String collectionName, String sliceName) throws KeeperException, InterruptedException {\n    log.debug(\"Waiting for slice {} of collection {} to be available\", sliceName, collectionName);\n    RTimer timer = new RTimer();\n    int retryCount = 320;\n    while (retryCount-- > 0) {\n      ClusterState clusterState = zkStateReader.getClusterState();\n      DocCollection collection = clusterState.getCollection(collectionName);\n\n      if (collection == null) {\n        throw new SolrException(ErrorCode.SERVER_ERROR,\n            \"Unable to find collection: \" + collectionName + \" in clusterstate\");\n      }\n      Slice slice = collection.getSlice(sliceName);\n      if (slice != null) {\n        log.debug(\"Waited for {}ms for slice {} of collection {} to be available\",\n            timer.getTime(), sliceName, collectionName);\n        return clusterState;\n      }\n      Thread.sleep(1000);\n    }\n    throw new SolrException(ErrorCode.SERVER_ERROR,\n        \"Could not find new slice \" + sliceName + \" in collection \" + collectionName\n            + \" even after waiting for \" + timer.getTime() + \"ms\"\n    );\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1498cb4cd65cf2303ccde0e0d6edf5a5e1e8fd28":["b94236357aaa22b76c10629851fe4e376e0cea82"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"4abf821a41a2fdca2a1dea148999931d22e20529":["1498cb4cd65cf2303ccde0e0d6edf5a5e1e8fd28"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4abf821a41a2fdca2a1dea148999931d22e20529"],"b0b597c65628ca9e73913a07e81691f8229bae35":["b94236357aaa22b76c10629851fe4e376e0cea82","1498cb4cd65cf2303ccde0e0d6edf5a5e1e8fd28"]},"commit2Childs":{"1498cb4cd65cf2303ccde0e0d6edf5a5e1e8fd28":["4abf821a41a2fdca2a1dea148999931d22e20529","b0b597c65628ca9e73913a07e81691f8229bae35"],"b94236357aaa22b76c10629851fe4e376e0cea82":["1498cb4cd65cf2303ccde0e0d6edf5a5e1e8fd28","b0b597c65628ca9e73913a07e81691f8229bae35"],"4abf821a41a2fdca2a1dea148999931d22e20529":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}