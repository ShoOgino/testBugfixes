{"path":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","commits":[{"id":"beea4d4bbebcfb6689ed31936553c5e98bce2871","date":1393882670,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"/dev/null","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = baseReq.getSearcher();\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, afterReq.getSearcher().getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e453ee95e5ed4cd001de2d5d3269e25f977980f1","0e49c5115c9943dedfca7559a7f11921edb1b7a0","686fc6c072e3cf75fee3f14f8bcb908c7fcb6121"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ffbafffd25b93aa3ae294291ebc172a02333cdb6","date":1395763814,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = baseReq.getSearcher();\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = beforeReq.getSearcher();\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, afterReq.getSearcher().getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e453ee95e5ed4cd001de2d5d3269e25f977980f1","date":1432836708,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"bugIntro":["0e49c5115c9943dedfca7559a7f11921edb1b7a0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e49c5115c9943dedfca7559a7f11921edb1b7a0","date":1436048101,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":["beea4d4bbebcfb6689ed31936553c5e98bce2871","e453ee95e5ed4cd001de2d5d3269e25f977980f1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"686fc6c072e3cf75fee3f14f8bcb908c7fcb6121","date":1441385057,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n    assertU(commit());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasi≈Ñski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always guarantee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always guarantee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/TestSearcherReuse#test().mjava","sourceNew":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always guarantee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","sourceOld":"  public void test() throws Exception {\n\n    // seed some docs & segments\n    int numDocs = atLeast(1);\n    for (int i = 1; i <= numDocs; i++) {\n      // NOTE: starting at \"1\", we'll use id=0 later\n      assertU(adoc(\"id\", \"\"+i));\n      if (random().nextBoolean()) {\n        assertU(commit());\n      }\n    }\n\n    // with random merge policies, a regular commit can cause a segment to be flushed that can kick off a background merge\n    // that can cause a later commit to actually see changes and open a new searcher.  This should not be possible with optimize\n    assertU(optimize());\n\n    // seed a single query into the cache\n    assertQ(req(\"*:*\"), \"//*[@numFound='\"+numDocs+\"']\");\n\n    final SolrQueryRequest baseReq = req(\"q\",\"foo\");\n    try {\n      // we make no index changes in this block, so the searcher should always be the same\n      // NOTE: we *have* to call getSearcher() in advance, it's a delayed binding\n      final SolrIndexSearcher expectedSearcher = getMainSearcher(baseReq);\n\n      assertU(commit());\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delQ(\"id:match_no_documents\"));\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n      assertU(delI(\"0\")); // no doc has this id, yet\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasNotChanged(expectedSearcher);\n\n    } finally {\n      baseReq.close();\n    }\n\n    // now do a variety of things that *should* always garuntee a new searcher\n    SolrQueryRequest beforeReq;\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delI(\"1\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n    \n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(adoc(\"id\", \"0\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      assertU(delQ(\"id:[0 TO 5]\"));\n      assertU(commit());\n      assertSearcherHasChanged(before);\n    } finally {\n      beforeReq.close();\n    }\n\n    beforeReq = req(\"q\",\"foo\");\n    try {\n      // NOTE: we *have* to call getSearcher() in advance: delayed binding\n      SolrIndexSearcher before = getMainSearcher(beforeReq);\n\n      // create a new field & add it.\n      assertTrue(\"schema not mutable\", beforeReq.getSchema().isMutable());\n      ManagedIndexSchema oldSchema = (ManagedIndexSchema) beforeReq.getSchema();\n      SchemaField newField = oldSchema.newField\n        (\"hoss\", \"string\", Collections.<String,Object>emptyMap());\n      IndexSchema newSchema = oldSchema.addField(newField);\n      h.getCore().setLatestSchema(newSchema);\n\n      // sanity check, later asserts assume this\n      assertNotSame(oldSchema, newSchema); \n\n      // the schema has changed - but nothing has requested a new Searcher yet\n      assertSearcherHasNotChanged(before);\n\n      // only now should we get a new searcher...\n      assertU(commit(\"softCommit\",\"true\",\"openSearcher\",\"true\"));\n      assertSearcherHasChanged(before);\n\n      // sanity that opening the new searcher was useful to get new schema...\n      SolrQueryRequest afterReq = req(\"q\",\"foo\");\n      try {\n        assertSame(newSchema, afterReq.getSchema());\n        assertSame(newSchema, getMainSearcher(afterReq).getSchema());\n      } finally {\n        afterReq.close();\n      }\n\n    } finally {\n      beforeReq.close();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ffbafffd25b93aa3ae294291ebc172a02333cdb6":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"beea4d4bbebcfb6689ed31936553c5e98bce2871":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e453ee95e5ed4cd001de2d5d3269e25f977980f1":["ffbafffd25b93aa3ae294291ebc172a02333cdb6"],"0e49c5115c9943dedfca7559a7f11921edb1b7a0":["e453ee95e5ed4cd001de2d5d3269e25f977980f1"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["686fc6c072e3cf75fee3f14f8bcb908c7fcb6121","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"686fc6c072e3cf75fee3f14f8bcb908c7fcb6121":["0e49c5115c9943dedfca7559a7f11921edb1b7a0"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["686fc6c072e3cf75fee3f14f8bcb908c7fcb6121","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["686fc6c072e3cf75fee3f14f8bcb908c7fcb6121"]},"commit2Childs":{"ffbafffd25b93aa3ae294291ebc172a02333cdb6":["e453ee95e5ed4cd001de2d5d3269e25f977980f1"],"beea4d4bbebcfb6689ed31936553c5e98bce2871":["ffbafffd25b93aa3ae294291ebc172a02333cdb6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["beea4d4bbebcfb6689ed31936553c5e98bce2871"],"e453ee95e5ed4cd001de2d5d3269e25f977980f1":["0e49c5115c9943dedfca7559a7f11921edb1b7a0"],"0e49c5115c9943dedfca7559a7f11921edb1b7a0":["686fc6c072e3cf75fee3f14f8bcb908c7fcb6121"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"686fc6c072e3cf75fee3f14f8bcb908c7fcb6121":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}