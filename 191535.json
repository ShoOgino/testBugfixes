{"path":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","commits":[{"id":"77cae179618908dcb534af567cdf3019505ada6c","date":1449365361,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    recoveryInfo.positionOfStart = tlog == null ? 0 : tlog.snapshot();\n    state = State.BUFFERING;\n    operationFlags |= FLAG_GAP;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1455c941cc4ce652efc776fc23471b0e499246f6","date":1528086751,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","sourceNew":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    state = State.BUFFERING;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    recoveryInfo.positionOfStart = tlog == null ? 0 : tlog.snapshot();\n    state = State.BUFFERING;\n    operationFlags |= FLAG_GAP;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f592209545c71895260367152601e9200399776d","date":1528238935,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","sourceNew":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    state = State.BUFFERING;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    recoveryInfo.positionOfStart = tlog == null ? 0 : tlog.snapshot();\n    state = State.BUFFERING;\n    operationFlags |= FLAG_GAP;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","sourceNew":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    state = State.BUFFERING;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    recoveryInfo.positionOfStart = tlog == null ? 0 : tlog.snapshot();\n    state = State.BUFFERING;\n    operationFlags |= FLAG_GAP;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"018a36ff4088cb91ab12cbe44f696d81d1fadd77","date":1591657414,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","sourceNew":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    state = State.BUFFERING;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        @SuppressWarnings({\"rawtypes\"})\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    state = State.BUFFERING;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1","date":1598647393,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/update/CdcrUpdateLog#copyBufferedUpdates(File,long,long).mjava","sourceNew":null,"sourceOld":"  /**\n   * <p>\n   *   Read the entries from the given tlog file and replay them as buffered updates.\n   *   The buffered tlog that we are trying to copy might contain duplicate operations with the\n   *   current update log. During the tlog replication process, the replica might buffer update operations\n   *   that will be present also in the tlog files downloaded from the leader. In order to remove these\n   *   duplicates, it will skip any operations with a version inferior to the latest know version.\n   */\n  private void copyBufferedUpdates(File tlogSrc, long offsetSrc, long latestVersion) {\n    recoveryInfo = new RecoveryInfo();\n    state = State.BUFFERING;\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());\n    SolrQueryRequest req = new LocalSolrQueryRequest(uhandler.core, params);\n\n    CdcrTransactionLog src = new CdcrTransactionLog(tlogSrc, null, true);\n    TransactionLog.LogReader tlogReader = src.getReader(offsetSrc);\n    try {\n      int operationAndFlags = 0;\n      for (; ; ) {\n        Object o = tlogReader.next();\n        if (o == null) break; // we reached the end of the tlog\n        // should currently be a List<Oper,Ver,Doc/Id>\n        @SuppressWarnings({\"rawtypes\"})\n        List entry = (List) o;\n        operationAndFlags = (Integer) entry.get(0);\n        int oper = operationAndFlags & OPERATION_MASK;\n        long version = (Long) entry.get(1);\n        if (version <= latestVersion) {\n          // probably a buffered update that is also present in a tlog file coming from the leader,\n          // skip it.\n          log.debug(\"Dropping buffered operation - version {} < {}\", version, latestVersion);\n          continue;\n        }\n\n        switch (oper) {\n          case UpdateLog.ADD: {\n            SolrInputDocument sdoc = (SolrInputDocument) entry.get(entry.size() - 1);\n            AddUpdateCommand cmd = new AddUpdateCommand(req);\n            cmd.solrDoc = sdoc;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.add(cmd);\n            break;\n          }\n          case UpdateLog.DELETE: {\n            byte[] idBytes = (byte[]) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.setIndexedId(new BytesRef(idBytes));\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.delete(cmd);\n            break;\n          }\n\n          case UpdateLog.DELETE_BY_QUERY: {\n            String query = (String) entry.get(2);\n            DeleteUpdateCommand cmd = new DeleteUpdateCommand(req);\n            cmd.query = query;\n            cmd.setVersion(version);\n            cmd.setFlags(UpdateCommand.BUFFERING);\n            this.deleteByQuery(cmd);\n            break;\n          }\n\n          default:\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Invalid Operation! \" + oper);\n        }\n\n      }\n    }\n    catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to copy buffered updates\", e);\n    }\n    finally {\n      try {\n        tlogReader.close();\n      }\n      finally {\n        this.doClose(src);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"77cae179618908dcb534af567cdf3019505ada6c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["1455c941cc4ce652efc776fc23471b0e499246f6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["77cae179618908dcb534af567cdf3019505ada6c","1455c941cc4ce652efc776fc23471b0e499246f6"],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["018a36ff4088cb91ab12cbe44f696d81d1fadd77"],"f592209545c71895260367152601e9200399776d":["77cae179618908dcb534af567cdf3019505ada6c","1455c941cc4ce652efc776fc23471b0e499246f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"1455c941cc4ce652efc776fc23471b0e499246f6":["77cae179618908dcb534af567cdf3019505ada6c"]},"commit2Childs":{"77cae179618908dcb534af567cdf3019505ada6c":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","1455c941cc4ce652efc776fc23471b0e499246f6"],"018a36ff4088cb91ab12cbe44f696d81d1fadd77":["23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["77cae179618908dcb534af567cdf3019505ada6c"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"23ec6d2969d61cadbfd0a5452e9be1f9999e8aa1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f592209545c71895260367152601e9200399776d":[],"1455c941cc4ce652efc776fc23471b0e499246f6":["018a36ff4088cb91ab12cbe44f696d81d1fadd77","b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b70042a8a492f7054d480ccdd2be9796510d4327","f592209545c71895260367152601e9200399776d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}