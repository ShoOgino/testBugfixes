{"path":"solr/core/src/test/org/apache/solr/schema/TestSortableTextField#testRandomStrEquivilentBehavior().mjava","commits":[{"id":"09db84b25dda87b73022d145a68f14c86a3a552d","date":1517506829,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSortableTextField#testRandomStrEquivilentBehavior().mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * tests that a SortableTextField using KeywordTokenzier (w/docValues) behaves exactly the same as \n   * StrFields that it's copied to for quering and sorting\n   */\n  public void testRandomStrEquivilentBehavior() throws Exception {\n    final List<String> test_fields = Arrays.asList(\"keyword_stxt\", \"keyword_dv_stxt\",\n                                                   \"keyword_s_dv\", \"keyword_s\");\n    // we use embedded client instead of assertQ: we want to compare the responses from multiple requests\n    final SolrClient client = new EmbeddedSolrServer(h.getCore());\n    \n    final int numDocs = atLeast(100);\n    final int magicIdx = TestUtil.nextInt(random(), 1, numDocs);\n    String magic = null;\n    for (int i = 1; i <= numDocs; i++) {\n\n      // ideally we'd test all \"realistic\" unicode string, but EmbeddedSolrServer uses XML request writer\n      // and has no option to change this so ctrl-characters break the request\n      final String val = TestUtil.randomSimpleString(random(), 100);\n      if (i == magicIdx) {\n        magic = val;\n      }\n      assertEquals(0, client.add(sdoc(\"id\", \"\"+i, \"keyword_stxt\", val)).getStatus());\n      \n    }\n    assertNotNull(magic);\n    \n    assertEquals(0, client.commit().getStatus());\n\n    // query for magic term should match same doc regardless of field (reminder: keyword tokenizer)\n    // (we need the filter in the unlikely event that magic value with randomly picked twice)\n    for (String f : test_fields) {\n      \n      final SolrDocumentList results = client.query(params(\"q\", \"{!field f=\"+f+\" v=$v}\",\n                                                           \"v\", magic,\n                                                           \"fq\", \"id:\" + magicIdx )).getResults();\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + results,\n                   1L, results.getNumFound());\n      final SolrDocument doc = results.get(0);\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   \"\"+magicIdx, doc.getFieldValue(\"id\"));\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   magic, doc.getFieldValue(f));\n    }\n\n    // do some random id range queries using all 3 fields for sorting.  results should be identical\n    final int numQ = atLeast(10);\n    for (int i = 0; i < numQ; i++) {\n      final int hi = TestUtil.nextInt(random(), 1, numDocs-1);\n      final int lo = TestUtil.nextInt(random(), 1, hi);\n      final boolean fwd = random().nextBoolean();\n      \n      SolrDocumentList previous = null;\n      String prevField = null;\n      for (String f : test_fields) {\n        final SolrDocumentList results = client.query(params(\"q\",\"id_i:[\"+lo+\" TO \"+hi+\"]\",\n                                                             \"sort\", f + (fwd ? \" asc\" : \" desc\") +\n                                                             // secondary on id for determinism\n                                                             \", id asc\")\n                                                      ).getResults();\n        assertEquals(results.toString(), (1L + hi - lo), results.getNumFound());\n        if (null != previous) {\n          assertEquals(prevField + \" vs \" + f,\n                       previous.getNumFound(), results.getNumFound());\n          for (int d = 0; d < results.size(); d++) {\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(\"id\"),\n                         results.get(d).getFieldValue(\"id\"));\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(prevField),\n                         results.get(d).getFieldValue(f));\n            \n          }\n        }\n        previous = results;\n        prevField = f;\n      }\n    }\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f15af35d55d70c34451f9df5edeaeff6b31f8cbe","date":1519625627,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSortableTextField#testRandomStrEquivilentBehavior().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestSortableTextField#testRandomStrEquivilentBehavior().mjava","sourceNew":"  /**\n   * tests that a SortableTextField using KeywordTokenzier (w/docValues) behaves exactly the same as \n   * StrFields that it's copied to for quering and sorting\n   */\n  public void testRandomStrEquivilentBehavior() throws Exception {\n    final List<String> test_fields = Arrays.asList(\"keyword_stxt\", \"keyword_dv_stxt\",\n                                                   \"keyword_s_dv\", \"keyword_s\");\n    // we use embedded client instead of assertQ: we want to compare the responses from multiple requests\n    @SuppressWarnings(\"resource\") final SolrClient client = new EmbeddedSolrServer(h.getCore());\n    \n    final int numDocs = atLeast(100);\n    final int magicIdx = TestUtil.nextInt(random(), 1, numDocs);\n    String magic = null;\n    for (int i = 1; i <= numDocs; i++) {\n\n      // ideally we'd test all \"realistic\" unicode string, but EmbeddedSolrServer uses XML request writer\n      // and has no option to change this so ctrl-characters break the request\n      final String val = TestUtil.randomSimpleString(random(), 100);\n      if (i == magicIdx) {\n        magic = val;\n      }\n      assertEquals(0, client.add(sdoc(\"id\", \"\"+i, \"keyword_stxt\", val)).getStatus());\n      \n    }\n    assertNotNull(magic);\n    \n    assertEquals(0, client.commit().getStatus());\n\n    // query for magic term should match same doc regardless of field (reminder: keyword tokenizer)\n    // (we need the filter in the unlikely event that magic value with randomly picked twice)\n    for (String f : test_fields) {\n      \n      final SolrDocumentList results = client.query(params(\"q\", \"{!field f=\"+f+\" v=$v}\",\n                                                           \"v\", magic,\n                                                           \"fq\", \"id:\" + magicIdx )).getResults();\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + results,\n                   1L, results.getNumFound());\n      final SolrDocument doc = results.get(0);\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   \"\"+magicIdx, doc.getFieldValue(\"id\"));\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   magic, doc.getFieldValue(f));\n    }\n\n    // do some random id range queries using all 3 fields for sorting.  results should be identical\n    final int numQ = atLeast(10);\n    for (int i = 0; i < numQ; i++) {\n      final int hi = TestUtil.nextInt(random(), 1, numDocs-1);\n      final int lo = TestUtil.nextInt(random(), 1, hi);\n      final boolean fwd = random().nextBoolean();\n      \n      SolrDocumentList previous = null;\n      String prevField = null;\n      for (String f : test_fields) {\n        final SolrDocumentList results = client.query(params(\"q\",\"id_i:[\"+lo+\" TO \"+hi+\"]\",\n                                                             \"sort\", f + (fwd ? \" asc\" : \" desc\") +\n                                                             // secondary on id for determinism\n                                                             \", id asc\")\n                                                      ).getResults();\n        assertEquals(results.toString(), (1L + hi - lo), results.getNumFound());\n        if (null != previous) {\n          assertEquals(prevField + \" vs \" + f,\n                       previous.getNumFound(), results.getNumFound());\n          for (int d = 0; d < results.size(); d++) {\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(\"id\"),\n                         results.get(d).getFieldValue(\"id\"));\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(prevField),\n                         results.get(d).getFieldValue(f));\n            \n          }\n        }\n        previous = results;\n        prevField = f;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /**\n   * tests that a SortableTextField using KeywordTokenzier (w/docValues) behaves exactly the same as \n   * StrFields that it's copied to for quering and sorting\n   */\n  public void testRandomStrEquivilentBehavior() throws Exception {\n    final List<String> test_fields = Arrays.asList(\"keyword_stxt\", \"keyword_dv_stxt\",\n                                                   \"keyword_s_dv\", \"keyword_s\");\n    // we use embedded client instead of assertQ: we want to compare the responses from multiple requests\n    final SolrClient client = new EmbeddedSolrServer(h.getCore());\n    \n    final int numDocs = atLeast(100);\n    final int magicIdx = TestUtil.nextInt(random(), 1, numDocs);\n    String magic = null;\n    for (int i = 1; i <= numDocs; i++) {\n\n      // ideally we'd test all \"realistic\" unicode string, but EmbeddedSolrServer uses XML request writer\n      // and has no option to change this so ctrl-characters break the request\n      final String val = TestUtil.randomSimpleString(random(), 100);\n      if (i == magicIdx) {\n        magic = val;\n      }\n      assertEquals(0, client.add(sdoc(\"id\", \"\"+i, \"keyword_stxt\", val)).getStatus());\n      \n    }\n    assertNotNull(magic);\n    \n    assertEquals(0, client.commit().getStatus());\n\n    // query for magic term should match same doc regardless of field (reminder: keyword tokenizer)\n    // (we need the filter in the unlikely event that magic value with randomly picked twice)\n    for (String f : test_fields) {\n      \n      final SolrDocumentList results = client.query(params(\"q\", \"{!field f=\"+f+\" v=$v}\",\n                                                           \"v\", magic,\n                                                           \"fq\", \"id:\" + magicIdx )).getResults();\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + results,\n                   1L, results.getNumFound());\n      final SolrDocument doc = results.get(0);\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   \"\"+magicIdx, doc.getFieldValue(\"id\"));\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   magic, doc.getFieldValue(f));\n    }\n\n    // do some random id range queries using all 3 fields for sorting.  results should be identical\n    final int numQ = atLeast(10);\n    for (int i = 0; i < numQ; i++) {\n      final int hi = TestUtil.nextInt(random(), 1, numDocs-1);\n      final int lo = TestUtil.nextInt(random(), 1, hi);\n      final boolean fwd = random().nextBoolean();\n      \n      SolrDocumentList previous = null;\n      String prevField = null;\n      for (String f : test_fields) {\n        final SolrDocumentList results = client.query(params(\"q\",\"id_i:[\"+lo+\" TO \"+hi+\"]\",\n                                                             \"sort\", f + (fwd ? \" asc\" : \" desc\") +\n                                                             // secondary on id for determinism\n                                                             \", id asc\")\n                                                      ).getResults();\n        assertEquals(results.toString(), (1L + hi - lo), results.getNumFound());\n        if (null != previous) {\n          assertEquals(prevField + \" vs \" + f,\n                       previous.getNumFound(), results.getNumFound());\n          for (int d = 0; d < results.size(); d++) {\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(\"id\"),\n                         results.get(d).getFieldValue(\"id\"));\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(prevField),\n                         results.get(d).getFieldValue(f));\n            \n          }\n        }\n        previous = results;\n        prevField = f;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f4251f14d2db68330fc1e6f0495c053a905d560","date":1537116380,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/schema/TestSortableTextField#testRandomStrEquivalentBehavior().mjava","pathOld":"solr/core/src/test/org/apache/solr/schema/TestSortableTextField#testRandomStrEquivilentBehavior().mjava","sourceNew":"  /**\n   * tests that a SortableTextField using KeywordTokenzier (w/docValues) behaves exactly the same as \n   * StrFields that it's copied to for quering and sorting\n   */\n  public void testRandomStrEquivalentBehavior() throws Exception {\n    final List<String> test_fields = Arrays.asList(\"keyword_stxt\", \"keyword_dv_stxt\",\n                                                   \"keyword_s_dv\", \"keyword_s\");\n    // we use embedded client instead of assertQ: we want to compare the responses from multiple requests\n    @SuppressWarnings(\"resource\") final SolrClient client = new EmbeddedSolrServer(h.getCore());\n    \n    final int numDocs = atLeast(100);\n    final int magicIdx = TestUtil.nextInt(random(), 1, numDocs);\n    String magic = null;\n    for (int i = 1; i <= numDocs; i++) {\n\n      // ideally we'd test all \"realistic\" unicode string, but EmbeddedSolrServer uses XML request writer\n      // and has no option to change this so ctrl-characters break the request\n      final String val = TestUtil.randomSimpleString(random(), 100);\n      if (i == magicIdx) {\n        magic = val;\n      }\n      assertEquals(0, client.add(sdoc(\"id\", \"\"+i, \"keyword_stxt\", val)).getStatus());\n      \n    }\n    assertNotNull(magic);\n    \n    assertEquals(0, client.commit().getStatus());\n\n    // query for magic term should match same doc regardless of field (reminder: keyword tokenizer)\n    // (we need the filter in the unlikely event that magic value with randomly picked twice)\n    for (String f : test_fields) {\n      \n      final SolrDocumentList results = client.query(params(\"q\", \"{!field f=\"+f+\" v=$v}\",\n                                                           \"v\", magic,\n                                                           \"fq\", \"id:\" + magicIdx )).getResults();\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + results,\n                   1L, results.getNumFound());\n      final SolrDocument doc = results.get(0);\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   \"\"+magicIdx, doc.getFieldValue(\"id\"));\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   magic, doc.getFieldValue(f));\n    }\n\n    // do some random id range queries using all 3 fields for sorting.  results should be identical\n    final int numQ = atLeast(10);\n    for (int i = 0; i < numQ; i++) {\n      final int hi = TestUtil.nextInt(random(), 1, numDocs-1);\n      final int lo = TestUtil.nextInt(random(), 1, hi);\n      final boolean fwd = random().nextBoolean();\n      \n      SolrDocumentList previous = null;\n      String prevField = null;\n      for (String f : test_fields) {\n        final SolrDocumentList results = client.query(params(\"q\",\"id_i:[\"+lo+\" TO \"+hi+\"]\",\n                                                             \"sort\", f + (fwd ? \" asc\" : \" desc\") +\n                                                             // secondary on id for determinism\n                                                             \", id asc\")\n                                                      ).getResults();\n        assertEquals(results.toString(), (1L + hi - lo), results.getNumFound());\n        if (null != previous) {\n          assertEquals(prevField + \" vs \" + f,\n                       previous.getNumFound(), results.getNumFound());\n          for (int d = 0; d < results.size(); d++) {\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(\"id\"),\n                         results.get(d).getFieldValue(\"id\"));\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(prevField),\n                         results.get(d).getFieldValue(f));\n            \n          }\n        }\n        previous = results;\n        prevField = f;\n      }\n    }\n    \n  }\n\n","sourceOld":"  /**\n   * tests that a SortableTextField using KeywordTokenzier (w/docValues) behaves exactly the same as \n   * StrFields that it's copied to for quering and sorting\n   */\n  public void testRandomStrEquivilentBehavior() throws Exception {\n    final List<String> test_fields = Arrays.asList(\"keyword_stxt\", \"keyword_dv_stxt\",\n                                                   \"keyword_s_dv\", \"keyword_s\");\n    // we use embedded client instead of assertQ: we want to compare the responses from multiple requests\n    @SuppressWarnings(\"resource\") final SolrClient client = new EmbeddedSolrServer(h.getCore());\n    \n    final int numDocs = atLeast(100);\n    final int magicIdx = TestUtil.nextInt(random(), 1, numDocs);\n    String magic = null;\n    for (int i = 1; i <= numDocs; i++) {\n\n      // ideally we'd test all \"realistic\" unicode string, but EmbeddedSolrServer uses XML request writer\n      // and has no option to change this so ctrl-characters break the request\n      final String val = TestUtil.randomSimpleString(random(), 100);\n      if (i == magicIdx) {\n        magic = val;\n      }\n      assertEquals(0, client.add(sdoc(\"id\", \"\"+i, \"keyword_stxt\", val)).getStatus());\n      \n    }\n    assertNotNull(magic);\n    \n    assertEquals(0, client.commit().getStatus());\n\n    // query for magic term should match same doc regardless of field (reminder: keyword tokenizer)\n    // (we need the filter in the unlikely event that magic value with randomly picked twice)\n    for (String f : test_fields) {\n      \n      final SolrDocumentList results = client.query(params(\"q\", \"{!field f=\"+f+\" v=$v}\",\n                                                           \"v\", magic,\n                                                           \"fq\", \"id:\" + magicIdx )).getResults();\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + results,\n                   1L, results.getNumFound());\n      final SolrDocument doc = results.get(0);\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   \"\"+magicIdx, doc.getFieldValue(\"id\"));\n      assertEquals(f + \": Query (\"+magic+\") filtered by id: \" + magicIdx + \" ==> \" + doc,\n                   magic, doc.getFieldValue(f));\n    }\n\n    // do some random id range queries using all 3 fields for sorting.  results should be identical\n    final int numQ = atLeast(10);\n    for (int i = 0; i < numQ; i++) {\n      final int hi = TestUtil.nextInt(random(), 1, numDocs-1);\n      final int lo = TestUtil.nextInt(random(), 1, hi);\n      final boolean fwd = random().nextBoolean();\n      \n      SolrDocumentList previous = null;\n      String prevField = null;\n      for (String f : test_fields) {\n        final SolrDocumentList results = client.query(params(\"q\",\"id_i:[\"+lo+\" TO \"+hi+\"]\",\n                                                             \"sort\", f + (fwd ? \" asc\" : \" desc\") +\n                                                             // secondary on id for determinism\n                                                             \", id asc\")\n                                                      ).getResults();\n        assertEquals(results.toString(), (1L + hi - lo), results.getNumFound());\n        if (null != previous) {\n          assertEquals(prevField + \" vs \" + f,\n                       previous.getNumFound(), results.getNumFound());\n          for (int d = 0; d < results.size(); d++) {\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(\"id\"),\n                         results.get(d).getFieldValue(\"id\"));\n            assertEquals(prevField + \" vs \" + f + \": \" + d,\n                         previous.get(d).getFieldValue(prevField),\n                         results.get(d).getFieldValue(f));\n            \n          }\n        }\n        previous = results;\n        prevField = f;\n      }\n    }\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"09db84b25dda87b73022d145a68f14c86a3a552d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["09db84b25dda87b73022d145a68f14c86a3a552d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9f4251f14d2db68330fc1e6f0495c053a905d560"]},"commit2Childs":{"9f4251f14d2db68330fc1e6f0495c053a905d560":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"09db84b25dda87b73022d145a68f14c86a3a552d":["f15af35d55d70c34451f9df5edeaeff6b31f8cbe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["09db84b25dda87b73022d145a68f14c86a3a552d"],"f15af35d55d70c34451f9df5edeaeff6b31f8cbe":["9f4251f14d2db68330fc1e6f0495c053a905d560"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}