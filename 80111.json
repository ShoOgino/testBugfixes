{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f08557cdb6c60ac7b88a9342c983a20cd236e74f","date":1330954480,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings(\"unchecked\") final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings(\"unchecked\") final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<IntPair>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<State>();\n      partition[q] = new HashSet<State>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<State>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4ef381bf0c2d618c6db830d3dd668c6901c05a","date":1402592253,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":null,"sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperationsLight#minimizeHopcroft(LightAutomaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static LightAutomaton minimizeHopcroft(LightAutomaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new LightAutomaton();\n    }\n    a = BasicOperations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    LightAutomaton result = new LightAutomaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return BasicOperations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bab620c8ab32bb77a62753eca4afb8e47efa87c","date":1402997861,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = a.totalize();\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static void minimizeHopcroft(Automaton a) {\n    a.determinize();\n    if (a.initial.numTransitions == 1) {\n      Transition t = a.initial.transitionsArray[0];\n      if (t.to == a.initial && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) return;\n    }\n    a.totalize();\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final State[] states = a.getNumberedStates();\n    final int sigmaLen = sigma.length, statesLen = states.length;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[][] reverse =\n      (ArrayList<State>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<State>[] partition =\n      (HashSet<State>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<State>[] splitblock =\n      (ArrayList<State>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final State qq = states[q];\n      final int j = qq.accept ? 0 : 1;\n      partition[j].add(qq);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<State>[] r =\n          reverse[qq.step(sigma[x]).number];\n        if (r[x] == null)\n          r[x] = new ArrayList<>();\n        r[x].add(qq);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (final State qq : partition[j]) {\n          if (reverse[qq.number][x] != null)\n            active2[qq.number][x] = active[j][x].add(qq);\n        }\n      }\n    }\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n    // process pending until fixed point\n    int k = 2;\n    while (!pending.isEmpty()) {\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<State> r = reverse[m.q.number][x];\n        if (r != null) for (final State s : r) {\n          final int i = s.number;\n          if (!split.get(i)) {\n            split.set(i);\n            final int j = block[i];\n            splitblock[j].add(s);\n            if (!refine2.get(j)) {\n              refine2.set(j);\n              refine.set(j);\n            }\n          }\n        }\n      }\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<State> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<State> b1 = partition[j];\n          final HashSet<State> b2 = partition[k];\n          for (final State s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s.number] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s.number][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s.number][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (final State s : sb)\n          split.clear(s.number);\n        sb.clear();\n      }\n      refine.clear();\n    }\n    // make a new state for each equivalence class, set initial state\n    State[] newstates = new State[k];\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = new State();\n      newstates[n] = s;\n      for (State q : partition[n]) {\n        if (q == a.initial) a.initial = s;\n        s.accept = q.accept;\n        s.number = q.number; // select representative\n        q.number = n;\n      }\n    }\n    // build transitions and set acceptance\n    for (int n = 0; n < newstates.length; n++) {\n      final State s = newstates[n];\n      s.accept = states[s.number].accept;\n      for (Transition t : states[s.number].getTransitions())\n        s.addTransition(new Transition(t.min, t.max, newstates[t.to.number]));\n    }\n    a.clearNumberedStates();\n    a.removeDeadTransitions();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b316f82baae88f5e279893a9cb7eee51fd8902f","date":1415131390,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimize(Automaton,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/MinimizationOperations#minimizeHopcroft(Automaton).mjava","sourceNew":"  /**\n   * Minimizes (and determinizes if not already deterministic) the given\n   * automaton using Hopcroft's algorighm.\n   * @param maxDeterminizedStates maximum number of states determinizing the\n   *  automaton can result in.  Set higher to allow more complex queries and\n   *  lower to prevent memory exhaustion.\n   */\n  public static Automaton minimize(Automaton a, int maxDeterminizedStates) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a, maxDeterminizedStates);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","sourceOld":"  /**\n   * Minimizes the given automaton using Hopcroft's algorithm.\n   */\n  public static Automaton minimizeHopcroft(Automaton a) {\n    if (a.getNumStates() == 0 || (a.isAccept(0) == false && a.getNumTransitions(0) == 0)) {\n      // Fastmatch for common case\n      return new Automaton();\n    }\n    a = Operations.determinize(a);\n    //a.writeDot(\"adet\");\n    if (a.getNumTransitions(0) == 1) {\n      Transition t = new Transition();\n      a.getTransition(0, 0, t);\n      if (t.dest == 0 && t.min == Character.MIN_CODE_POINT\n          && t.max == Character.MAX_CODE_POINT) {\n        // Accepts all strings\n        return a;\n      }\n    }\n    a = Operations.totalize(a);\n    //a.writeDot(\"atot\");\n\n    // initialize data structures\n    final int[] sigma = a.getStartPoints();\n    final int sigmaLen = sigma.length, statesLen = a.getNumStates();\n\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[][] reverse =\n      (ArrayList<Integer>[][]) new ArrayList[statesLen][sigmaLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final HashSet<Integer>[] partition =\n      (HashSet<Integer>[]) new HashSet[statesLen];\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final ArrayList<Integer>[] splitblock =\n      (ArrayList<Integer>[]) new ArrayList[statesLen];\n    final int[] block = new int[statesLen];\n    final StateList[][] active = new StateList[statesLen][sigmaLen];\n    final StateListNode[][] active2 = new StateListNode[statesLen][sigmaLen];\n    final LinkedList<IntPair> pending = new LinkedList<>();\n    final BitSet pending2 = new BitSet(sigmaLen*statesLen);\n    final BitSet split = new BitSet(statesLen), \n      refine = new BitSet(statesLen), refine2 = new BitSet(statesLen);\n    for (int q = 0; q < statesLen; q++) {\n      splitblock[q] = new ArrayList<>();\n      partition[q] = new HashSet<>();\n      for (int x = 0; x < sigmaLen; x++) {\n        active[q][x] = new StateList();\n      }\n    }\n    // find initial partition and reverse edges\n    for (int q = 0; q < statesLen; q++) {\n      final int j = a.isAccept(q) ? 0 : 1;\n      partition[j].add(q);\n      block[q] = j;\n      for (int x = 0; x < sigmaLen; x++) {\n        final ArrayList<Integer>[] r = reverse[a.step(q, sigma[x])];\n        if (r[x] == null) {\n          r[x] = new ArrayList<>();\n        }\n        r[x].add(q);\n      }\n    }\n    // initialize active sets\n    for (int j = 0; j <= 1; j++) {\n      for (int x = 0; x < sigmaLen; x++) {\n        for (int q : partition[j]) {\n          if (reverse[q][x] != null) {\n            active2[q][x] = active[j][x].add(q);\n          }\n        }\n      }\n    }\n\n    // initialize pending\n    for (int x = 0; x < sigmaLen; x++) {\n      final int j = (active[0][x].size <= active[1][x].size) ? 0 : 1;\n      pending.add(new IntPair(j, x));\n      pending2.set(x*statesLen + j);\n    }\n\n    // process pending until fixed point\n    int k = 2;\n    //System.out.println(\"start min\");\n    while (!pending.isEmpty()) {\n      //System.out.println(\"  cycle pending\");\n      final IntPair ip = pending.removeFirst();\n      final int p = ip.n1;\n      final int x = ip.n2;\n      //System.out.println(\"    pop n1=\" + ip.n1 + \" n2=\" + ip.n2);\n      pending2.clear(x*statesLen + p);\n      // find states that need to be split off their blocks\n      for (StateListNode m = active[p][x].first; m != null; m = m.next) {\n        final ArrayList<Integer> r = reverse[m.q][x];\n        if (r != null) {\n          for (int i : r) {\n            if (!split.get(i)) {\n              split.set(i);\n              final int j = block[i];\n              splitblock[j].add(i);\n              if (!refine2.get(j)) {\n                refine2.set(j);\n                refine.set(j);\n              }\n            }\n          }\n        }\n      }\n\n      // refine blocks\n      for (int j = refine.nextSetBit(0); j >= 0; j = refine.nextSetBit(j+1)) {\n        final ArrayList<Integer> sb = splitblock[j];\n        if (sb.size() < partition[j].size()) {\n          final HashSet<Integer> b1 = partition[j];\n          final HashSet<Integer> b2 = partition[k];\n          for (int s : sb) {\n            b1.remove(s);\n            b2.add(s);\n            block[s] = k;\n            for (int c = 0; c < sigmaLen; c++) {\n              final StateListNode sn = active2[s][c];\n              if (sn != null && sn.sl == active[j][c]) {\n                sn.remove();\n                active2[s][c] = active[k][c].add(s);\n              }\n            }\n          }\n          // update pending\n          for (int c = 0; c < sigmaLen; c++) {\n            final int aj = active[j][c].size,\n              ak = active[k][c].size,\n              ofs = c*statesLen;\n            if (!pending2.get(ofs + j) && 0 < aj && aj <= ak) {\n              pending2.set(ofs + j);\n              pending.add(new IntPair(j, c));\n            } else {\n              pending2.set(ofs + k);\n              pending.add(new IntPair(k, c));\n            }\n          }\n          k++;\n        }\n        refine2.clear(j);\n        for (int s : sb) {\n          split.clear(s);\n        }\n        sb.clear();\n      }\n      refine.clear();\n    }\n\n    Automaton result = new Automaton();\n\n    Transition t = new Transition();\n\n    //System.out.println(\"  k=\" + k);\n\n    // make a new state for each equivalence class, set initial state\n    int[] stateMap = new int[statesLen];\n    int[] stateRep = new int[k];\n\n    result.createState();\n\n    //System.out.println(\"min: k=\" + k);\n    for (int n = 0; n < k; n++) {\n      //System.out.println(\"    n=\" + n);\n\n      boolean isInitial = false;\n      for (int q : partition[n]) {\n        if (q == 0) {\n          isInitial = true;\n          //System.out.println(\"    isInitial!\");\n          break;\n        }\n      }\n\n      int newState;\n      if (isInitial) {\n        newState = 0;\n      } else {\n        newState = result.createState();\n      }\n\n      //System.out.println(\"  newState=\" + newState);\n\n      for (int q : partition[n]) {\n        stateMap[q] = newState;\n        //System.out.println(\"      q=\" + q + \" isAccept?=\" + a.isAccept(q));\n        result.setAccept(newState, a.isAccept(q));\n        stateRep[newState] = q;   // select representative\n      }\n    }\n\n    // build transitions and set acceptance\n    for (int n = 0; n < k; n++) {\n      int numTransitions = a.initTransition(stateRep[n], t);\n      for(int i=0;i<numTransitions;i++) {\n        a.getNextTransition(t);\n        //System.out.println(\"  add trans\");\n        result.addTransition(n, stateMap[t.dest], t.min, t.max);\n      }\n    }\n    result.finishState();\n    //System.out.println(result.getNumStates() + \" states\");\n\n    return Operations.removeDeadStates(result);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"6bab620c8ab32bb77a62753eca4afb8e47efa87c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["5c84485629d80d203608e8975a1139de9933cc38"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","6bab620c8ab32bb77a62753eca4afb8e47efa87c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8b316f82baae88f5e279893a9cb7eee51fd8902f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7f4ef381bf0c2d618c6db830d3dd668c6901c05a","5c84485629d80d203608e8975a1139de9933cc38"],"6bab620c8ab32bb77a62753eca4afb8e47efa87c":["5c84485629d80d203608e8975a1139de9933cc38"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"f08557cdb6c60ac7b88a9342c983a20cd236e74f":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","f08557cdb6c60ac7b88a9342c983a20cd236e74f"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["6bab620c8ab32bb77a62753eca4afb8e47efa87c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"7f4ef381bf0c2d618c6db830d3dd668c6901c05a":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"8b316f82baae88f5e279893a9cb7eee51fd8902f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5c84485629d80d203608e8975a1139de9933cc38":["8b316f82baae88f5e279893a9cb7eee51fd8902f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}