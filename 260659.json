{"path":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","commits":[{"id":"de3459a54b4c8751d9ef19b035577e2418064be7","date":1520297996,"type":0,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n    \n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14ad5f6d86e47603e934be859694ffbba27cd436","date":1522709785,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","sourceNew":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        log.info(\"collection properties changed. Now: {}\",  collectionProperties);\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n    \n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n  }\n\n","sourceOld":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n    \n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"18203691ab20d0fcb1286227878fd1b7d6097994","date":1565030972,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","sourceNew":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n\n    // NOTE: Using a semaphore to ensure we wait for Watcher to fire before proceeding with\n    // test logic, to prevent triggering SOLR-13678\n    final Semaphore sawExpectedProps = new Semaphore(0);\n    final AtomicReference<Map<String,String>> expectedProps\n      = new AtomicReference<Map<String,String>>(null);\n    \n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        log.info(\"collection properties changed. Now: {}\",  collectionProperties);\n        final Map<String,String> expected = expectedProps.get();\n        if (expected != null && expected.equals(collectionProperties)) {\n          log.info(\"...new props match expected\");\n          sawExpectedProps.release();\n        }\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n\n    // HACK: don't let our watcher be removed until we're sure it's \"up to date\"\n    // with the final prop values expected below...\n    expectedProps.set(new HashMap<>());\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n\n    assertTrue(\"Gave up waitng an excessive amount of time for watcher to see final expected props\",\n               sawExpectedProps.tryAcquire(1, 120, TimeUnit.SECONDS));\n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n    \n  }\n\n","sourceOld":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        log.info(\"collection properties changed. Now: {}\",  collectionProperties);\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n    \n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","date":1565097295,"type":3,"author":"Jan Høydahl","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionPropsTest#testReadWriteCached().mjava","sourceNew":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n\n    // NOTE: Using a semaphore to ensure we wait for Watcher to fire before proceeding with\n    // test logic, to prevent triggering SOLR-13678\n    final Semaphore sawExpectedProps = new Semaphore(0);\n    final AtomicReference<Map<String,String>> expectedProps\n      = new AtomicReference<Map<String,String>>(null);\n    \n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        log.info(\"collection properties changed. Now: {}\",  collectionProperties);\n        final Map<String,String> expected = expectedProps.get();\n        if (expected != null && expected.equals(collectionProperties)) {\n          log.info(\"...new props match expected\");\n          sawExpectedProps.release();\n        }\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n\n    // HACK: don't let our watcher be removed until we're sure it's \"up to date\"\n    // with the final prop values expected below...\n    expectedProps.set(new HashMap<>());\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n\n    assertTrue(\"Gave up waitng an excessive amount of time for watcher to see final expected props\",\n               sawExpectedProps.tryAcquire(1, 120, TimeUnit.SECONDS));\n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n    \n  }\n\n","sourceOld":"  @Test\n  public void testReadWriteCached() throws InterruptedException, IOException {\n    CollectionProperties collectionProps = new CollectionProperties(zkClient());\n    final CollectionPropsWatcher w = new CollectionPropsWatcher() {\n      @Override\n      public boolean onStateChanged(Map<String,String> collectionProperties) {\n        log.info(\"collection properties changed. Now: {}\",  collectionProperties);\n        return false;\n      }\n    };\n    \n    cluster.getSolrClient().getZkStateReader().registerCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"value2\");\n    waitForValue(\"property1\", \"value1\", 5000);\n    waitForValue(\"property2\", \"value2\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\"); // no change\n    checkValue(\"property1\", \"value1\");\n\n    collectionProps.setCollectionProperty(collectionName, \"property1\", null);\n    collectionProps.setCollectionProperty(collectionName, \"property2\", \"newValue\");\n    waitForValue(\"property1\", null, 5000);\n    waitForValue(\"property2\", \"newValue\", 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null);\n    waitForValue(\"property2\", null, 5000);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property2\", null); // no change\n    checkValue(\"property2\", null);\n    \n    cluster.getSolrClient().getZkStateReader().removeCollectionPropsWatcher(collectionName, w);\n    \n    collectionProps.setCollectionProperty(collectionName, \"property1\", \"value1\");\n    checkValue(\"property1\", \"value1\"); //Should be no cache, so the change should take effect immediately\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"18203691ab20d0fcb1286227878fd1b7d6097994":["14ad5f6d86e47603e934be859694ffbba27cd436"],"de3459a54b4c8751d9ef19b035577e2418064be7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14ad5f6d86e47603e934be859694ffbba27cd436":["de3459a54b4c8751d9ef19b035577e2418064be7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":["14ad5f6d86e47603e934be859694ffbba27cd436","18203691ab20d0fcb1286227878fd1b7d6097994"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["18203691ab20d0fcb1286227878fd1b7d6097994"]},"commit2Childs":{"18203691ab20d0fcb1286227878fd1b7d6097994":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"de3459a54b4c8751d9ef19b035577e2418064be7":["14ad5f6d86e47603e934be859694ffbba27cd436"],"14ad5f6d86e47603e934be859694ffbba27cd436":["18203691ab20d0fcb1286227878fd1b7d6097994","d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["de3459a54b4c8751d9ef19b035577e2418064be7"],"d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d8daa7a1d5d0c033d73962d5ca3bf3f9c9687693","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}