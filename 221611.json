{"path":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","pathOld":"/dev/null","sourceNew":"  /** Test Terms.intersect on this range, and validates that it returns the same doc ids as using non-intersect TermsEnum.  Returns true if\n   *  any fake terms were seen. */\n  private static boolean checkSingleTermRange(String field, int maxDoc, Terms terms, BytesRef minTerm, BytesRef maxTerm, FixedBitSet normalDocs, FixedBitSet intersectDocs) throws IOException {\n    // System.out.println(\"  check minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n\n    TermsEnum termsEnum = terms.iterator(null);\n    TermsEnum.SeekStatus status = termsEnum.seekCeil(minTerm);\n    if (status != TermsEnum.SeekStatus.FOUND) {\n      throw new RuntimeException(\"failed to seek to existing term field=\" + field + \" term=\" + minTerm);\n    }\n\n    // Do \"dumb\" iteration to visit all terms in the range:\n    long normalTermCount = getDocsFromTermRange(field, maxDoc, termsEnum, normalDocs, minTerm, maxTerm, false);\n\n    // Now do the same operation using intersect:\n    long intersectTermCount = getDocsFromTermRange(field, maxDoc, terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, true, maxTerm, false), true, false, Integer.MAX_VALUE, true), null), intersectDocs, minTerm, maxTerm, true);\n\n    if (intersectTermCount > normalTermCount) {\n      throw new RuntimeException(\"intersect returned too many terms: field=\" + field + \" intersectTermCount=\" + intersectTermCount + \" normalTermCount=\" + normalTermCount);\n    }\n\n    if (normalDocs.equals(intersectDocs) == false) {\n      throw new RuntimeException(\"intersect visited different docs than straight terms enum: \" + normalDocs.cardinality() + \" for straight enum, vs \" + intersectDocs.cardinality() + \" for intersect, minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n    }\n    //System.out.println(\"    \" + intersectTermCount + \" vs \" + normalTermCount);\n    return intersectTermCount != normalTermCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","pathOld":"/dev/null","sourceNew":"  /** Test Terms.intersect on this range, and validates that it returns the same doc ids as using non-intersect TermsEnum.  Returns true if\n   *  any fake terms were seen. */\n  private static boolean checkSingleTermRange(String field, int maxDoc, Terms terms, BytesRef minTerm, BytesRef maxTerm, FixedBitSet normalDocs, FixedBitSet intersectDocs) throws IOException {\n    // System.out.println(\"  check minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n\n    TermsEnum termsEnum = terms.iterator(null);\n    TermsEnum.SeekStatus status = termsEnum.seekCeil(minTerm);\n    if (status != TermsEnum.SeekStatus.FOUND) {\n      throw new RuntimeException(\"failed to seek to existing term field=\" + field + \" term=\" + minTerm);\n    }\n\n    // Do \"dumb\" iteration to visit all terms in the range:\n    long normalTermCount = getDocsFromTermRange(field, maxDoc, termsEnum, normalDocs, minTerm, maxTerm, false);\n\n    // Now do the same operation using intersect:\n    long intersectTermCount = getDocsFromTermRange(field, maxDoc, terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, true, maxTerm, false), true, false, Integer.MAX_VALUE, true), null), intersectDocs, minTerm, maxTerm, true);\n\n    if (intersectTermCount > normalTermCount) {\n      throw new RuntimeException(\"intersect returned too many terms: field=\" + field + \" intersectTermCount=\" + intersectTermCount + \" normalTermCount=\" + normalTermCount);\n    }\n\n    if (normalDocs.equals(intersectDocs) == false) {\n      throw new RuntimeException(\"intersect visited different docs than straight terms enum: \" + normalDocs.cardinality() + \" for straight enum, vs \" + intersectDocs.cardinality() + \" for intersect, minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n    }\n    //System.out.println(\"    \" + intersectTermCount + \" vs \" + normalTermCount);\n    return intersectTermCount != normalTermCount;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"372b4e16bc7ce0e14dccdc44b8cb31888f7402ab","date":1428224042,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","sourceNew":"  /** Test Terms.intersect on this range, and validates that it returns the same doc ids as using non-intersect TermsEnum.  Returns true if\n   *  any fake terms were seen. */\n  private static boolean checkSingleTermRange(String field, int maxDoc, Terms terms, BytesRef minTerm, BytesRef maxTerm, FixedBitSet normalDocs, FixedBitSet intersectDocs) throws IOException {\n    //System.out.println(\"    check minTerm=\" + minTerm.utf8ToString() + \" maxTerm=\" + maxTerm.utf8ToString());\n    assert minTerm.compareTo(maxTerm) <= 0;\n\n    TermsEnum termsEnum = terms.iterator(null);\n    TermsEnum.SeekStatus status = termsEnum.seekCeil(minTerm);\n    if (status != TermsEnum.SeekStatus.FOUND) {\n      throw new RuntimeException(\"failed to seek to existing term field=\" + field + \" term=\" + minTerm);\n    }\n\n    // Do \"dumb\" iteration to visit all terms in the range:\n    long normalTermCount = getDocsFromTermRange(field, maxDoc, termsEnum, normalDocs, minTerm, maxTerm, false);\n\n    // Now do the same operation using intersect:\n    long intersectTermCount = getDocsFromTermRange(field, maxDoc, terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, true, maxTerm, false), true, false, Integer.MAX_VALUE, true), null), intersectDocs, minTerm, maxTerm, true);\n\n    if (intersectTermCount > normalTermCount) {\n      throw new RuntimeException(\"intersect returned too many terms: field=\" + field + \" intersectTermCount=\" + intersectTermCount + \" normalTermCount=\" + normalTermCount);\n    }\n\n    if (normalDocs.equals(intersectDocs) == false) {\n      throw new RuntimeException(\"intersect visited different docs than straight terms enum: \" + normalDocs.cardinality() + \" for straight enum, vs \" + intersectDocs.cardinality() + \" for intersect, minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n    }\n    //System.out.println(\"      docs=\" + normalTermCount);\n    //System.out.println(\"    \" + intersectTermCount + \" vs \" + normalTermCount);\n    return intersectTermCount != normalTermCount;\n  }\n\n","sourceOld":"  /** Test Terms.intersect on this range, and validates that it returns the same doc ids as using non-intersect TermsEnum.  Returns true if\n   *  any fake terms were seen. */\n  private static boolean checkSingleTermRange(String field, int maxDoc, Terms terms, BytesRef minTerm, BytesRef maxTerm, FixedBitSet normalDocs, FixedBitSet intersectDocs) throws IOException {\n    // System.out.println(\"  check minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n\n    TermsEnum termsEnum = terms.iterator(null);\n    TermsEnum.SeekStatus status = termsEnum.seekCeil(minTerm);\n    if (status != TermsEnum.SeekStatus.FOUND) {\n      throw new RuntimeException(\"failed to seek to existing term field=\" + field + \" term=\" + minTerm);\n    }\n\n    // Do \"dumb\" iteration to visit all terms in the range:\n    long normalTermCount = getDocsFromTermRange(field, maxDoc, termsEnum, normalDocs, minTerm, maxTerm, false);\n\n    // Now do the same operation using intersect:\n    long intersectTermCount = getDocsFromTermRange(field, maxDoc, terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, true, maxTerm, false), true, false, Integer.MAX_VALUE, true), null), intersectDocs, minTerm, maxTerm, true);\n\n    if (intersectTermCount > normalTermCount) {\n      throw new RuntimeException(\"intersect returned too many terms: field=\" + field + \" intersectTermCount=\" + intersectTermCount + \" normalTermCount=\" + normalTermCount);\n    }\n\n    if (normalDocs.equals(intersectDocs) == false) {\n      throw new RuntimeException(\"intersect visited different docs than straight terms enum: \" + normalDocs.cardinality() + \" for straight enum, vs \" + intersectDocs.cardinality() + \" for intersect, minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n    }\n    //System.out.println(\"    \" + intersectTermCount + \" vs \" + normalTermCount);\n    return intersectTermCount != normalTermCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82","date":1428522487,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#checkSingleTermRange(String,int,Terms,BytesRef,BytesRef,FixedBitSet,FixedBitSet).mjava","sourceNew":"  /** Test Terms.intersect on this range, and validates that it returns the same doc ids as using non-intersect TermsEnum.  Returns true if\n   *  any fake terms were seen. */\n  private static boolean checkSingleTermRange(String field, int maxDoc, Terms terms, BytesRef minTerm, BytesRef maxTerm, FixedBitSet normalDocs, FixedBitSet intersectDocs) throws IOException {\n    //System.out.println(\"    check minTerm=\" + minTerm.utf8ToString() + \" maxTerm=\" + maxTerm.utf8ToString());\n    assert minTerm.compareTo(maxTerm) <= 0;\n\n    TermsEnum termsEnum = terms.iterator();\n    TermsEnum.SeekStatus status = termsEnum.seekCeil(minTerm);\n    if (status != TermsEnum.SeekStatus.FOUND) {\n      throw new RuntimeException(\"failed to seek to existing term field=\" + field + \" term=\" + minTerm);\n    }\n\n    // Do \"dumb\" iteration to visit all terms in the range:\n    long normalTermCount = getDocsFromTermRange(field, maxDoc, termsEnum, normalDocs, minTerm, maxTerm, false);\n\n    // Now do the same operation using intersect:\n    long intersectTermCount = getDocsFromTermRange(field, maxDoc, terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, true, maxTerm, false), true, false, Integer.MAX_VALUE, true), null), intersectDocs, minTerm, maxTerm, true);\n\n    if (intersectTermCount > normalTermCount) {\n      throw new RuntimeException(\"intersect returned too many terms: field=\" + field + \" intersectTermCount=\" + intersectTermCount + \" normalTermCount=\" + normalTermCount);\n    }\n\n    if (normalDocs.equals(intersectDocs) == false) {\n      throw new RuntimeException(\"intersect visited different docs than straight terms enum: \" + normalDocs.cardinality() + \" for straight enum, vs \" + intersectDocs.cardinality() + \" for intersect, minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n    }\n    //System.out.println(\"      docs=\" + normalTermCount);\n    //System.out.println(\"    \" + intersectTermCount + \" vs \" + normalTermCount);\n    return intersectTermCount != normalTermCount;\n  }\n\n","sourceOld":"  /** Test Terms.intersect on this range, and validates that it returns the same doc ids as using non-intersect TermsEnum.  Returns true if\n   *  any fake terms were seen. */\n  private static boolean checkSingleTermRange(String field, int maxDoc, Terms terms, BytesRef minTerm, BytesRef maxTerm, FixedBitSet normalDocs, FixedBitSet intersectDocs) throws IOException {\n    //System.out.println(\"    check minTerm=\" + minTerm.utf8ToString() + \" maxTerm=\" + maxTerm.utf8ToString());\n    assert minTerm.compareTo(maxTerm) <= 0;\n\n    TermsEnum termsEnum = terms.iterator(null);\n    TermsEnum.SeekStatus status = termsEnum.seekCeil(minTerm);\n    if (status != TermsEnum.SeekStatus.FOUND) {\n      throw new RuntimeException(\"failed to seek to existing term field=\" + field + \" term=\" + minTerm);\n    }\n\n    // Do \"dumb\" iteration to visit all terms in the range:\n    long normalTermCount = getDocsFromTermRange(field, maxDoc, termsEnum, normalDocs, minTerm, maxTerm, false);\n\n    // Now do the same operation using intersect:\n    long intersectTermCount = getDocsFromTermRange(field, maxDoc, terms.intersect(new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, true, maxTerm, false), true, false, Integer.MAX_VALUE, true), null), intersectDocs, minTerm, maxTerm, true);\n\n    if (intersectTermCount > normalTermCount) {\n      throw new RuntimeException(\"intersect returned too many terms: field=\" + field + \" intersectTermCount=\" + intersectTermCount + \" normalTermCount=\" + normalTermCount);\n    }\n\n    if (normalDocs.equals(intersectDocs) == false) {\n      throw new RuntimeException(\"intersect visited different docs than straight terms enum: \" + normalDocs.cardinality() + \" for straight enum, vs \" + intersectDocs.cardinality() + \" for intersect, minTerm=\" + minTerm + \" maxTerm=\" + maxTerm);\n    }\n    //System.out.println(\"      docs=\" + normalTermCount);\n    //System.out.println(\"    \" + intersectTermCount + \" vs \" + normalTermCount);\n    return intersectTermCount != normalTermCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["372b4e16bc7ce0e14dccdc44b8cb31888f7402ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"372b4e16bc7ce0e14dccdc44b8cb31888f7402ab":["3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"]},"commit2Childs":{"0a773283ef5eab2e9c7136eeb66574a4b7a2dc82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"372b4e16bc7ce0e14dccdc44b8cb31888f7402ab":["0a773283ef5eab2e9c7136eeb66574a4b7a2dc82"],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","372b4e16bc7ce0e14dccdc44b8cb31888f7402ab"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}