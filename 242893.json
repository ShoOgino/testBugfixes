{"path":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","commits":[{"id":"a760e2135dfe20a04dea360873d4de1c6a0280bb","date":1430762855,"type":1,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter#remoteQuery(String,HttpServletRequest,SolrQueryRequest,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n\n      String queryString = req.getQueryString();\n\n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equals(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletRequest req,\n      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n      \n      String queryString = req.getQueryString();\n      \n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      }\n      else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      }\n      else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n          \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      }\n      else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      }\n      else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n          && !header.getName().equals(CONNECTION_HEADER)) {\n            resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(null, solrReq, req, resp, new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"108c77096b1abf4c8c26991421f63f87d4c6b13c","date":1432228904,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n\n      String queryString = req.getQueryString();\n\n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equals(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n\n      String queryString = req.getQueryString();\n\n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        method.addHeader(headerName, req.getHeader(headerName));\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equals(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"42718e80a64f6c041cebc3699ab91cd1c928444d","date":1448186182,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl;\n\n      String queryString = req.getQueryString();\n\n      urlstr += queryString == null ? \"\" : \"?\" + queryString;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equals(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":["0713b289be914e52cc2ec942aeb7306f0593a787","f0e8b6c653fa7a4e4ce7df62d16488c8876de46d","a760e2135dfe20a04dea360873d4de1c6a0280bb"],"bugIntro":["3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","date":1452195469,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n        os.flush();\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    boolean success = false;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n        try {\n          IOUtils.copyLarge(is, os);\n          os.flush();\n        } finally {\n          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams\n          IOUtils.closeQuietly(is);\n        }\n      }\n      success = true;\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n      if (method != null && !success) {\n        method.abort();\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2e54d5d0cea0a8b27773e28c44cdd733ef0685b","date":1455646297,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n        os.flush();\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"181cc1f3e63d177595a41313d15974c5ed594bd1","date":1455646562,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      EntityUtils.consumeQuietly(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method);\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521","date":1461254038,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":["f0e8b6c653fa7a4e4ce7df62d16488c8876de46d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","date":1461308643,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"070b525fb213c5643ba35e1b60f1a1d4f7b23312","date":1475678176,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext(cores));\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"07cebc9816f8c940e8e9683abbdc742fe95e25d7","date":1475696954,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext(cores));\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15fb22f207e0cbf913dbc9857b6a4fe30390a625","date":1475989569,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac35531329b1809368fb0780bcf1e72d0add3c21","date":1525474926,"type":3,"author":"Mark Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = new CloseShieldInputStream(req.getInputStream()); // Prevent close of container streams\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12ddd922ea96c1d0ea68a68506b6984a246cfb22","date":1554385731,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method = null;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710","date":1571130800,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":["42718e80a64f6c041cebc3699ab91cd1c928444d"],"bugIntro":["79411f20952f22cd9b944ff6f25f051554ff8e53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + queryParams.toQueryString();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"69756bd5823fa359033ca95cf123ac8a7ceaaef3","date":1579805154,"type":3,"author":"Kevin Risden","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba4636b043a2611cc1c43bad730a78b6d5bc4a5f","date":1589320207,"type":3,"author":"Samuel Garca Martnez","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setHeader(httpEntity.getContentEncoding().getName(), httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79411f20952f22cd9b944ff6f25f051554ff8e53","date":1601389092,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n\n    ModifiableSolrParams updatedQueryParams = new ModifiableSolrParams(queryParams);\n    int forwardCount = queryParams.getInt(INTERNAL_REQUEST_COUNT, 0) + 1;\n    updatedQueryParams.set(INTERNAL_REQUEST_COUNT, forwardCount);\n    String queryStr = updatedQueryParams.toQueryString();\n\n    try {\n      String urlstr = coreUrl + queryStr;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setHeader(httpEntity.getContentEncoding().getName(), httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl + \" with _forwardCount: \" + forwardCount, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n    try {\n      String urlstr = coreUrl + getQuerySting();\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setHeader(httpEntity.getContentEncoding().getName(), httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":["3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710","32602a1a43a5a8782a888221a5df3766ddd775aa"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9746d4d1a8506463e6a4647323b07467d8ed843b","date":1601396343,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","pathOld":"solr/core/src/java/org/apache/solr/servlet/HttpSolrCall#remoteQuery(String,HttpServletResponse).mjava","sourceNew":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n\n    ModifiableSolrParams updatedQueryParams = new ModifiableSolrParams(queryParams);\n    int forwardCount = queryParams.getInt(INTERNAL_REQUEST_COUNT, 0) + 1;\n    updatedQueryParams.set(INTERNAL_REQUEST_COUNT, forwardCount);\n    String queryStr = updatedQueryParams.toQueryString();\n\n    try {\n      String urlstr = coreUrl + queryStr;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          \n          // NOTE: explicitly using 'setHeader' instead of 'addHeader' so that\n          // the remote nodes values for any response headers will overide any that\n          // may have already been set locally (ex: by the local jetty's RewriteHandler config)\n          resp.setHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setHeader(httpEntity.getContentEncoding().getName(), httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl + \" with _forwardCount: \" + forwardCount, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","sourceOld":"  //TODO using Http2Client\n  private void remoteQuery(String coreUrl, HttpServletResponse resp) throws IOException {\n    HttpRequestBase method;\n    HttpEntity httpEntity = null;\n\n    ModifiableSolrParams updatedQueryParams = new ModifiableSolrParams(queryParams);\n    int forwardCount = queryParams.getInt(INTERNAL_REQUEST_COUNT, 0) + 1;\n    updatedQueryParams.set(INTERNAL_REQUEST_COUNT, forwardCount);\n    String queryStr = updatedQueryParams.toQueryString();\n\n    try {\n      String urlstr = coreUrl + queryStr;\n\n      boolean isPostOrPutRequest = \"POST\".equals(req.getMethod()) || \"PUT\".equals(req.getMethod());\n      if (\"GET\".equals(req.getMethod())) {\n        method = new HttpGet(urlstr);\n      } else if (\"HEAD\".equals(req.getMethod())) {\n        method = new HttpHead(urlstr);\n      } else if (isPostOrPutRequest) {\n        HttpEntityEnclosingRequestBase entityRequest =\n            \"POST\".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);\n        InputStream in = req.getInputStream();\n        HttpEntity entity = new InputStreamEntity(in, req.getContentLength());\n        entityRequest.setEntity(entity);\n        method = entityRequest;\n      } else if (\"DELETE\".equals(req.getMethod())) {\n        method = new HttpDelete(urlstr);\n      } else if (\"OPTIONS\".equals(req.getMethod())) {\n        method = new HttpOptions(urlstr);\n      } else {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n            \"Unexpected method type: \" + req.getMethod());\n      }\n\n      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements(); ) {\n        String headerName = e.nextElement();\n        if (!\"host\".equalsIgnoreCase(headerName)\n            && !\"authorization\".equalsIgnoreCase(headerName)\n            && !\"accept\".equalsIgnoreCase(headerName)) {\n          method.addHeader(headerName, req.getHeader(headerName));\n        }\n      }\n      // These headers not supported for HttpEntityEnclosingRequests\n      if (method instanceof HttpEntityEnclosingRequest) {\n        method.removeHeaders(TRANSFER_ENCODING_HEADER);\n        method.removeHeaders(CONTENT_LENGTH_HEADER);\n      }\n\n      final HttpResponse response\n          = solrDispatchFilter.httpClient.execute(method, HttpClientUtil.createNewHttpClientRequestContext());\n      int httpStatus = response.getStatusLine().getStatusCode();\n      httpEntity = response.getEntity();\n\n      resp.setStatus(httpStatus);\n      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext(); ) {\n        Header header = responseHeaders.nextHeader();\n\n        // We pull out these two headers below because they can cause chunked\n        // encoding issues with Tomcat\n        if (header != null && !header.getName().equalsIgnoreCase(TRANSFER_ENCODING_HEADER)\n            && !header.getName().equalsIgnoreCase(CONNECTION_HEADER)) {\n          resp.addHeader(header.getName(), header.getValue());\n        }\n      }\n\n      if (httpEntity != null) {\n        if (httpEntity.getContentEncoding() != null)\n          resp.setHeader(httpEntity.getContentEncoding().getName(), httpEntity.getContentEncoding().getValue());\n        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());\n\n        InputStream is = httpEntity.getContent();\n        OutputStream os = resp.getOutputStream();\n\n        IOUtils.copyLarge(is, os);\n      }\n\n    } catch (IOException e) {\n      sendError(new SolrException(\n          SolrException.ErrorCode.SERVER_ERROR,\n          \"Error trying to proxy request for url: \" + coreUrl + \" with _forwardCount: \" + forwardCount, e));\n    } finally {\n      Utils.consumeFully(httpEntity);\n    }\n\n  }\n\n","bugFix":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9746d4d1a8506463e6a4647323b07467d8ed843b":["79411f20952f22cd9b944ff6f25f051554ff8e53"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["42718e80a64f6c041cebc3699ab91cd1c928444d"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["859081acf00749f5dd462772c571d611d4a4d2db","26ab43e1a461b9c1d9db0739ee0eb5caed8bc521"],"070b525fb213c5643ba35e1b60f1a1d4f7b23312":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["07cebc9816f8c940e8e9683abbdc742fe95e25d7"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"d2e54d5d0cea0a8b27773e28c44cdd733ef0685b":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["ac35531329b1809368fb0780bcf1e72d0add3c21"],"859081acf00749f5dd462772c571d611d4a4d2db":["181cc1f3e63d177595a41313d15974c5ed594bd1"],"07cebc9816f8c940e8e9683abbdc742fe95e25d7":["070b525fb213c5643ba35e1b60f1a1d4f7b23312"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79411f20952f22cd9b944ff6f25f051554ff8e53":["ba4636b043a2611cc1c43bad730a78b6d5bc4a5f"],"69756bd5823fa359033ca95cf123ac8a7ceaaef3":["3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710"],"42718e80a64f6c041cebc3699ab91cd1c928444d":["108c77096b1abf4c8c26991421f63f87d4c6b13c"],"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521":["859081acf00749f5dd462772c571d611d4a4d2db"],"3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"108c77096b1abf4c8c26991421f63f87d4c6b13c":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"181cc1f3e63d177595a41313d15974c5ed594bd1":["d2e54d5d0cea0a8b27773e28c44cdd733ef0685b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9746d4d1a8506463e6a4647323b07467d8ed843b"],"ba4636b043a2611cc1c43bad730a78b6d5bc4a5f":["69756bd5823fa359033ca95cf123ac8a7ceaaef3"],"b0b597c65628ca9e73913a07e81691f8229bae35":["12ddd922ea96c1d0ea68a68506b6984a246cfb22","3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710"]},"commit2Childs":{"9746d4d1a8506463e6a4647323b07467d8ed843b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710","b0b597c65628ca9e73913a07e81691f8229bae35"],"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["d2e54d5d0cea0a8b27773e28c44cdd733ef0685b"],"ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca":["070b525fb213c5643ba35e1b60f1a1d4f7b23312","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"070b525fb213c5643ba35e1b60f1a1d4f7b23312":["07cebc9816f8c940e8e9683abbdc742fe95e25d7"],"15fb22f207e0cbf913dbc9857b6a4fe30390a625":["ac35531329b1809368fb0780bcf1e72d0add3c21","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a760e2135dfe20a04dea360873d4de1c6a0280bb":["108c77096b1abf4c8c26991421f63f87d4c6b13c"],"ac35531329b1809368fb0780bcf1e72d0add3c21":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d2e54d5d0cea0a8b27773e28c44cdd733ef0685b":["181cc1f3e63d177595a41313d15974c5ed594bd1"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"859081acf00749f5dd462772c571d611d4a4d2db":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca","26ab43e1a461b9c1d9db0739ee0eb5caed8bc521"],"07cebc9816f8c940e8e9683abbdc742fe95e25d7":["15fb22f207e0cbf913dbc9857b6a4fe30390a625"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a760e2135dfe20a04dea360873d4de1c6a0280bb"],"79411f20952f22cd9b944ff6f25f051554ff8e53":["9746d4d1a8506463e6a4647323b07467d8ed843b"],"42718e80a64f6c041cebc3699ab91cd1c928444d":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"26ab43e1a461b9c1d9db0739ee0eb5caed8bc521":["ec4dfcb8d7e7f83ca209a5bcc83e8b98658e9dca"],"69756bd5823fa359033ca95cf123ac8a7ceaaef3":["ba4636b043a2611cc1c43bad730a78b6d5bc4a5f"],"3ce90eebc5ea0ea353b865b3db6dbe0c51fc1710":["69756bd5823fa359033ca95cf123ac8a7ceaaef3","b0b597c65628ca9e73913a07e81691f8229bae35"],"108c77096b1abf4c8c26991421f63f87d4c6b13c":["42718e80a64f6c041cebc3699ab91cd1c928444d"],"181cc1f3e63d177595a41313d15974c5ed594bd1":["859081acf00749f5dd462772c571d611d4a4d2db"],"ba4636b043a2611cc1c43bad730a78b6d5bc4a5f":["79411f20952f22cd9b944ff6f25f051554ff8e53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}