{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1 && !sr.termsIndexLoaded()) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooledd (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1 && !sr.termsIndexLoaded()) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooledd (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor, codecs);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooledd (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1 && !sr.termsIndexLoaded()) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooledd (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c6939c02640b94d1bf6d450ec81236a35acce0d","date":1275435666,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor, codecs);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor, codecs);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooledd (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ef87af8c7bd0f8429622b83aa74202383f2e757","date":1280262785,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":null,"sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor, codecs);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a493e6d0c3ad86bd55c0a1360d110142e948f2bd","date":1289406991,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor, codecs);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor, codecs);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","date":1295995357,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     * \n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"639c36565ce03aed5b0fce7c9e4448e53a1f7efd","date":1308580104,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, IOContext context, int termsIndexDivisor) throws IOException {\n\n      //      if (poolReaders) {\n      //        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      //      }\n      \n      // nocommit context should be part of the key used to cache that reader in the pool.\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, doOpenStores, termsIndexDivisor, context);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ddc4c914be86e34b54f70023f45a60fa7f04e929","date":1310115160,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, IOContext context, int termsIndexDivisor) throws IOException {\n\n      //      if (poolReaders) {\n      //        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      //      }\n      \n      // TODO: context should be part of the key used to cache that reader in the pool.\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, doOpenStores, termsIndexDivisor, context);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d004d0e0b3f65bb40da76d476d659d7888270e8","date":1310158940,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,IOContext,int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter.ReaderPool#get(SegmentInfo,boolean,int,int).mjava","sourceNew":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, IOContext context, int termsIndexDivisor) throws IOException {\n\n      //      if (poolReaders) {\n      //        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      //      }\n      \n      // TODO: context should be part of the key used to cache that reader in the pool.\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, doOpenStores, termsIndexDivisor, context);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","sourceOld":"    /**\n     * Obtain a SegmentReader from the readerPool.  The reader\n     * must be returned by calling {@link #release(SegmentReader)}\n     *\n     * @see #release(SegmentReader)\n     * @param info\n     * @param doOpenStores\n     * @param readBufferSize\n     * @param termsIndexDivisor\n     * @throws IOException\n     */\n    public synchronized SegmentReader get(SegmentInfo info, boolean doOpenStores, int readBufferSize, int termsIndexDivisor) throws IOException {\n\n      if (poolReaders) {\n        readBufferSize = BufferedIndexInput.BUFFER_SIZE;\n      }\n\n      SegmentReader sr = readerMap.get(info);\n      if (sr == null) {\n        // TODO: we may want to avoid doing this while\n        // synchronized\n        // Returns a ref, which we xfer to readerMap:\n        sr = SegmentReader.get(false, info.dir, info, readBufferSize, doOpenStores, termsIndexDivisor);\n        sr.readerFinishedListeners = readerFinishedListeners;\n\n        if (info.dir == directory) {\n          // Only pool if reader is not external\n          readerMap.put(info, sr);\n        }\n      } else {\n        if (doOpenStores) {\n          sr.openDocStores();\n        }\n        if (termsIndexDivisor != -1) {\n          // If this reader was originally opened because we\n          // needed to merge it, we didn't load the terms\n          // index.  But now, if the caller wants the terms\n          // index (eg because it's doing deletes, or an NRT\n          // reader is being opened) we ask the reader to\n          // load its terms index.\n          sr.loadTermsIndex(termsIndexDivisor);\n        }\n      }\n\n      // Return a ref to our caller\n      if (info.dir == directory) {\n        // Only incRef if we pooled (reader is not external)\n        sr.incRef();\n      }\n      return sr;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2c6939c02640b94d1bf6d450ec81236a35acce0d":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["2c6939c02640b94d1bf6d450ec81236a35acce0d"],"85a883878c0af761245ab048babc63d099f835f3":["2c6939c02640b94d1bf6d450ec81236a35acce0d","a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5ef87af8c7bd0f8429622b83aa74202383f2e757","a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd"],"a3776dccca01c11e7046323cfad46a3b4a471233":["cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["85a883878c0af761245ab048babc63d099f835f3","cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5ef87af8c7bd0f8429622b83aa74202383f2e757":["2c6939c02640b94d1bf6d450ec81236a35acce0d"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":["a3776dccca01c11e7046323cfad46a3b4a471233","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","639c36565ce03aed5b0fce7c9e4448e53a1f7efd"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"2c6939c02640b94d1bf6d450ec81236a35acce0d":["a493e6d0c3ad86bd55c0a1360d110142e948f2bd","85a883878c0af761245ab048babc63d099f835f3","5ef87af8c7bd0f8429622b83aa74202383f2e757"],"a493e6d0c3ad86bd55c0a1360d110142e948f2bd":["85a883878c0af761245ab048babc63d099f835f3","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340"],"85a883878c0af761245ab048babc63d099f835f3":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["2c6939c02640b94d1bf6d450ec81236a35acce0d"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","639c36565ce03aed5b0fce7c9e4448e53a1f7efd","a3776dccca01c11e7046323cfad46a3b4a471233","ddc4c914be86e34b54f70023f45a60fa7f04e929"],"639c36565ce03aed5b0fce7c9e4448e53a1f7efd":["ddc4c914be86e34b54f70023f45a60fa7f04e929"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"cdd3a20c3f7b8db3ed0313a58cb6304f9b5bc340":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5d004d0e0b3f65bb40da76d476d659d7888270e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"5ef87af8c7bd0f8429622b83aa74202383f2e757":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"5d004d0e0b3f65bb40da76d476d659d7888270e8":[],"ddc4c914be86e34b54f70023f45a60fa7f04e929":["5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5d004d0e0b3f65bb40da76d476d659d7888270e8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}