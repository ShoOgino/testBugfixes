{"path":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","commits":[{"id":"f76ccdfca879f9e8881676ce0fb611f44c0f07a2","date":1322905997,"type":1,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7c2454a6a8237bfd0e953f5b940838408c9055","date":1323649300,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    s.close();\n    r.close();\n    joinS.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bd4a7478aca8c3880512b730b28bf3239340635","date":1326554224,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\" + parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\" + joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // BlockJoinQuery/Collector can query) and the other w/\n    // same docs just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: test star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        System.out.println(\"  \" + parentDoc);\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          System.out.println(\"    \" + joinChildDoc);\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final BlockJoinQuery childJoinQuery = new BlockJoinQuery(childQuery, parentsFilter, BlockJoinQuery.ScoreMode.Avg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare)\n      // results:\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorst:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n      \n      final BlockJoinCollector c = new BlockJoinCollector(parentSort, 10, true, true);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5a3548d95924aea5ee6d88499a7d166498a8e49","date":1328909332,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\" + parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\" + joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\" + parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\" + joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2","b0d5df20d7317b5f4bbefc70ca764b5d3ea8cf3c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba540f2bbd05538ead776efa6ccbabd725c68b2","date":1331205650,"type":3,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\" + parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\" + joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\" + parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\" + joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f918f6e4bff7afea488f1928f7a7ec05338d479f","date":1331745861,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random.nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random.nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random.nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random.nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random.nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n      } else {\n        // AND child field w/ parent query:\n        final BooleanQuery bq = new BooleanQuery();\n        childJoinQuery2 = bq;\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(childTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        childQuery2 = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(childTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n\n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 + \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, null, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, null, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random, 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random.nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random, dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random, joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random.nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random.nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random, 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random.nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random.nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random.nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random.nextInt(3) == 2) {\n        final int childFieldID = random.nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random.nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random, 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random.nextInt(childFields[childFieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random.nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random.nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random.nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random.nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random.nextBoolean();\n        trackMaxScore = random.nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random, 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random.nextInt(3) == 2) {\n        final int fieldID = random.nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n      } else if (random.nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random, 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random.nextBoolean()) {\n            occur = random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random.nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random, 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random.nextInt(parentFields[fieldID].length)])),\n               random.nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random.nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random.nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random.nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random.nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random.nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random.nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random.nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random.nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestBlockJoin#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    // We build two indices at once: one normalized (which\n    // ToParentBlockJoinQuery/Collector,\n    // ToChildBlockJoinQuery can query) and the other w/\n    // the same docs, just fully denormalized:\n    final Directory dir = newDirectory();\n    final Directory joinDir = newDirectory();\n\n    final int numParentDocs = _TestUtil.nextInt(random(), 100*RANDOM_MULTIPLIER, 300*RANDOM_MULTIPLIER);\n    //final int numParentDocs = 30;\n\n    // Values for parent fields:\n    final String[][] parentFields = getRandomFields(numParentDocs/2);\n    // Values for child fields:\n    final String[][] childFields = getRandomFields(numParentDocs);\n\n    final boolean doDeletes = random().nextBoolean();\n    final List<Integer> toDelete = new ArrayList<Integer>();\n\n    // TODO: parallel star join, nested join cases too!\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    final RandomIndexWriter joinW = new RandomIndexWriter(random(), joinDir);\n    for(int parentDocID=0;parentDocID<numParentDocs;parentDocID++) {\n      Document parentDoc = new Document();\n      Document parentJoinDoc = new Document();\n      Field id = newField(\"parentID\", \"\"+parentDocID, StringField.TYPE_STORED);\n      parentDoc.add(id);\n      parentJoinDoc.add(id);\n      parentJoinDoc.add(newField(\"isParent\", \"x\", StringField.TYPE_UNSTORED));\n      for(int field=0;field<parentFields.length;field++) {\n        if (random().nextDouble() < 0.9) {\n          Field f = newField(\"parent\" + field,\n                             parentFields[field][random().nextInt(parentFields[field].length)],\n                             StringField.TYPE_UNSTORED);\n          parentDoc.add(f);\n          parentJoinDoc.add(f);\n        }\n      }\n\n      if (doDeletes) {\n        parentDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        parentJoinDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n      }\n\n      final List<Document> joinDocs = new ArrayList<Document>();\n\n      if (VERBOSE) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"parentID=\").append(parentDoc.get(\"parentID\"));\n        for(int fieldID=0;fieldID<parentFields.length;fieldID++) {\n          String s = parentDoc.get(\"parent\" + fieldID);\n          if (s != null) {\n            sb.append(\" parent\" + fieldID + \"=\" + s);\n          }\n        }\n        System.out.println(\"  \" + sb.toString());\n      }\n\n      final int numChildDocs = _TestUtil.nextInt(random(), 1, 20);\n      for(int childDocID=0;childDocID<numChildDocs;childDocID++) {\n        // Denormalize: copy all parent fields into child doc:\n        Document childDoc = _TestUtil.cloneDocument(parentDoc);\n        Document joinChildDoc = new Document();\n        joinDocs.add(joinChildDoc);\n\n        Field childID = newField(\"childID\", \"\"+childDocID, StringField.TYPE_STORED);\n        childDoc.add(childID);\n        joinChildDoc.add(childID);\n\n        for(int childFieldID=0;childFieldID<childFields.length;childFieldID++) {\n          if (random().nextDouble() < 0.9) {\n            Field f = newField(\"child\" + childFieldID,\n                               childFields[childFieldID][random().nextInt(childFields[childFieldID].length)],\n                               StringField.TYPE_UNSTORED);\n            childDoc.add(f);\n            joinChildDoc.add(f);\n          }\n        }\n\n        if (VERBOSE) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"childID=\").append(joinChildDoc.get(\"childID\"));\n          for(int fieldID=0;fieldID<childFields.length;fieldID++) {\n            String s = joinChildDoc.get(\"child\" + fieldID);\n            if (s != null) {\n              sb.append(\" child\" + fieldID + \"=\" + s);\n            }\n          }\n          System.out.println(\"    \" + sb.toString());\n        }\n\n        if (doDeletes) {\n          joinChildDoc.add(newField(\"blockID\", \"\"+parentDocID, StringField.TYPE_UNSTORED));\n        }\n\n        w.addDocument(childDoc);\n      }\n\n      // Parent last:\n      joinDocs.add(parentJoinDoc);\n      joinW.addDocuments(joinDocs);\n\n      if (doDeletes && random().nextInt(30) == 7) {\n        toDelete.add(parentDocID);\n      }\n    }\n\n    for(int deleteID : toDelete) {\n      if (VERBOSE) {\n        System.out.println(\"DELETE parentID=\" + deleteID);\n      }\n      w.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n      joinW.deleteDocuments(new Term(\"blockID\", \"\"+deleteID));\n    }\n\n    final IndexReader r = w.getReader();\n    w.close();\n    final IndexReader joinR = joinW.getReader();\n    joinW.close();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: reader=\" + r);\n      System.out.println(\"TEST: joinReader=\" + joinR);\n\n      for(int docIDX=0;docIDX<joinR.maxDoc();docIDX++) {\n        System.out.println(\"  docID=\" + docIDX + \" doc=\" + joinR.document(docIDX));\n      }\n    }\n\n    final IndexSearcher s = newSearcher(r);\n    s.setDefaultFieldSortScoring(true, true);\n\n    final IndexSearcher joinS = newSearcher(joinR);\n\n    final Filter parentsFilter = new CachingWrapperFilter(new QueryWrapperFilter(new TermQuery(new Term(\"isParent\", \"x\"))));\n\n    final int iters = 200*RANDOM_MULTIPLIER;\n\n    for(int iter=0;iter<iters;iter++) {\n      if (VERBOSE) {\n        System.out.println(\"TEST: iter=\" + (1+iter) + \" of \" + iters);\n      }\n\n      final Query childQuery;\n      if (random().nextInt(3) == 2) {\n        final int childFieldID = random().nextInt(childFields.length);\n        childQuery = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomChildTerm(childFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n            clause = new TermQuery(new Term(\"child\" + childFieldID,\n                                            childFields[childFieldID][random().nextInt(childFields[childFieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        childQuery = bq;\n        \n        bq.add(new TermQuery(randomChildTerm(childFields[0])),\n               BooleanClause.Occur.MUST);\n        final int childFieldID = _TestUtil.nextInt(random(), 1, childFields.length-1);\n        bq.add(new TermQuery(new Term(\"child\" + childFieldID, childFields[childFieldID][random().nextInt(childFields[childFieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      final int x = random().nextInt(4);\n      final ToParentBlockJoinQuery.ScoreMode agg;\n      if (x == 0) {\n        agg = ToParentBlockJoinQuery.ScoreMode.None;\n      } else if (x == 1) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Max;\n      } else if (x == 2) {\n        agg = ToParentBlockJoinQuery.ScoreMode.Total;\n      } else {\n        agg = ToParentBlockJoinQuery.ScoreMode.Avg;\n      }\n\n      final ToParentBlockJoinQuery childJoinQuery = new ToParentBlockJoinQuery(childQuery, parentsFilter, agg);\n\n      // To run against the block-join index:\n      final Query parentJoinQuery;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query parentQuery;\n\n      if (random().nextBoolean()) {\n        parentQuery = childQuery;\n        parentJoinQuery = childJoinQuery;\n      } else {\n        // AND parent field w/ child field\n        final BooleanQuery bq = new BooleanQuery();\n        parentJoinQuery = bq;\n        final Term parentTerm = randomParentTerm(parentFields[0]);\n        if (random().nextBoolean()) {\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n        } else {\n          bq.add(new TermQuery(parentTerm),\n                 BooleanClause.Occur.MUST);\n          bq.add(childJoinQuery, BooleanClause.Occur.MUST);\n        }\n\n        final BooleanQuery bq2 = new BooleanQuery();\n        parentQuery = bq2;\n        if (random().nextBoolean()) {\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n        } else {\n          bq2.add(new TermQuery(parentTerm),\n                  BooleanClause.Occur.MUST);\n          bq2.add(childQuery, BooleanClause.Occur.MUST);\n        }\n      }\n\n      final Sort parentSort = getRandomSort(\"parent\", parentFields.length);\n      final Sort childSort = getRandomSort(\"child\", childFields.length);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: query=\" + parentQuery + \" joinQuery=\" + parentJoinQuery + \" parentSort=\" + parentSort + \" childSort=\" + childSort);\n      }\n\n      // Merge both sorts:\n      final List<SortField> sortFields = new ArrayList<SortField>(Arrays.asList(parentSort.getSort()));\n      sortFields.addAll(Arrays.asList(childSort.getSort()));\n      final Sort parentAndChildSort = new Sort(sortFields.toArray(new SortField[sortFields.size()]));\n\n      final TopDocs results = s.search(parentQuery, null, r.numDocs(),\n                                       parentAndChildSort);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: normal index gets \" + results.totalHits + \" hits\");\n        final ScoreDoc[] hits = results.scoreDocs;\n        for(int hitIDX=0;hitIDX<hits.length;hitIDX++) {\n          final Document doc = s.doc(hits[hitIDX].doc);\n          //System.out.println(\"  score=\" + hits[hitIDX].score + \" parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          System.out.println(\"  parentID=\" + doc.get(\"parentID\") + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + hits[hitIDX].doc + \")\");\n          FieldDoc fd = (FieldDoc) hits[hitIDX];\n          if (fd.fields != null) {\n            System.out.print(\"    \");\n            for(Object o : fd.fields) {\n              if (o instanceof BytesRef) {\n                System.out.print(((BytesRef) o).utf8ToString() + \" \");\n              } else {\n                System.out.print(o + \" \");\n              }\n            }\n            System.out.println();\n          }\n        }\n      }\n\n      final boolean trackScores;\n      final boolean trackMaxScore;\n      if (agg == ToParentBlockJoinQuery.ScoreMode.None) {\n        trackScores = false;\n        trackMaxScore = false;\n      } else {\n        trackScores = random().nextBoolean();\n        trackMaxScore = random().nextBoolean();\n      }\n      final ToParentBlockJoinCollector c = new ToParentBlockJoinCollector(parentSort, 10, trackScores, trackMaxScore);\n\n      joinS.search(parentJoinQuery, c);\n\n      final int hitsPerGroup = _TestUtil.nextInt(random(), 1, 20);\n      //final int hitsPerGroup = 100;\n      final TopGroups<Integer> joinResults = c.getTopGroups(childJoinQuery, childSort, 0, hitsPerGroup, 0, true);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: block join index gets \" + (joinResults == null ? 0 : joinResults.groups.length) + \" groups; hitsPerGroup=\" + hitsPerGroup);\n        if (joinResults != null) {\n          final GroupDocs<Integer>[] groups = joinResults.groups;\n          for(int groupIDX=0;groupIDX<groups.length;groupIDX++) {\n            final GroupDocs<Integer> group = groups[groupIDX];\n            if (group.groupSortValues != null) {\n              System.out.print(\"  \");\n              for(Object o : group.groupSortValues) {\n                if (o instanceof BytesRef) {\n                  System.out.print(((BytesRef) o).utf8ToString() + \" \");\n                } else {\n                  System.out.print(o + \" \");\n                }\n              }\n              System.out.println();\n            }\n\n            assertNotNull(group.groupValue);\n            final Document parentDoc = joinS.doc(group.groupValue);\n            System.out.println(\"  group parentID=\" + parentDoc.get(\"parentID\") + \" (docID=\" + group.groupValue + \")\");\n            for(int hitIDX=0;hitIDX<group.scoreDocs.length;hitIDX++) {\n              final Document doc = joinS.doc(group.scoreDocs[hitIDX].doc);\n              //System.out.println(\"    score=\" + group.scoreDocs[hitIDX].score + \" childID=\" + doc.get(\"childID\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n              System.out.println(\"    childID=\" + doc.get(\"childID\") + \" child0=\" + doc.get(\"child0\") + \" (docID=\" + group.scoreDocs[hitIDX].doc + \")\");\n            }\n          }\n        }\n      }\n\n      if (results.totalHits == 0) {\n        assertNull(joinResults);\n      } else {\n        compareHits(r, joinR, results, joinResults);\n      }\n\n      // Test joining in the opposite direction (parent to\n      // child):\n\n      // Get random query against parent documents:\n      final Query parentQuery2;\n      if (random().nextInt(3) == 2) {\n        final int fieldID = random().nextInt(parentFields.length);\n        parentQuery2 = new TermQuery(new Term(\"parent\" + fieldID,\n                                              parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n      } else if (random().nextInt(3) == 2) {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        final int numClauses = _TestUtil.nextInt(random(), 2, 4);\n        boolean didMust = false;\n        for(int clauseIDX=0;clauseIDX<numClauses;clauseIDX++) {\n          Query clause;\n          BooleanClause.Occur occur;\n          if (!didMust && random().nextBoolean()) {\n            occur = random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT;\n            clause = new TermQuery(randomParentTerm(parentFields[0]));\n            didMust = true;\n          } else {\n            occur = BooleanClause.Occur.SHOULD;\n            final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n            clause = new TermQuery(new Term(\"parent\" + fieldID,\n                                            parentFields[fieldID][random().nextInt(parentFields[fieldID].length)]));\n          }\n          bq.add(clause, occur);\n        }\n      } else {\n        BooleanQuery bq = new BooleanQuery();\n        parentQuery2 = bq;\n        \n        bq.add(new TermQuery(randomParentTerm(parentFields[0])),\n               BooleanClause.Occur.MUST);\n        final int fieldID = _TestUtil.nextInt(random(), 1, parentFields.length-1);\n        bq.add(new TermQuery(new Term(\"parent\" + fieldID, parentFields[fieldID][random().nextInt(parentFields[fieldID].length)])),\n               random().nextBoolean() ? BooleanClause.Occur.MUST : BooleanClause.Occur.MUST_NOT);\n      }\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: top down: parentQuery2=\" + parentQuery2);\n      }\n\n      // Maps parent query to child docs:\n      final ToChildBlockJoinQuery parentJoinQuery2 = new ToChildBlockJoinQuery(parentQuery2, parentsFilter, random().nextBoolean());\n\n      // To run against the block-join index:\n      final Query childJoinQuery2;\n\n      // Same query as parentJoinQuery, but to run against\n      // the fully denormalized index (so we can compare\n      // results):\n      final Query childQuery2;\n      \n      // apply a filter to children\n      final Filter childFilter2, childJoinFilter2;\n\n      if (random().nextBoolean()) {\n        childQuery2 = parentQuery2;\n        childJoinQuery2 = parentJoinQuery2;\n        childFilter2 = null;\n        childJoinFilter2 = null;\n      } else {\n        final Term childTerm = randomChildTerm(childFields[0]);\n        if (random().nextBoolean()) { // filtered case\n          childJoinQuery2 = parentJoinQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childJoinFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childJoinFilter2 = null;\n          // AND child field w/ parent query:\n          final BooleanQuery bq = new BooleanQuery();\n          childJoinQuery2 = bq;\n          if (random().nextBoolean()) {\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n          } else {\n            bq.add(new TermQuery(childTerm),\n                   BooleanClause.Occur.MUST);\n            bq.add(parentJoinQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n        \n        if (random().nextBoolean()) { // filtered case\n          childQuery2 = parentQuery2;\n          final Filter f = new QueryWrapperFilter(new TermQuery(childTerm));\n          childFilter2 = random().nextBoolean()\n                  ? new CachingWrapperFilter(f): f;\n        } else {\n          childFilter2 = null;\n          final BooleanQuery bq2 = new BooleanQuery();\n          childQuery2 = bq2;\n          if (random().nextBoolean()) {\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n          } else {\n            bq2.add(new TermQuery(childTerm),\n                    BooleanClause.Occur.MUST);\n            bq2.add(parentQuery2, BooleanClause.Occur.MUST);\n          }\n        }\n      }\n\n      final Sort childSort2 = getRandomSort(\"child\", childFields.length);\n              \n      // Search denormalized index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down query=\" + childQuery2 +\n            \" filter=\" + childFilter2 +\n            \" sort=\" + childSort2);\n      }\n      final TopDocs results2 = s.search(childQuery2, childFilter2, r.numDocs(),\n                                        childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + results2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : results2.scoreDocs) {\n          final Document doc = s.doc(sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + doc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      // Search join index:\n      if (VERBOSE) {\n        System.out.println(\"TEST: run top down join query=\" + childJoinQuery2 + \n            \" filter=\" + childJoinFilter2 + \" sort=\" + childSort2);\n      }\n      TopDocs joinResults2 = joinS.search(childJoinQuery2, childJoinFilter2, joinR.numDocs(), childSort2);\n      if (VERBOSE) {\n        System.out.println(\"  \" + joinResults2.totalHits + \" totalHits:\");\n        for(ScoreDoc sd : joinResults2.scoreDocs) {\n          final Document doc = joinS.doc(sd.doc);\n          final Document parentDoc = getParentDoc(joinR, parentsFilter, sd.doc);\n          System.out.println(\"  childID=\" + doc.get(\"childID\") + \" parentID=\" + parentDoc.get(\"parentID\") + \" docID=\" + sd.doc);\n        }\n      }\n\n      compareChildHits(r, joinR, results2, joinResults2);\n    }\n\n    r.close();\n    joinR.close();\n    dir.close();\n    joinDir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"6bd4a7478aca8c3880512b730b28bf3239340635":["0e7c2454a6a8237bfd0e953f5b940838408c9055"],"38e3b736c7ca086d61b7dbb841c905ee115490da":["b5a3548d95924aea5ee6d88499a7d166498a8e49","aba540f2bbd05538ead776efa6ccbabd725c68b2"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"b5a3548d95924aea5ee6d88499a7d166498a8e49":["6bd4a7478aca8c3880512b730b28bf3239340635"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["f76ccdfca879f9e8881676ce0fb611f44c0f07a2"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["f76ccdfca879f9e8881676ce0fb611f44c0f07a2","0e7c2454a6a8237bfd0e953f5b940838408c9055"],"f918f6e4bff7afea488f1928f7a7ec05338d479f":["aba540f2bbd05538ead776efa6ccbabd725c68b2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["f918f6e4bff7afea488f1928f7a7ec05338d479f"],"f76ccdfca879f9e8881676ce0fb611f44c0f07a2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"aba540f2bbd05538ead776efa6ccbabd725c68b2":["b5a3548d95924aea5ee6d88499a7d166498a8e49"]},"commit2Childs":{"6bd4a7478aca8c3880512b730b28bf3239340635":["b5a3548d95924aea5ee6d88499a7d166498a8e49"],"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"b5a3548d95924aea5ee6d88499a7d166498a8e49":["38e3b736c7ca086d61b7dbb841c905ee115490da","aba540f2bbd05538ead776efa6ccbabd725c68b2"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0e7c2454a6a8237bfd0e953f5b940838408c9055":["6bd4a7478aca8c3880512b730b28bf3239340635","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"f918f6e4bff7afea488f1928f7a7ec05338d479f":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f76ccdfca879f9e8881676ce0fb611f44c0f07a2"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"f76ccdfca879f9e8881676ce0fb611f44c0f07a2":["0e7c2454a6a8237bfd0e953f5b940838408c9055","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"aba540f2bbd05538ead776efa6ccbabd725c68b2":["38e3b736c7ca086d61b7dbb841c905ee115490da","f918f6e4bff7afea488f1928f7a7ec05338d479f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}