{"path":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","commits":[{"id":"b7d615ef411046679022f6728bb2b876273d13ae","date":1400253450,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      // nocommit randomRealisticUniode / full binary\n      String idValue = TestUtil.randomSimpleString(random());\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      //long version = random().nextLong() & 0x7fffffffffffffffL;\n      version++;\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else {\n        idValue = TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(-1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(-1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9","date":1400353720,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      // nocommit randomRealisticUniode / full binary\n      String idValue = TestUtil.randomSimpleString(random());\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      //long version = random().nextLong() & 0x7fffffffffffffffL;\n      version++;\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else {\n        idValue = TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      // nocommit randomRealisticUniode / full binary\n      String idValue = TestUtil.randomSimpleString(random());\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      //long version = random().nextLong() & 0x7fffffffffffffffL;\n      version++;\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else {\n        idValue = TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(-1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(-1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3251bdaf728baf81f779183e464984bc769ed9c7","date":1400494940,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids;\n    switch (random().nextInt(6)) {\n    case 0:\n      // random simple\n      if (VERBOSE) {\n        System.out.println(\"  use random simple ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomSimpleString(random());\n          }\n        };\n      break;\n    case 1:\n      // random realistic unicode\n      if (VERBOSE) {\n        System.out.println(\"  use random realistic unicode ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomRealisticUnicodeString(random());\n          }\n        };\n      break;\n    case 2:\n      // sequential\n      if (VERBOSE) {\n        System.out.println(\"  use seuquential ids\");\n      }\n      ids = new IDSource() {\n          int upto;\n          @Override\n          public String next() {\n            return Integer.toString(upto++);\n          }\n        };\n      break;\n    case 3:\n      // zero-pad sequential\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad seuquential ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%0\" + TestUtil.nextInt(random(), 4, 20) + \"d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            String s = Integer.toString(upto++);\n            return zeroPad.substring(zeroPad.length() - s.length()) + s;\n          }\n        };\n      break;\n    case 4:\n      // random long\n      if (VERBOSE) {\n        System.out.println(\"  use random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    case 5:\n      // zero-pad random long\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%015d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    default:\n      throw new AssertionError();\n    }\n\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      // nocommit randomRealisticUniode / full binary\n      String idValue = TestUtil.randomSimpleString(random());\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      //long version = random().nextLong() & 0x7fffffffffffffffL;\n      version++;\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else {\n        idValue = TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a16b40feb4e6e0d55c1716733bde48296bedd20","date":1400540388,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids;\n    switch (random().nextInt(6)) {\n    case 0:\n      // random simple\n      if (VERBOSE) {\n        System.out.println(\"  use random simple ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomSimpleString(random());\n          }\n        };\n      break;\n    case 1:\n      // random realistic unicode\n      if (VERBOSE) {\n        System.out.println(\"  use random realistic unicode ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomRealisticUnicodeString(random());\n          }\n        };\n      break;\n    case 2:\n      // sequential\n      if (VERBOSE) {\n        System.out.println(\"  use seuquential ids\");\n      }\n      ids = new IDSource() {\n          int upto;\n          @Override\n          public String next() {\n            return Integer.toString(upto++);\n          }\n        };\n      break;\n    case 3:\n      // zero-pad sequential\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad seuquential ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%0\" + TestUtil.nextInt(random(), 4, 20) + \"d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            String s = Integer.toString(upto++);\n            return zeroPad.substring(zeroPad.length() - s.length()) + s;\n          }\n        };\n      break;\n    case 4:\n      // random long\n      if (VERBOSE) {\n        System.out.println(\"  use random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    case 5:\n      // zero-pad random long\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%015d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    default:\n      throw new AssertionError();\n    }\n\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids;\n    switch (random().nextInt(6)) {\n    case 0:\n      // random simple\n      if (VERBOSE) {\n        System.out.println(\"  use random simple ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomSimpleString(random());\n          }\n        };\n      break;\n    case 1:\n      // random realistic unicode\n      if (VERBOSE) {\n        System.out.println(\"  use random realistic unicode ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomRealisticUnicodeString(random());\n          }\n        };\n      break;\n    case 2:\n      // sequential\n      if (VERBOSE) {\n        System.out.println(\"  use seuquential ids\");\n      }\n      ids = new IDSource() {\n          int upto;\n          @Override\n          public String next() {\n            return Integer.toString(upto++);\n          }\n        };\n      break;\n    case 3:\n      // zero-pad sequential\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad seuquential ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%0\" + TestUtil.nextInt(random(), 4, 20) + \"d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            String s = Integer.toString(upto++);\n            return zeroPad.substring(zeroPad.length() - s.length()) + s;\n          }\n        };\n      break;\n    case 4:\n      // random long\n      if (VERBOSE) {\n        System.out.println(\"  use random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    case 5:\n      // zero-pad random long\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%015d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    default:\n      throw new AssertionError();\n    }\n\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efcf27cd5ca23def8376b4c321970c14dd71623","date":1400662679,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    int minItemsInBlock = TestUtil.nextInt(random(), 2, 50);\n    int maxItemsInBlock = 2*(minItemsInBlock-1) + random().nextInt(50);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat(minItemsInBlock, maxItemsInBlock)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    //IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids;\n    switch (random().nextInt(6)) {\n    case 0:\n      // random simple\n      if (VERBOSE) {\n        System.out.println(\"  use random simple ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomSimpleString(random());\n          }\n        };\n      break;\n    case 1:\n      // random realistic unicode\n      if (VERBOSE) {\n        System.out.println(\"  use random realistic unicode ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomRealisticUnicodeString(random());\n          }\n        };\n      break;\n    case 2:\n      // sequential\n      if (VERBOSE) {\n        System.out.println(\"  use seuquential ids\");\n      }\n      ids = new IDSource() {\n          int upto;\n          @Override\n          public String next() {\n            return Integer.toString(upto++);\n          }\n        };\n      break;\n    case 3:\n      // zero-pad sequential\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad seuquential ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%0\" + TestUtil.nextInt(random(), 4, 20) + \"d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            String s = Integer.toString(upto++);\n            return zeroPad.substring(zeroPad.length() - s.length()) + s;\n          }\n        };\n      break;\n    case 4:\n      // random long\n      if (VERBOSE) {\n        System.out.println(\"  use random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    case 5:\n      // zero-pad random long\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%015d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    default:\n      throw new AssertionError();\n    }\n\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    List<String> idsList = new ArrayList<>();\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      idsList.add(idValue);\n\n      if (idsList.size() > 0 && random().nextInt(7) == 5) {\n        // Randomly delete or update a previous ID\n        idValue = idsList.get(random().nextInt(idsList.size()));\n        if (random().nextBoolean()) {\n          if (useMonotonicVersion) {\n            version += TestUtil.nextInt(random(), 1, 10);\n          } else {\n            version = random().nextLong() & 0x7fffffffffffffffL;\n          }\n          doc = new Document();\n          doc.add(makeIDField(idValue, version));\n          if (VERBOSE) {\n            System.out.println(\"  update \" + idValue + \" -> \" + version);\n          }\n          w.updateDocument(new Term(\"id\", idValue), doc);\n          idValues.put(idValue, version);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  delete \" + idValue);\n          }\n          w.deleteDocuments(new Term(\"id\", idValue));\n          idValues.remove(idValue);\n        }        \n      }\n\n      docUpto++;\n    }\n\n    IndexReader r = w.getReader();\n    //IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(idValuesList.size())).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    // nocommit randomize the block sizes:\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat()));\n    // nocommit put back\n    //RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids;\n    switch (random().nextInt(6)) {\n    case 0:\n      // random simple\n      if (VERBOSE) {\n        System.out.println(\"  use random simple ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomSimpleString(random());\n          }\n        };\n      break;\n    case 1:\n      // random realistic unicode\n      if (VERBOSE) {\n        System.out.println(\"  use random realistic unicode ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomRealisticUnicodeString(random());\n          }\n        };\n      break;\n    case 2:\n      // sequential\n      if (VERBOSE) {\n        System.out.println(\"  use seuquential ids\");\n      }\n      ids = new IDSource() {\n          int upto;\n          @Override\n          public String next() {\n            return Integer.toString(upto++);\n          }\n        };\n      break;\n    case 3:\n      // zero-pad sequential\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad seuquential ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%0\" + TestUtil.nextInt(random(), 4, 20) + \"d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            String s = Integer.toString(upto++);\n            return zeroPad.substring(zeroPad.length() - s.length()) + s;\n          }\n        };\n      break;\n    case 4:\n      // random long\n      if (VERBOSE) {\n        System.out.println(\"  use random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    case 5:\n      // zero-pad random long\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%015d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    default:\n      throw new AssertionError();\n    }\n\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      // nocommit add deletes in\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      docUpto++;\n    }\n\n    //IndexReader r = w.getReader();\n    IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(numDocs)).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca044bd4a0bea8391cbebb44a34aba53a9b50541","date":1400784655,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    int minItemsInBlock = TestUtil.nextInt(random(), 2, 50);\n    int maxItemsInBlock = 2*(minItemsInBlock-1) + random().nextInt(50);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat(minItemsInBlock, maxItemsInBlock)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    //IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids = getRandomIDs();\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    List<String> idsList = new ArrayList<>();\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      idsList.add(idValue);\n\n      if (idsList.size() > 0 && random().nextInt(7) == 5) {\n        // Randomly delete or update a previous ID\n        idValue = idsList.get(random().nextInt(idsList.size()));\n        if (random().nextBoolean()) {\n          if (useMonotonicVersion) {\n            version += TestUtil.nextInt(random(), 1, 10);\n          } else {\n            version = random().nextLong() & 0x7fffffffffffffffL;\n          }\n          doc = new Document();\n          doc.add(makeIDField(idValue, version));\n          if (VERBOSE) {\n            System.out.println(\"  update \" + idValue + \" -> \" + version);\n          }\n          w.updateDocument(new Term(\"id\", idValue), doc);\n          idValues.put(idValue, version);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  delete \" + idValue);\n          }\n          w.deleteDocuments(new Term(\"id\", idValue));\n          idValues.remove(idValue);\n        }        \n      }\n\n      docUpto++;\n    }\n\n    IndexReader r = w.getReader();\n    //IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(idValuesList.size())).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    int minItemsInBlock = TestUtil.nextInt(random(), 2, 50);\n    int maxItemsInBlock = 2*(minItemsInBlock-1) + random().nextInt(50);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat(minItemsInBlock, maxItemsInBlock)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    //IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids;\n    switch (random().nextInt(6)) {\n    case 0:\n      // random simple\n      if (VERBOSE) {\n        System.out.println(\"  use random simple ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomSimpleString(random());\n          }\n        };\n      break;\n    case 1:\n      // random realistic unicode\n      if (VERBOSE) {\n        System.out.println(\"  use random realistic unicode ids\");\n      }\n      ids = new IDSource() {\n          @Override\n          public String next() {\n            return TestUtil.randomRealisticUnicodeString(random());\n          }\n        };\n      break;\n    case 2:\n      // sequential\n      if (VERBOSE) {\n        System.out.println(\"  use seuquential ids\");\n      }\n      ids = new IDSource() {\n          int upto;\n          @Override\n          public String next() {\n            return Integer.toString(upto++);\n          }\n        };\n      break;\n    case 3:\n      // zero-pad sequential\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad seuquential ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%0\" + TestUtil.nextInt(random(), 4, 20) + \"d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            String s = Integer.toString(upto++);\n            return zeroPad.substring(zeroPad.length() - s.length()) + s;\n          }\n        };\n      break;\n    case 4:\n      // random long\n      if (VERBOSE) {\n        System.out.println(\"  use random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    case 5:\n      // zero-pad random long\n      if (VERBOSE) {\n        System.out.println(\"  use zero-pad random long ids\");\n      }\n      ids = new IDSource() {\n          final int radix = TestUtil.nextInt(random(), Character.MIN_RADIX, Character.MAX_RADIX);\n          final String zeroPad = String.format(Locale.ROOT, \"%015d\", 0);\n          int upto;\n          @Override\n          public String next() {\n            return Long.toString(random().nextLong() & 0x7ffffffffffffffL, radix);\n          }\n        };\n      break;\n    default:\n      throw new AssertionError();\n    }\n\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    List<String> idsList = new ArrayList<>();\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      idsList.add(idValue);\n\n      if (idsList.size() > 0 && random().nextInt(7) == 5) {\n        // Randomly delete or update a previous ID\n        idValue = idsList.get(random().nextInt(idsList.size()));\n        if (random().nextBoolean()) {\n          if (useMonotonicVersion) {\n            version += TestUtil.nextInt(random(), 1, 10);\n          } else {\n            version = random().nextLong() & 0x7fffffffffffffffL;\n          }\n          doc = new Document();\n          doc.add(makeIDField(idValue, version));\n          if (VERBOSE) {\n            System.out.println(\"  update \" + idValue + \" -> \" + version);\n          }\n          w.updateDocument(new Term(\"id\", idValue), doc);\n          idValues.put(idValue, version);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  delete \" + idValue);\n          }\n          w.deleteDocuments(new Term(\"id\", idValue));\n          idValues.remove(idValue);\n        }        \n      }\n\n      docUpto++;\n    }\n\n    IndexReader r = w.getReader();\n    //IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(idValuesList.size())).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","date":1400786907,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","pathOld":"lucene/codecs/src/test/org/apache/lucene/codecs/idversion/TestIDVersionPostingsFormat#testRandom().mjava","sourceNew":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    int minItemsInBlock = TestUtil.nextInt(random(), 2, 50);\n    int maxItemsInBlock = 2*(minItemsInBlock-1) + random().nextInt(50);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat(minItemsInBlock, maxItemsInBlock)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    //IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids = getRandomIDs();\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    List<String> idsList = new ArrayList<>();\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      idsList.add(idValue);\n\n      if (idsList.size() > 0 && random().nextInt(7) == 5) {\n        // Randomly delete or update a previous ID\n        idValue = idsList.get(random().nextInt(idsList.size()));\n        if (random().nextBoolean()) {\n          if (useMonotonicVersion) {\n            version += TestUtil.nextInt(random(), 1, 10);\n          } else {\n            version = random().nextLong() & 0x7fffffffffffffffL;\n          }\n          doc = new Document();\n          doc.add(makeIDField(idValue, version));\n          if (VERBOSE) {\n            System.out.println(\"  update \" + idValue + \" -> \" + version);\n          }\n          w.updateDocument(new Term(\"id\", idValue), doc);\n          idValues.put(idValue, version);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  delete \" + idValue);\n          }\n          w.deleteDocuments(new Term(\"id\", idValue));\n          idValues.remove(idValue);\n        }        \n      }\n\n      docUpto++;\n    }\n\n    IndexReader r = w.getReader();\n    //IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(idValuesList.size())).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandom() throws Exception {\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random()));\n    int minItemsInBlock = TestUtil.nextInt(random(), 2, 50);\n    int maxItemsInBlock = 2*(minItemsInBlock-1) + random().nextInt(50);\n    iwc.setCodec(TestUtil.alwaysPostingsFormat(new IDVersionPostingsFormat(minItemsInBlock, maxItemsInBlock)));\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n    //IndexWriter w = new IndexWriter(dir, iwc);\n    int numDocs = atLeast(1000);\n    Map<String,Long> idValues = new HashMap<String,Long>();\n    int docUpto = 0;\n    if (VERBOSE) {\n      System.out.println(\"TEST: numDocs=\" + numDocs);\n    }\n\n    IDSource ids = getRandomIDs();\n    String idPrefix;\n    if (random().nextBoolean()) {\n      idPrefix = \"\";\n    } else {\n      idPrefix = TestUtil.randomSimpleString(random());\n      if (VERBOSE) {\n        System.out.println(\"TEST: use id prefix: \" + idPrefix);\n      }\n    }\n\n    boolean useMonotonicVersion = random().nextBoolean();\n    if (VERBOSE) {\n      System.out.println(\"TEST: useMonotonicVersion=\" + useMonotonicVersion);\n    }\n\n    List<String> idsList = new ArrayList<>();\n\n    long version = 0;\n    while (docUpto < numDocs) {\n      String idValue = idPrefix + ids.next();\n      if (idValues.containsKey(idValue)) {\n        continue;\n      }\n      if (useMonotonicVersion) {\n        version += TestUtil.nextInt(random(), 1, 10);\n      } else {\n        version = random().nextLong() & 0x7fffffffffffffffL;\n      }\n      idValues.put(idValue, version);\n      if (VERBOSE) {\n        System.out.println(\"  \" + idValue + \" -> \" + version);\n      }\n      Document doc = new Document();\n      doc.add(makeIDField(idValue, version));\n      w.addDocument(doc);\n      idsList.add(idValue);\n\n      if (idsList.size() > 0 && random().nextInt(7) == 5) {\n        // Randomly delete or update a previous ID\n        idValue = idsList.get(random().nextInt(idsList.size()));\n        if (random().nextBoolean()) {\n          if (useMonotonicVersion) {\n            version += TestUtil.nextInt(random(), 1, 10);\n          } else {\n            version = random().nextLong() & 0x7fffffffffffffffL;\n          }\n          doc = new Document();\n          doc.add(makeIDField(idValue, version));\n          if (VERBOSE) {\n            System.out.println(\"  update \" + idValue + \" -> \" + version);\n          }\n          w.updateDocument(new Term(\"id\", idValue), doc);\n          idValues.put(idValue, version);\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  delete \" + idValue);\n          }\n          w.deleteDocuments(new Term(\"id\", idValue));\n          idValues.remove(idValue);\n        }        \n      }\n\n      docUpto++;\n    }\n\n    IndexReader r = w.getReader();\n    //IndexReader r = DirectoryReader.open(w, true);\n    PerThreadVersionPKLookup lookup = new PerThreadVersionPKLookup(r, \"id\");\n\n    List<Map.Entry<String,Long>> idValuesList = new ArrayList<>(idValues.entrySet());\n    int iters = numDocs * 5;\n    for(int iter=0;iter<iters;iter++) {\n      String idValue;\n\n      if (random().nextBoolean()) {\n        idValue = idValuesList.get(random().nextInt(idValuesList.size())).getKey();\n      } else if (random().nextBoolean()) {\n        idValue = ids.next();\n      } else {\n        idValue = idPrefix + TestUtil.randomSimpleString(random());\n      }\n\n      BytesRef idValueBytes = new BytesRef(idValue);\n\n      Long expectedVersion = idValues.get(idValue);\n\n      if (VERBOSE) {\n        System.out.println(\"\\nTEST: iter=\" + iter + \" id=\" + idValue + \" expectedVersion=\" + expectedVersion);\n      }\n      \n      if (expectedVersion == null) {\n        assertEquals(\"term should not have been found (doesn't exist)\", -1, lookup.lookup(idValueBytes));\n      } else {\n        if (random().nextBoolean()) {\n          if (VERBOSE) {\n            System.out.println(\"  lookup exact version (should be found)\");\n          }\n          assertTrue(\"term should have been found (version too old)\", lookup.lookup(idValueBytes, expectedVersion.longValue()) != -1);\n          assertEquals(expectedVersion.longValue(), lookup.getVersion());\n        } else {\n          if (VERBOSE) {\n            System.out.println(\"  lookup version+1 (should not be found)\");\n          }\n          assertEquals(\"term should not have been found (version newer)\", -1, lookup.lookup(idValueBytes, expectedVersion.longValue()+1));\n        }\n      }\n    }\n\n    r.close();\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["b7d615ef411046679022f6728bb2b876273d13ae"],"0a16b40feb4e6e0d55c1716733bde48296bedd20":["3251bdaf728baf81f779183e464984bc769ed9c7"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["0a16b40feb4e6e0d55c1716733bde48296bedd20"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7d615ef411046679022f6728bb2b876273d13ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3251bdaf728baf81f779183e464984bc769ed9c7":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"]},"commit2Childs":{"3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e":[],"f56ba5d8fecfb0b8bfdca8c0b630372d998131a9":["3251bdaf728baf81f779183e464984bc769ed9c7"],"0a16b40feb4e6e0d55c1716733bde48296bedd20":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7d615ef411046679022f6728bb2b876273d13ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b7d615ef411046679022f6728bb2b876273d13ae":["f56ba5d8fecfb0b8bfdca8c0b630372d998131a9"],"3251bdaf728baf81f779183e464984bc769ed9c7":["0a16b40feb4e6e0d55c1716733bde48296bedd20"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3cf3e973ce145ef8b164e2e7c0d57cf807cf9a6e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}