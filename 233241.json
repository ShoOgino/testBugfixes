{"path":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","commits":[{"id":"d2ed1b9b7b46829fe3199afe9a8bc203f201b175","date":1301491807,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"/dev/null","sourceNew":"  private boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      try {\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n        finishFlushedSegment(newSegment);\n      } finally {\n          flushControl.doAfterFlush(flushingDWPT);\n          flushingDWPT.checkAndResetHasAborted();\n          indexWriter.flushCount.incrementAndGet();\n      }\n        flushingDWPT =  flushControl.nextPendingFlush() ;\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"327863a2fd61e831028b6c56c8fef6b00a44eb0b","date":1302686439,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        synchronized (ticketQueue) {\n         // each flush is assigned a ticket in the order they accquire the ticketQueue lock\n         ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n         ticketQueue.add(ticket);\n        }\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n        success = true;\n        /*\n         * now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets(ticket, newSegment);\n      } finally {\n          flushControl.doAfterFlush(flushingDWPT);\n          flushingDWPT.checkAndResetHasAborted();\n          indexWriter.flushCount.incrementAndGet();\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n            // in the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed\n              ticket.isSegmentFlush = false;\n             \n            }\n          }\n      }\n      flushingDWPT =  flushControl.nextPendingFlush() ;\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      try {\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n        finishFlushedSegment(newSegment);\n      } finally {\n          flushControl.doAfterFlush(flushingDWPT);\n          flushingDWPT.checkAndResetHasAborted();\n          indexWriter.flushCount.incrementAndGet();\n      }\n        flushingDWPT =  flushControl.nextPendingFlush() ;\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":["7d45e9e2ad7f57776540627c78f5e22e469ccdc1","33e096accda90a8bd2279f890efe2e287f47c743"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d45e9e2ad7f57776540627c78f5e22e469ccdc1","date":1302784878,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        synchronized (ticketQueue) {\n         // each flush is assigned a ticket in the order they accquire the ticketQueue lock\n         ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n         ticketQueue.add(ticket);\n        }\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n        success = true;\n        /*\n         * now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets(ticket, newSegment);\n      } finally {\n          flushControl.doAfterFlush(flushingDWPT);\n          flushingDWPT.checkAndResetHasAborted();\n          indexWriter.flushCount.incrementAndGet();\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // in the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed\n              ticket.isSegmentFlush = false;\n             \n            }\n          }\n      }\n      flushingDWPT =  flushControl.nextPendingFlush() ;\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        synchronized (ticketQueue) {\n         // each flush is assigned a ticket in the order they accquire the ticketQueue lock\n         ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n         ticketQueue.add(ticket);\n        }\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n        success = true;\n        /*\n         * now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets(ticket, newSegment);\n      } finally {\n          flushControl.doAfterFlush(flushingDWPT);\n          flushingDWPT.checkAndResetHasAborted();\n          indexWriter.flushCount.incrementAndGet();\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n            // in the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed\n              ticket.isSegmentFlush = false;\n             \n            }\n          }\n      }\n      flushingDWPT =  flushControl.nextPendingFlush() ;\n    }\n    return maybeMerge;\n  }\n\n","bugFix":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"bugIntro":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f6f4cae61e16730201371ab7e9912721c19324e7","date":1303199575,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        synchronized (ticketQueue) {\n          // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n          ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n          ticketQueue.add(ticket);\n        }\n\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n\n        // nocommit -- should this success = true be moved\n        // under the applyFlushTickets?\n        success = true;\n\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets(ticket, newSegment);\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        if (!success && ticket != null) {\n          synchronized (ticketQueue) {\n            // nocommit -- shouldn't we drop the ticket in\n            // this case?\n            // In the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed\n            ticket.isSegmentFlush = false;\n          }\n        }\n      }\n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        synchronized (ticketQueue) {\n         // each flush is assigned a ticket in the order they accquire the ticketQueue lock\n         ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n         ticketQueue.add(ticket);\n        }\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n        success = true;\n        /*\n         * now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets(ticket, newSegment);\n      } finally {\n          flushControl.doAfterFlush(flushingDWPT);\n          flushingDWPT.checkAndResetHasAborted();\n          indexWriter.flushCount.incrementAndGet();\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // in the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed\n              ticket.isSegmentFlush = false;\n             \n            }\n          }\n      }\n      flushingDWPT =  flushControl.nextPendingFlush() ;\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4","date":1303818069,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        synchronized (ticketQueue) {\n          // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n          ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n          ticketQueue.add(ticket);\n        }\n\n        // flush concurrently without locking\n        final FlushedSegment newSegment = flushingDWPT.flush();\n\n        // nocommit -- should this success = true be moved\n        // under the applyFlushTickets?\n        success = true;\n\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets(ticket, newSegment);\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        if (!success && ticket != null) {\n          synchronized (ticketQueue) {\n            // nocommit -- shouldn't we drop the ticket in\n            // this case?\n            // In the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed\n            ticket.isSegmentFlush = false;\n          }\n        }\n      }\n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":["fdc3f2b9a4e1c1aacfa53b304c4e42c13a1677ef","a1c3710e755dc60691ac0d7fe23c9fcba0537bdc","33e096accda90a8bd2279f890efe2e287f47c743"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"/dev/null","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"/dev/null","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32f306edd62f81390a6e263e8b913f089f3e98a1","date":1305615519,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","bugFix":["7d45e9e2ad7f57776540627c78f5e22e469ccdc1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      \n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"/dev/null","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7465988fd0a9c673dcb88f51473300c41d630f0","date":1311685662,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e529a1575ef832b87239240d5fb357a066a97487","date":1311706870,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        message(\"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6adfdb3f33dbaf27203539f573faac3966cc55f","date":1318443641,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        message(\"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they accquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        message(\"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":["33e096accda90a8bd2279f890efe2e287f47c743"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a1c3710e755dc60691ac0d7fe23c9fcba0537bdc","date":1320437768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.incrementAndAdd(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        message(\"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.add(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        message(\"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":["761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4"],"bugIntro":["33e096accda90a8bd2279f890efe2e287f47c743"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.incrementAndAdd(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.incrementAndAdd(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        message(\"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58c6bbc222f074c844e736e6fb23647e3db9cfe3","date":1322743940,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.incrementAndAdd(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.incrementAndAdd(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream != null) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33e096accda90a8bd2279f890efe2e287f47c743","date":1326726424,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      SegmentFlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n          ticket = ticketQueue.addFlushTicket(flushingDWPT);\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          ticketQueue.addSegment(ticket, newSegment);\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            // In the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed since the flush\n            // ticket could hold global deletes see FlushTicket#canPublish()\n            ticketQueue.markTicketFailed(ticket);\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        ticketQueue.tryPurge(this);\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      FlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          synchronized (ticketQueue) {\n            // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n            ticket =  new FlushTicket(flushingDWPT.prepareFlush(), true);\n            ticketQueue.incrementAndAdd(ticket);\n          }\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          synchronized (ticketQueue) {\n            ticket.segment = newSegment;\n          }\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            synchronized (ticketQueue) {\n              // In the case of a failure make sure we are making progress and\n              // apply all the deletes since the segment flush failed since the flush\n              // ticket could hold global deletes see FlushTicket#canPublish()\n              ticket.isSegmentFlush = false;\n            }\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        applyFlushTickets();\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":["327863a2fd61e831028b6c56c8fef6b00a44eb0b","761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4","a1c3710e755dc60691ac0d7fe23c9fcba0537bdc","a6adfdb3f33dbaf27203539f573faac3966cc55f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/DocumentsWriter#doFlush(DocumentsWriterPerThread).mjava","sourceNew":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      SegmentFlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n          ticket = ticketQueue.addFlushTicket(flushingDWPT);\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          ticketQueue.addSegment(ticket, newSegment);\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            // In the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed since the flush\n            // ticket could hold global deletes see FlushTicket#canPublish()\n            ticketQueue.markTicketFailed(ticket);\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        ticketQueue.tryPurge(this);\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","sourceOld":"  private  boolean doFlush(DocumentsWriterPerThread flushingDWPT) throws IOException {\n    boolean maybeMerge = false;\n    while (flushingDWPT != null) {\n      maybeMerge = true;\n      boolean success = false;\n      SegmentFlushTicket ticket = null;\n      try {\n        assert currentFullFlushDelQueue == null\n            || flushingDWPT.deleteQueue == currentFullFlushDelQueue : \"expected: \"\n            + currentFullFlushDelQueue + \"but was: \" + flushingDWPT.deleteQueue\n            + \" \" + flushControl.isFullFlush();\n        /*\n         * Since with DWPT the flush process is concurrent and several DWPT\n         * could flush at the same time we must maintain the order of the\n         * flushes before we can apply the flushed segment and the frozen global\n         * deletes it is buffering. The reason for this is that the global\n         * deletes mark a certain point in time where we took a DWPT out of\n         * rotation and freeze the global deletes.\n         * \n         * Example: A flush 'A' starts and freezes the global deletes, then\n         * flush 'B' starts and freezes all deletes occurred since 'A' has\n         * started. if 'B' finishes before 'A' we need to wait until 'A' is done\n         * otherwise the deletes frozen by 'B' are not applied to 'A' and we\n         * might miss to deletes documents in 'A'.\n         */\n        try {\n          // Each flush is assigned a ticket in the order they acquire the ticketQueue lock\n          ticket = ticketQueue.addFlushTicket(flushingDWPT);\n  \n          // flush concurrently without locking\n          final FlushedSegment newSegment = flushingDWPT.flush();\n          ticketQueue.addSegment(ticket, newSegment);\n          // flush was successful once we reached this point - new seg. has been assigned to the ticket!\n          success = true;\n        } finally {\n          if (!success && ticket != null) {\n            // In the case of a failure make sure we are making progress and\n            // apply all the deletes since the segment flush failed since the flush\n            // ticket could hold global deletes see FlushTicket#canPublish()\n            ticketQueue.markTicketFailed(ticket);\n          }\n        }\n        /*\n         * Now we are done and try to flush the ticket queue if the head of the\n         * queue has already finished the flush.\n         */\n        ticketQueue.tryPurge(this);\n      } finally {\n        flushControl.doAfterFlush(flushingDWPT);\n        flushingDWPT.checkAndResetHasAborted();\n        indexWriter.flushCount.incrementAndGet();\n        indexWriter.doAfterFlush();\n      }\n     \n      flushingDWPT = flushControl.nextPendingFlush();\n    }\n\n    // If deletes alone are consuming > 1/2 our RAM\n    // buffer, force them all to apply now. This is to\n    // prevent too-frequent flushing of a long tail of\n    // tiny segments:\n    final double ramBufferSizeMB = indexWriter.getConfig().getRAMBufferSizeMB();\n    if (ramBufferSizeMB != IndexWriterConfig.DISABLE_AUTO_FLUSH &&\n        flushControl.getDeleteBytesUsed() > (1024*1024*ramBufferSizeMB/2)) {\n      if (infoStream.isEnabled(\"DW\")) {\n        infoStream.message(\"DW\", \"force apply deletes bytesUsed=\" + flushControl.getDeleteBytesUsed() + \" vs ramBuffer=\" + (1024*1024*ramBufferSizeMB));\n      }\n      applyAllDeletes(deleteQueue);\n    }\n\n    return maybeMerge;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["06584e6e98d592b34e1329b384182f368d2025e8"],"761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4":["f6f4cae61e16730201371ab7e9912721c19324e7"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["33e096accda90a8bd2279f890efe2e287f47c743"],"06584e6e98d592b34e1329b384182f368d2025e8":["a1c3710e755dc60691ac0d7fe23c9fcba0537bdc"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4"],"a6adfdb3f33dbaf27203539f573faac3966cc55f":["e529a1575ef832b87239240d5fb357a066a97487"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"f6f4cae61e16730201371ab7e9912721c19324e7":["7d45e9e2ad7f57776540627c78f5e22e469ccdc1"],"7d45e9e2ad7f57776540627c78f5e22e469ccdc1":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["135621f3a0670a9394eb563224a3b76cc4dddc0f","32f306edd62f81390a6e263e8b913f089f3e98a1"],"b7465988fd0a9c673dcb88f51473300c41d630f0":["32f306edd62f81390a6e263e8b913f089f3e98a1"],"a3776dccca01c11e7046323cfad46a3b4a471233":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","32f306edd62f81390a6e263e8b913f089f3e98a1"],"a1c3710e755dc60691ac0d7fe23c9fcba0537bdc":["a6adfdb3f33dbaf27203539f573faac3966cc55f"],"32f306edd62f81390a6e263e8b913f089f3e98a1":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e529a1575ef832b87239240d5fb357a066a97487":["b7465988fd0a9c673dcb88f51473300c41d630f0"],"33e096accda90a8bd2279f890efe2e287f47c743":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["33e096accda90a8bd2279f890efe2e287f47c743"],"761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"06584e6e98d592b34e1329b384182f368d2025e8":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","32f306edd62f81390a6e263e8b913f089f3e98a1"],"a6adfdb3f33dbaf27203539f573faac3966cc55f":["a1c3710e755dc60691ac0d7fe23c9fcba0537bdc"],"327863a2fd61e831028b6c56c8fef6b00a44eb0b":["7d45e9e2ad7f57776540627c78f5e22e469ccdc1"],"f6f4cae61e16730201371ab7e9912721c19324e7":["761f91143f5b5b8e3016b2b178ee0f2f61a9b4e4"],"d2ed1b9b7b46829fe3199afe9a8bc203f201b175":["327863a2fd61e831028b6c56c8fef6b00a44eb0b"],"7d45e9e2ad7f57776540627c78f5e22e469ccdc1":["f6f4cae61e16730201371ab7e9912721c19324e7"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"b7465988fd0a9c673dcb88f51473300c41d630f0":["e529a1575ef832b87239240d5fb357a066a97487"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"a1c3710e755dc60691ac0d7fe23c9fcba0537bdc":["06584e6e98d592b34e1329b384182f368d2025e8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["135621f3a0670a9394eb563224a3b76cc4dddc0f","b3e06be49006ecac364d39d12b9c9f74882f9b9f","d2ed1b9b7b46829fe3199afe9a8bc203f201b175","a3776dccca01c11e7046323cfad46a3b4a471233"],"32f306edd62f81390a6e263e8b913f089f3e98a1":["c3a8a449466c1ff7ce2274fe73dab487256964b4","b7465988fd0a9c673dcb88f51473300c41d630f0","a3776dccca01c11e7046323cfad46a3b4a471233"],"e529a1575ef832b87239240d5fb357a066a97487":["a6adfdb3f33dbaf27203539f573faac3966cc55f"],"33e096accda90a8bd2279f890efe2e287f47c743":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}