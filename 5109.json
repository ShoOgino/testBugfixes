{"path":"backwards/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","commits":[{"id":"480d01e5b0ef8efb136d51670fec297ae5ae2c9c","date":1268821447,"type":0,"author":"Uwe Schindler","isMerge":false,"pathNew":"backwards/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"/dev/null","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/backwards/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","pathOld":"backwards/src/java/org/apache/lucene/index/SegmentInfos.FindSegmentsFile#run(IndexCommit).mjava","sourceNew":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","sourceOld":"    public Object run(IndexCommit commit) throws CorruptIndexException, IOException {\n      if (commit != null) {\n        if (directory != commit.getDirectory())\n          throw new IOException(\"the specified commit does not match the specified Directory\");\n        return doBody(commit.getSegmentsFileName());\n      }\n\n      String segmentFileName = null;\n      long lastGen = -1;\n      long gen = 0;\n      int genLookaheadCount = 0;\n      IOException exc = null;\n      boolean retry = false;\n\n      int method = 0;\n\n      // Loop until we succeed in calling doBody() without\n      // hitting an IOException.  An IOException most likely\n      // means a commit was in process and has finished, in\n      // the time it took us to load the now-old infos files\n      // (and segments files).  It's also possible it's a\n      // true error (corrupt index).  To distinguish these,\n      // on each retry we must see \"forward progress\" on\n      // which generation we are trying to load.  If we\n      // don't, then the original error is real and we throw\n      // it.\n      \n      // We have three methods for determining the current\n      // generation.  We try the first two in parallel, and\n      // fall back to the third when necessary.\n\n      while(true) {\n\n        if (0 == method) {\n\n          // Method 1: list the directory and use the highest\n          // segments_N file.  This method works well as long\n          // as there is no stale caching on the directory\n          // contents (NOTE: NFS clients often have such stale\n          // caching):\n          String[] files = null;\n\n          long genA = -1;\n\n          files = directory.listAll();\n          \n          if (files != null)\n            genA = getCurrentSegmentGeneration(files);\n\n          message(\"directory listing genA=\" + genA);\n\n          // Method 2: open segments.gen and read its\n          // contents.  Then we take the larger of the two\n          // gen's.  This way, if either approach is hitting\n          // a stale cache (NFS) we have a better chance of\n          // getting the right generation.\n          long genB = -1;\n          for(int i=0;i<defaultGenFileRetryCount;i++) {\n            IndexInput genInput = null;\n            try {\n              genInput = directory.openInput(IndexFileNames.SEGMENTS_GEN);\n            } catch (FileNotFoundException e) {\n              message(\"segments.gen open: FileNotFoundException \" + e);\n              break;\n            } catch (IOException e) {\n              message(\"segments.gen open: IOException \" + e);\n            }\n  \n            if (genInput != null) {\n              try {\n                int version = genInput.readInt();\n                if (version == FORMAT_LOCKLESS) {\n                  long gen0 = genInput.readLong();\n                  long gen1 = genInput.readLong();\n                  message(\"fallback check: \" + gen0 + \"; \" + gen1);\n                  if (gen0 == gen1) {\n                    // The file is consistent.\n                    genB = gen0;\n                    break;\n                  }\n                }\n              } catch (IOException err2) {\n                // will retry\n              } finally {\n                genInput.close();\n              }\n            }\n            try {\n              Thread.sleep(defaultGenFileRetryPauseMsec);\n            } catch (InterruptedException ie) {\n              throw new ThreadInterruptedException(ie);\n            }\n          }\n\n          message(IndexFileNames.SEGMENTS_GEN + \" check: genB=\" + genB);\n\n          // Pick the larger of the two gen's:\n          if (genA > genB)\n            gen = genA;\n          else\n            gen = genB;\n          \n          if (gen == -1) {\n            // Neither approach found a generation\n            throw new FileNotFoundException(\"no segments* file found in \" + directory + \": files: \" + Arrays.toString(files));\n          }\n        }\n\n        // Third method (fallback if first & second methods\n        // are not reliable): since both directory cache and\n        // file contents cache seem to be stale, just\n        // advance the generation.\n        if (1 == method || (0 == method && lastGen == gen && retry)) {\n\n          method = 1;\n\n          if (genLookaheadCount < defaultGenLookaheadCount) {\n            gen++;\n            genLookaheadCount++;\n            message(\"look ahead increment gen to \" + gen);\n          }\n        }\n\n        if (lastGen == gen) {\n\n          // This means we're about to try the same\n          // segments_N last tried.  This is allowed,\n          // exactly once, because writer could have been in\n          // the process of writing segments_N last time.\n\n          if (retry) {\n            // OK, we've tried the same segments_N file\n            // twice in a row, so this must be a real\n            // error.  We throw the original exception we\n            // got.\n            throw exc;\n          } else {\n            retry = true;\n          }\n\n        } else if (0 == method) {\n          // Segment file has advanced since our last loop, so\n          // reset retry:\n          retry = false;\n        }\n\n        lastGen = gen;\n\n        segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                \"\",\n                                                                gen);\n\n        try {\n          Object v = doBody(segmentFileName);\n          if (exc != null) {\n            message(\"success on \" + segmentFileName);\n          }\n          return v;\n        } catch (IOException err) {\n\n          // Save the original root cause:\n          if (exc == null) {\n            exc = err;\n          }\n\n          message(\"primary Exception on '\" + segmentFileName + \"': \" + err + \"'; will retry: retry=\" + retry + \"; gen = \" + gen);\n\n          if (!retry && gen > 1) {\n\n            // This is our first time trying this segments\n            // file (because retry is false), and, there is\n            // possibly a segments_(N-1) (because gen > 1).\n            // So, check if the segments_(N-1) exists and\n            // try it if so:\n            String prevSegmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS,\n                                                                               \"\",\n                                                                               gen-1);\n\n            final boolean prevExists;\n            prevExists = directory.fileExists(prevSegmentFileName);\n\n            if (prevExists) {\n              message(\"fallback to prior segment file '\" + prevSegmentFileName + \"'\");\n              try {\n                Object v = doBody(prevSegmentFileName);\n                if (exc != null) {\n                  message(\"success on fallback \" + prevSegmentFileName);\n                }\n                return v;\n              } catch (IOException err2) {\n                message(\"secondary Exception on '\" + prevSegmentFileName + \"': \" + err2 + \"'; will retry\");\n              }\n            }\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"]},"commit2Childs":{"480d01e5b0ef8efb136d51670fec297ae5ae2c9c":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["480d01e5b0ef8efb136d51670fec297ae5ae2c9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}