{"path":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","commits":[{"id":"ec1ff48f427e50e77e8d613a82e026521f628838","date":1321406846,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<String>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["92f8ab19a30ff70981e43b8cc78069cb0941476e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"206dd656d2bad51b47a453ca18c1328d317dd1ed","date":1391603013,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test @Ignore(\"Please fix me!\")\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<String>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<String>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["fc62c53ff8c243df3b582b572bb934b0e79d3467"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fc62c53ff8c243df3b582b572bb934b0e79d3467","date":1391619952,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<String>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":"  @Test @Ignore(\"Please fix me!\")\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<String>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":["206dd656d2bad51b47a453ca18c1328d317dd1ed"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<String>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"92f8ab19a30ff70981e43b8cc78069cb0941476e","date":1497374252,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":["ec1ff48f427e50e77e8d613a82e026521f628838"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] { \"ti\", \"tf\", \"td\", \"tl\" }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92f789dbd1886e4b468e61b0def88b29a3f55228","date":1533844010,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","pathOld":"solr/core/src/test/org/apache/solr/BasicFunctionalityTest#testClientErrorOnMalformedNumbers().mjava","sourceNew":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      SolrException e1 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a non-number: \" + field,\n          () -> h.update(add( doc(\"id\",\"100\", field, BAD_VALUE))));\n      String msg1 = e1.toString();\n      assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg1,\n          400 <= e1.code() && e1.code() < 500);\n      assertTrue(\"(update) client error does not mention bad value: \" + msg1,\n          msg1.contains(BAD_VALUE));\n      assertTrue(\"client error does not mention document id\",\n          msg1.contains(\"[doc=100]\"));\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n\n      SolrException e2 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a non-number: \" + field,\n          () -> h.query(req(\"q\",field + \":\" + BAD_VALUE))\n      );\n      String msg2 = e2.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg2,\n          400 <= e2.code() && e2.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg2,\n          msg2.contains(BAD_VALUE));\n\n      SolrException e3 = expectThrows(SolrException.class,\n          \"Didn't encounter an error trying to add a non-number: \" + field,\n          () -> h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"))\n      );\n      String msg3 = e3.toString();\n      assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg3,\n          400 <= e3.code() && e3.code() < 500);\n      assertTrue(\"(search) client error does not mention bad value: \" + msg3,\n          msg3.contains(BAD_VALUE));\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testClientErrorOnMalformedNumbers() throws Exception {\n\n    final String BAD_VALUE = \"NOT_A_NUMBER\";\n    ignoreException(BAD_VALUE);\n\n    final List<String> FIELDS = new LinkedList<>();\n    for (String type : new String[] {\n        \"ti\", \"tf\", \"td\", \"tl\",\n        \"i\", \"f\", \"d\", \"l\",\n        \"i_dv\", \"f_dv\", \"d_dv\", \"l_dv\",\n        \"i_dvo\", \"f_dvo\", \"d_dvo\", \"l_dvo\",\n        \"i_os\", \"f_os\", \"d_os\", \"l_os\"\n        }) {\n      FIELDS.add(\"malformed_\" + type);\n    }\n\n    // test that malformed numerics cause client error not server error\n    for (String field : FIELDS) {\n      try {\n        h.update(add( doc(\"id\",\"100\", field, BAD_VALUE)));\n        fail(\"Didn't encounter an error trying to add a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not an (update) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(update) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n        assertTrue(\"client error does not mention document id\",\n                   msg.contains(\"[doc=100]\"));\n      }\n      SchemaField sf = h.getCore().getLatestSchema().getField(field); \n      if (!sf.hasDocValues() && !sf.indexed()) {\n        continue;\n      }\n      try {\n        h.query(req(\"q\",field + \":\" + BAD_VALUE));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n      try {\n        h.query(req(\"q\",field + \":[10 TO \" + BAD_VALUE + \"]\"));\n        fail(\"Didn't encounter an error trying to query a non-number: \" + field);\n      } catch (SolrException e) {\n        String msg = e.toString();\n        assertTrue(\"not a (search) client error on field: \" + field +\" : \"+ msg,\n                   400 <= e.code() && e.code() < 500);\n        assertTrue(\"(search) client error does not mention bad value: \" + msg,\n                   msg.contains(BAD_VALUE));\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["fc62c53ff8c243df3b582b572bb934b0e79d3467"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"92f789dbd1886e4b468e61b0def88b29a3f55228":["28288370235ed02234a64753cdbf0c6ec096304a"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"fc62c53ff8c243df3b582b572bb934b0e79d3467":["206dd656d2bad51b47a453ca18c1328d317dd1ed"],"206dd656d2bad51b47a453ca18c1328d317dd1ed":["ec1ff48f427e50e77e8d613a82e026521f628838"],"ec1ff48f427e50e77e8d613a82e026521f628838":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"28288370235ed02234a64753cdbf0c6ec096304a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","92f8ab19a30ff70981e43b8cc78069cb0941476e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92f789dbd1886e4b468e61b0def88b29a3f55228"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["92f8ab19a30ff70981e43b8cc78069cb0941476e","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec1ff48f427e50e77e8d613a82e026521f628838"],"92f789dbd1886e4b468e61b0def88b29a3f55228":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"92f8ab19a30ff70981e43b8cc78069cb0941476e":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"fc62c53ff8c243df3b582b572bb934b0e79d3467":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"206dd656d2bad51b47a453ca18c1328d317dd1ed":["fc62c53ff8c243df3b582b572bb934b0e79d3467"],"28288370235ed02234a64753cdbf0c6ec096304a":["92f789dbd1886e4b468e61b0def88b29a3f55228"],"ec1ff48f427e50e77e8d613a82e026521f628838":["206dd656d2bad51b47a453ca18c1328d317dd1ed"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}