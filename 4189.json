{"path":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","commits":[{"id":"dd745d580729e528151b58aeda87ef82f1b95c9b","date":1248369082,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","pathOld":"contrib/analyzers/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","sourceNew":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList hw = (ArrayList) stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList hw = (ArrayList) stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"60cdc0e643184821eb066795a8791cd82559f46e","date":1257941914,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","pathOld":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","sourceNew":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList hw = stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList hw = (ArrayList) stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a","date":1267298041,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","pathOld":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","sourceNew":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList<Object> hw = stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList hw = stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","pathOld":"contrib/analyzers/common/src/java/org/apache/lucene/analysis/compound/hyphenation/HyphenationTree#hyphenate(char[],int,int,int,int).mjava","sourceNew":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList<Object> hw = stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  /**\n   * Hyphenate word and return an array of hyphenation points.\n   * \n   * @param w char array that contains the word\n   * @param offset Offset to first character in word\n   * @param len Length of word\n   * @param remainCharCount Minimum number of characters allowed before the\n   *        hyphenation point.\n   * @param pushCharCount Minimum number of characters allowed after the\n   *        hyphenation point.\n   * @return a {@link Hyphenation Hyphenation} object representing the\n   *         hyphenated word or null if word is not hyphenated.\n   */\n  public Hyphenation hyphenate(char[] w, int offset, int len,\n      int remainCharCount, int pushCharCount) {\n    int i;\n    char[] word = new char[len + 3];\n\n    // normalize word\n    char[] c = new char[2];\n    int iIgnoreAtBeginning = 0;\n    int iLength = len;\n    boolean bEndOfLetters = false;\n    for (i = 1; i <= len; i++) {\n      c[0] = w[offset + i - 1];\n      int nc = classmap.find(c, 0);\n      if (nc < 0) { // found a non-letter character ...\n        if (i == (1 + iIgnoreAtBeginning)) {\n          // ... before any letter character\n          iIgnoreAtBeginning++;\n        } else {\n          // ... after a letter character\n          bEndOfLetters = true;\n        }\n        iLength--;\n      } else {\n        if (!bEndOfLetters) {\n          word[i - iIgnoreAtBeginning] = (char) nc;\n        } else {\n          return null;\n        }\n      }\n    }\n    len = iLength;\n    if (len < (remainCharCount + pushCharCount)) {\n      // word is too short to be hyphenated\n      return null;\n    }\n    int[] result = new int[len + 1];\n    int k = 0;\n\n    // check exception list first\n    String sw = new String(word, 1, len);\n    if (stoplist.containsKey(sw)) {\n      // assume only simple hyphens (Hyphen.pre=\"-\", Hyphen.post = Hyphen.no =\n      // null)\n      ArrayList<Object> hw = stoplist.get(sw);\n      int j = 0;\n      for (i = 0; i < hw.size(); i++) {\n        Object o = hw.get(i);\n        // j = index(sw) = letterindex(word)?\n        // result[k] = corresponding index(w)\n        if (o instanceof String) {\n          j += ((String) o).length();\n          if (j >= remainCharCount && j < (len - pushCharCount)) {\n            result[k++] = j + iIgnoreAtBeginning;\n          }\n        }\n      }\n    } else {\n      // use algorithm to get hyphenation points\n      word[0] = '.'; // word start marker\n      word[len + 1] = '.'; // word end marker\n      word[len + 2] = 0; // null terminated\n      byte[] il = new byte[len + 3]; // initialized to zero\n      for (i = 0; i < len + 1; i++) {\n        searchPatterns(word, i, il);\n      }\n\n      // hyphenation points are located where interletter value is odd\n      // i is letterindex(word),\n      // i + 1 is index(word),\n      // result[k] = corresponding index(w)\n      for (i = 0; i < len; i++) {\n        if (((il[i + 1] & 1) == 1) && i >= remainCharCount\n            && i <= (len - pushCharCount)) {\n          result[k++] = i + iIgnoreAtBeginning;\n        }\n      }\n    }\n\n    if (k > 0) {\n      // trim result array\n      int[] res = new int[k+2];\n      System.arraycopy(result, 0, res, 1, k);\n      // We add the synthetical hyphenation points\n      // at the beginning and end of the word\n      res[0]=0;\n      res[k+1]=len;\n      return new Hyphenation(res);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"60cdc0e643184821eb066795a8791cd82559f46e":["dd745d580729e528151b58aeda87ef82f1b95c9b"],"dd745d580729e528151b58aeda87ef82f1b95c9b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["60cdc0e643184821eb066795a8791cd82559f46e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"]},"commit2Childs":{"60cdc0e643184821eb066795a8791cd82559f46e":["a9ac13b5f0ce5ef1b2ce168367d993a79594b23a"],"dd745d580729e528151b58aeda87ef82f1b95c9b":["60cdc0e643184821eb066795a8791cd82559f46e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd745d580729e528151b58aeda87ef82f1b95c9b"],"a9ac13b5f0ce5ef1b2ce168367d993a79594b23a":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}