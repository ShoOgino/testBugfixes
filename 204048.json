{"path":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","commits":[{"id":"27274410c91546fcfc28e692abd2dd77ca99be4b","date":1042501834,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"/dev/null","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      if (weights.size() == 1) {                  // optimize 1-clause queries\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(0);\n        if (!c.prohibited)\t\t\t  // just return clause scorer\n          return w.scorer(reader);\n      }\n\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"917a0c943aa5659b50fffad7167c838653bd809d","date":1042572030,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      if (weights.size() == 1) {                  // optimize 1-clause queries\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(0);\n        if (!c.prohibited)\t\t\t  // just return clause scorer\n          return w.scorer(reader);\n      }\n\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff40ad80f7ee098df7921f3467ede1806a08284b","date":1044643516,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15c469602973ef1a33c9a07367a380d278ffab20","date":1074206555,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;      \n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(searcher.getSimilarity());\n        for (int i = 0 ; i < weights.size(); i++) {\n          BooleanClause c = (BooleanClause)clauses.elementAt(i);\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c","date":1076095160,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;      \n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          BooleanClause c = (BooleanClause)clauses.elementAt(i);\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;      \n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(searcher.getSimilarity());\n        for (int i = 0 ; i < weights.size(); i++) {\n          BooleanClause c = (BooleanClause)clauses.elementAt(i);\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(searcher.getSimilarity());\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca7cd2ad66547827fd308bca603a45a46ac255bf","date":1079636718,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          BooleanClause c = (BooleanClause)clauses.elementAt(i);\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;      \n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          BooleanClause c = (BooleanClause)clauses.elementAt(i);\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c8177df921c9b4c00d7fdfa1b22ceb76fa19a34","date":1084295884,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          BooleanClause c = (BooleanClause)clauses.elementAt(i);\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d1fc81afb0c32e0b7589e656cceb5cf177093fa","date":1093637352,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.required)\n          allRequired = false;\n        if (c.query instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.required, c.prohibited);\n        else if (c.required)\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29d6eadc26bef1d3f5d3804b90cb7ba77162d007","date":1106594461,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /** @return A good old 1.4 Scorer */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"402061809f3a4629ea0c449e33e9f94a9772f3c3","date":1113967712,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /** @return A good old 1.4 Scorer */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(similarity);\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(similarity);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    /** @return A good old 1.4 Scorer */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(getSimilarity(searcher));\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(getSimilarity(searcher));\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e","date":1166323237,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /** @return A good old 1.4 Scorer */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(similarity);\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(similarity);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    /** @return A good old 1.4 Scorer */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(similarity);\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(similarity);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6212677fdd165340d4284ad2530970c664042d6e","date":1180380790,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /** @return Returns BooleanScorer2 that uses and provides skipTo(),\n     *          and scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    /** @return A good old 1.4 Scorer */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // First see if the (faster) ConjunctionScorer will work.  This can be\n      // used when all clauses are required.  Also, at this point a\n      // BooleanScorer cannot be embedded in a ConjunctionScorer, as the hits\n      // from a BooleanScorer are not always sorted by document number (sigh)\n      // and hence BooleanScorer cannot implement skipTo() correctly, which is\n      // required by ConjunctionScorer.\n      boolean allRequired = true;\n      boolean noneBoolean = true;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        if (!c.isRequired())\n          allRequired = false;\n        if (c.getQuery() instanceof BooleanQuery)\n          noneBoolean = false;\n      }\n\n      if (allRequired && noneBoolean) {           // ConjunctionScorer is okay\n        ConjunctionScorer result =\n          new ConjunctionScorer(similarity);\n        for (int i = 0 ; i < weights.size(); i++) {\n          Weight w = (Weight)weights.elementAt(i);\n          Scorer subScorer = w.scorer(reader);\n          if (subScorer == null)\n            return null;\n          result.add(subScorer);\n        }\n        return result;\n      }\n\n      // Use good-old BooleanScorer instead.\n      BooleanScorer result = new BooleanScorer(similarity);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19f758d6efad251890e720eb5370329f6ab5b509","date":1217253519,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /** @return Returns BooleanScorer2 that uses and provides skipTo(),\n     *          and scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    /** @return Returns BooleanScorer2 that uses and provides skipTo(),\n     *          and scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc","date":1241865401,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /** @return Returns BooleanScorer2 that uses and provides skipTo(),\n     *          and scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // TODO (3.0): instantiate either BS or BS2, according to\n      // allowDocsOutOfOrder (basically, try to inline BS2.score(Collector)'s\n      // logic.\n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    /** @return Returns BooleanScorer2 that uses and provides skipTo(),\n     *          and scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30a558487f2298c2c19ceca9103c1b6865d64708","date":1244393921,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":"    /**\n     * @return Returns BooleanScorer2 that uses and provides advance(), and\n     *         scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // TODO (3.0): instantiate either BS or BS2, according to\n      // allowDocsOutOfOrder (basically, try to inline BS2.score(Collector)'s\n      // logic.\n      \n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","sourceOld":"    /** @return Returns BooleanScorer2 that uses and provides skipTo(),\n     *          and scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // TODO (3.0): instantiate either BS or BS2, according to\n      // allowDocsOutOfOrder (basically, try to inline BS2.score(Collector)'s\n      // logic.\n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#scorer(IndexReader).mjava","sourceNew":null,"sourceOld":"    /**\n     * @return Returns BooleanScorer2 that uses and provides advance(), and\n     *         scores documents in document number order.\n     */\n    public Scorer scorer(IndexReader reader) throws IOException {\n      // TODO (3.0): instantiate either BS or BS2, according to\n      // allowDocsOutOfOrder (basically, try to inline BS2.score(Collector)'s\n      // logic.\n      \n      BooleanScorer2 result = new BooleanScorer2(similarity,\n                                                 minNrShouldMatch,\n                                                 allowDocsOutOfOrder);\n\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Scorer subScorer = w.scorer(reader);\n        if (subScorer != null)\n          result.add(subScorer, c.isRequired(), c.isProhibited());\n        else if (c.isRequired())\n          return null;\n      }\n\n      return result;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6c8177df921c9b4c00d7fdfa1b22ceb76fa19a34":["ca7cd2ad66547827fd308bca603a45a46ac255bf"],"ff40ad80f7ee098df7921f3467ede1806a08284b":["917a0c943aa5659b50fffad7167c838653bd809d"],"6212677fdd165340d4284ad2530970c664042d6e":["570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e"],"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc":["19f758d6efad251890e720eb5370329f6ab5b509"],"19f758d6efad251890e720eb5370329f6ab5b509":["6212677fdd165340d4284ad2530970c664042d6e"],"30a558487f2298c2c19ceca9103c1b6865d64708":["17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["29d6eadc26bef1d3f5d3804b90cb7ba77162d007"],"ca7cd2ad66547827fd308bca603a45a46ac255bf":["8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c"],"27274410c91546fcfc28e692abd2dd77ca99be4b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0d1fc81afb0c32e0b7589e656cceb5cf177093fa":["6c8177df921c9b4c00d7fdfa1b22ceb76fa19a34"],"570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c":["15c469602973ef1a33c9a07367a380d278ffab20"],"052fac7830290bd38a04cddee1a121ee07656b56":["30a558487f2298c2c19ceca9103c1b6865d64708"],"29d6eadc26bef1d3f5d3804b90cb7ba77162d007":["0d1fc81afb0c32e0b7589e656cceb5cf177093fa"],"917a0c943aa5659b50fffad7167c838653bd809d":["27274410c91546fcfc28e692abd2dd77ca99be4b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["052fac7830290bd38a04cddee1a121ee07656b56"],"15c469602973ef1a33c9a07367a380d278ffab20":["ff40ad80f7ee098df7921f3467ede1806a08284b"]},"commit2Childs":{"6c8177df921c9b4c00d7fdfa1b22ceb76fa19a34":["0d1fc81afb0c32e0b7589e656cceb5cf177093fa"],"ff40ad80f7ee098df7921f3467ede1806a08284b":["15c469602973ef1a33c9a07367a380d278ffab20"],"6212677fdd165340d4284ad2530970c664042d6e":["19f758d6efad251890e720eb5370329f6ab5b509"],"17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc":["30a558487f2298c2c19ceca9103c1b6865d64708"],"19f758d6efad251890e720eb5370329f6ab5b509":["17563f8c3ca7e14d56ce4dcbb3fe9b042ba613cc"],"30a558487f2298c2c19ceca9103c1b6865d64708":["052fac7830290bd38a04cddee1a121ee07656b56"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e"],"ca7cd2ad66547827fd308bca603a45a46ac255bf":["6c8177df921c9b4c00d7fdfa1b22ceb76fa19a34"],"27274410c91546fcfc28e692abd2dd77ca99be4b":["917a0c943aa5659b50fffad7167c838653bd809d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["27274410c91546fcfc28e692abd2dd77ca99be4b"],"0d1fc81afb0c32e0b7589e656cceb5cf177093fa":["29d6eadc26bef1d3f5d3804b90cb7ba77162d007"],"570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e":["6212677fdd165340d4284ad2530970c664042d6e"],"8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c":["ca7cd2ad66547827fd308bca603a45a46ac255bf"],"917a0c943aa5659b50fffad7167c838653bd809d":["ff40ad80f7ee098df7921f3467ede1806a08284b"],"29d6eadc26bef1d3f5d3804b90cb7ba77162d007":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"052fac7830290bd38a04cddee1a121ee07656b56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"15c469602973ef1a33c9a07367a380d278ffab20":["8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}