{"path":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","commits":[{"id":"683242c67a3f6086bae8b1354748fcaa38edfbd5","date":1457575601,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,NumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new NumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new NumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5af5ba0166322092193d4c29880b0f7670fc7ca0","date":1471440525,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      LegacyFieldType ft = new LegacyFieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    LegacyFieldType ft = new LegacyFieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      LegacyFieldType ft = new LegacyFieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    LegacyFieldType ft = new LegacyFieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      LegacyFieldType ft = new LegacyFieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    LegacyFieldType ft = new LegacyFieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"50b8410419cbbe9d8e1a96c918a951976bffe680","date":1471869553,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":null,"sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      LegacyFieldType ft = new LegacyFieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    LegacyFieldType ft = new LegacyFieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c82557b0a8c9d4012f208e5de912ae7500ea351","date":1471888093,"type":4,"author":"Noble Paul","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":null,"sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      LegacyFieldType ft = new LegacyFieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    LegacyFieldType ft = new LegacyFieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":null,"sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      LegacyFieldType ft = new LegacyFieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    LegacyFieldType ft = new LegacyFieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":4,"author":"Kevin Risden","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/queryparser/src/test/org/apache/lucene/queryparser/flexible/standard/TestLegacyNumericQueryParser#beforeClass().mjava","sourceNew":null,"sourceOld":"  @BeforeClass\n  public static void beforeClass() throws Exception {\n    ANALYZER = new MockAnalyzer(random());\n    \n    qp = new StandardQueryParser(ANALYZER);\n    \n    final HashMap<String,Number> randomNumberMap = new HashMap<>();\n    \n    SimpleDateFormat dateFormat;\n    long randomDate;\n    boolean dateFormatSanityCheckPass;\n    int count = 0;\n    do {\n      if (count > 100) {\n        fail(\"This test has problems to find a sane random DateFormat/NumberFormat. Stopped trying after 100 iterations.\");\n      }\n      \n      dateFormatSanityCheckPass = true;\n      LOCALE = randomLocale(random());\n      TIMEZONE = randomTimeZone(random());\n      DATE_STYLE = randomDateStyle(random());\n      TIME_STYLE = randomDateStyle(random());\n      \n      // assumes localized date pattern will have at least year, month, day,\n      // hour, minute\n      dateFormat = (SimpleDateFormat) DateFormat.getDateTimeInstance(\n          DATE_STYLE, TIME_STYLE, LOCALE);\n      \n      // not all date patterns includes era, full year, timezone and second,\n      // so we add them here\n      dateFormat.applyPattern(dateFormat.toPattern() + \" G s Z yyyy\");\n      dateFormat.setTimeZone(TIMEZONE);\n      \n      DATE_FORMAT = new NumberDateFormat(dateFormat);\n      \n      do {\n        randomDate = random().nextLong();\n        \n        // prune date value so it doesn't pass in insane values to some\n        // calendars.\n        randomDate = randomDate % 3400000000000l;\n        \n        // truncate to second\n        randomDate = (randomDate / 1000L) * 1000L;\n        \n        // only positive values\n        randomDate = Math.abs(randomDate);\n      } while (randomDate == 0L);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, randomDate);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat, 0);\n      \n      dateFormatSanityCheckPass &= checkDateFormatSanity(dateFormat,\n          -randomDate);\n      \n      count++;\n    } while (!dateFormatSanityCheckPass);\n    \n    NUMBER_FORMAT = NumberFormat.getNumberInstance(LOCALE);\n    NUMBER_FORMAT.setMaximumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumFractionDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMaximumIntegerDigits((random().nextInt() & 20) + 1);\n    NUMBER_FORMAT.setMinimumIntegerDigits((random().nextInt() & 20) + 1);\n    \n    double randomDouble;\n    long randomLong;\n    int randomInt;\n    float randomFloat;\n    \n    while ((randomLong = normalizeNumber(Math.abs(random().nextLong()))\n        .longValue()) == 0L)\n      ;\n    while ((randomDouble = normalizeNumber(Math.abs(random().nextDouble()))\n        .doubleValue()) == 0.0)\n      ;\n    while ((randomFloat = normalizeNumber(Math.abs(random().nextFloat()))\n        .floatValue()) == 0.0f)\n      ;\n    while ((randomInt = normalizeNumber(Math.abs(random().nextInt())).intValue()) == 0)\n      ;\n    \n    randomNumberMap.put(LegacyNumericType.LONG.name(), randomLong);\n    randomNumberMap.put(FieldType.LegacyNumericType.INT.name(), randomInt);\n    randomNumberMap.put(LegacyNumericType.FLOAT.name(), randomFloat);\n    randomNumberMap.put(LegacyNumericType.DOUBLE.name(), randomDouble);\n    randomNumberMap.put(DATE_FIELD_NAME, randomDate);\n    \n    RANDOM_NUMBER_MAP = Collections.unmodifiableMap(randomNumberMap);\n    \n    directory = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), directory,\n        newIndexWriterConfig(new MockAnalyzer(random()))\n            .setMaxBufferedDocs(TestUtil.nextInt(random(), 50, 1000))\n            .setMergePolicy(newLogMergePolicy()));\n    \n    Document doc = new Document();\n    HashMap<String,LegacyNumericConfig> numericConfigMap = new HashMap<>();\n    HashMap<String,Field> numericFieldMap = new HashMap<>();\n    qp.setLegacyNumericConfigMap(numericConfigMap);\n    \n    for (LegacyNumericType type : LegacyNumericType.values()) {\n      numericConfigMap.put(type.name(), new LegacyNumericConfig(PRECISION_STEP,\n          NUMBER_FORMAT, type));\n\n      FieldType ft = new FieldType(LegacyIntField.TYPE_NOT_STORED);\n      ft.setNumericType(type);\n      ft.setStored(true);\n      ft.setNumericPrecisionStep(PRECISION_STEP);\n      ft.freeze();\n      final Field field;\n\n      switch(type) {\n      case INT:\n        field = new LegacyIntField(type.name(), 0, ft);\n        break;\n      case FLOAT:\n        field = new LegacyFloatField(type.name(), 0.0f, ft);\n        break;\n      case LONG:\n        field = new LegacyLongField(type.name(), 0l, ft);\n        break;\n      case DOUBLE:\n        field = new LegacyDoubleField(type.name(), 0.0, ft);\n        break;\n      default:\n        fail();\n        field = null;\n      }\n      numericFieldMap.put(type.name(), field);\n      doc.add(field);\n    }\n    \n    numericConfigMap.put(DATE_FIELD_NAME, new LegacyNumericConfig(PRECISION_STEP,\n        DATE_FORMAT, LegacyNumericType.LONG));\n    FieldType ft = new FieldType(LegacyLongField.TYPE_NOT_STORED);\n    ft.setStored(true);\n    ft.setNumericPrecisionStep(PRECISION_STEP);\n    LegacyLongField dateField = new LegacyLongField(DATE_FIELD_NAME, 0l, ft);\n    numericFieldMap.put(DATE_FIELD_NAME, dateField);\n    doc.add(dateField);\n    \n    for (NumberType numberType : NumberType.values()) {\n      setFieldValues(numberType, numericFieldMap);\n      if (VERBOSE) System.out.println(\"Indexing document: \" + doc);\n      writer.addDocument(doc);\n    }\n    \n    reader = writer.getReader();\n    searcher = newSearcher(reader);\n    writer.close();\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"683242c67a3f6086bae8b1354748fcaa38edfbd5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["683242c67a3f6086bae8b1354748fcaa38edfbd5","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["403d05f7f8d69b65659157eff1bc1d2717f04c66","50b8410419cbbe9d8e1a96c918a951976bffe680"],"50b8410419cbbe9d8e1a96c918a951976bffe680":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["683242c67a3f6086bae8b1354748fcaa38edfbd5"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["683242c67a3f6086bae8b1354748fcaa38edfbd5","5af5ba0166322092193d4c29880b0f7670fc7ca0"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["403d05f7f8d69b65659157eff1bc1d2717f04c66","0c82557b0a8c9d4012f208e5de912ae7500ea351"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["683242c67a3f6086bae8b1354748fcaa38edfbd5","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"]},"commit2Childs":{"683242c67a3f6086bae8b1354748fcaa38edfbd5":["403d05f7f8d69b65659157eff1bc1d2717f04c66","5af5ba0166322092193d4c29880b0f7670fc7ca0","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["0c82557b0a8c9d4012f208e5de912ae7500ea351","50b8410419cbbe9d8e1a96c918a951976bffe680","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"0c82557b0a8c9d4012f208e5de912ae7500ea351":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"50b8410419cbbe9d8e1a96c918a951976bffe680":["0c82557b0a8c9d4012f208e5de912ae7500ea351"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["683242c67a3f6086bae8b1354748fcaa38edfbd5"],"5af5ba0166322092193d4c29880b0f7670fc7ca0":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}