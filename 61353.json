{"path":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","commits":[{"id":"7f2e96099703c24c0c63d27806ba7020626b649b","date":1385214372,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62b8732cb451168644d19e4d6e4fcf7b07bafc3d","date":1385219983,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","sourceNew":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","sourceOld":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf2ccf302186b563c9549824a4d45db1e8cf8a0d","date":1387322051,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","sourceNew":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    if (suggesterResults.size() == 1) {\n      return suggesterResults.get(0);\n    }\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","sourceOld":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","pathOld":"/dev/null","sourceNew":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    if (suggesterResults.size() == 1) {\n      return suggesterResults.get(0);\n    }\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"214b8610690edbe7e294594a7bc58a978ef1863c","date":1389376762,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","sourceNew":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    Set<String> suggesterNames = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      for (String suggesterName : shardResult.getSuggesterNames()) {\n        allTokens.addAll(shardResult.getTokens(suggesterName));\n        suggesterNames.add(suggesterName);\n      }\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String suggesterName : suggesterNames) {\n      for (String token : allTokens) {\n        Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n            count);\n        for (SuggesterResult shardResult : suggesterResults) {\n          List<LookupResult> suggests = shardResult.getLookupResult(suggesterName, token);\n          if (suggests == null) {\n            continue;\n          }\n          for (LookupResult res : suggests) {\n            resultQueue.insertWithOverflow(res);\n          }\n        }\n        List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n        Collections.addAll(sortedSuggests, resultQueue.getResults());\n        result.add(suggesterName, token, sortedSuggests);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    if (suggesterResults.size() == 1) {\n      return suggesterResults.get(0);\n    }\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      allTokens.addAll(shardResult.getTokens());\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String token : allTokens) {\n      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n          count);\n      for (SuggesterResult shardResult : suggesterResults) {\n        List<LookupResult> suggests = shardResult.getLookupResult(token);\n        if (suggests == null) {\n          continue;\n        }\n        for (LookupResult res : suggests) {\n          resultQueue.insertWithOverflow(res);\n        }\n      }\n      List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n      Collections.addAll(sortedSuggests, resultQueue.getResults());\n      result.add(token, sortedSuggests);\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/SuggestComponent#merge(List[SuggesterResult],int).mjava","sourceNew":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<>();\n    Set<String> suggesterNames = new HashSet<>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      for (String suggesterName : shardResult.getSuggesterNames()) {\n        allTokens.addAll(shardResult.getTokens(suggesterName));\n        suggesterNames.add(suggesterName);\n      }\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String suggesterName : suggesterNames) {\n      for (String token : allTokens) {\n        Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n            count);\n        for (SuggesterResult shardResult : suggesterResults) {\n          List<LookupResult> suggests = shardResult.getLookupResult(suggesterName, token);\n          if (suggests == null) {\n            continue;\n          }\n          for (LookupResult res : suggests) {\n            resultQueue.insertWithOverflow(res);\n          }\n        }\n        List<LookupResult> sortedSuggests = new LinkedList<>();\n        Collections.addAll(sortedSuggests, resultQueue.getResults());\n        result.add(suggesterName, token, sortedSuggests);\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  /** \n   * Given a list of {@link SuggesterResult} and <code>count</code>\n   * returns a {@link SuggesterResult} containing <code>count</code>\n   * number of {@link LookupResult}, sorted by their associated \n   * weights\n   * */\n  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {\n    SuggesterResult result = new SuggesterResult();\n    Set<String> allTokens = new HashSet<String>();\n    Set<String> suggesterNames = new HashSet<String>();\n    \n    // collect all tokens\n    for (SuggesterResult shardResult : suggesterResults) {\n      for (String suggesterName : shardResult.getSuggesterNames()) {\n        allTokens.addAll(shardResult.getTokens(suggesterName));\n        suggesterNames.add(suggesterName);\n      }\n    }\n    \n    // Get Top N for every token in every shard (using weights)\n    for (String suggesterName : suggesterNames) {\n      for (String token : allTokens) {\n        Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(\n            count);\n        for (SuggesterResult shardResult : suggesterResults) {\n          List<LookupResult> suggests = shardResult.getLookupResult(suggesterName, token);\n          if (suggests == null) {\n            continue;\n          }\n          for (LookupResult res : suggests) {\n            resultQueue.insertWithOverflow(res);\n          }\n        }\n        List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();\n        Collections.addAll(sortedSuggests, resultQueue.getResults());\n        result.add(suggesterName, token, sortedSuggests);\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["214b8610690edbe7e294594a7bc58a978ef1863c"],"62b8732cb451168644d19e4d6e4fcf7b07bafc3d":["7f2e96099703c24c0c63d27806ba7020626b649b"],"7f2e96099703c24c0c63d27806ba7020626b649b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"214b8610690edbe7e294594a7bc58a978ef1863c":["bf2ccf302186b563c9549824a4d45db1e8cf8a0d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","bf2ccf302186b563c9549824a4d45db1e8cf8a0d"],"bf2ccf302186b563c9549824a4d45db1e8cf8a0d":["62b8732cb451168644d19e4d6e4fcf7b07bafc3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"62b8732cb451168644d19e4d6e4fcf7b07bafc3d":["bf2ccf302186b563c9549824a4d45db1e8cf8a0d"],"7f2e96099703c24c0c63d27806ba7020626b649b":["62b8732cb451168644d19e4d6e4fcf7b07bafc3d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7f2e96099703c24c0c63d27806ba7020626b649b","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"214b8610690edbe7e294594a7bc58a978ef1863c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"bf2ccf302186b563c9549824a4d45db1e8cf8a0d":["214b8610690edbe7e294594a7bc58a978ef1863c","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}