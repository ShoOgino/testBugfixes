{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","commits":[{"id":"1e7090fb56105afb6515b6506724359c32ec7639","date":1521211434,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.LinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints = plane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints = plane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // No actual crossing\n        return true;\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      final GeoPoint[] crossingPoints = plane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (crossingPoints != null) {\n        // We need to handle the endpoint case, which is quite tricky.\n        for (final GeoPoint crossingPoint : crossingPoints) {\n          countCrossingPoint(crossingPoint, edge);\n        }\n      }\n      return true;\n    }\n\n","bugFix":null,"bugIntro":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"65d6841593942b33f59f72a2448d918225940311","date":1523319192,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // No actual crossing\n        return true;\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a","date":1523373040,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = computeCrossings(abovePlane, edge, bound1, bound2);\n      final GeoPoint[] belowCrossings = computeCrossings(belowPlane, edge, bound1, bound2);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = abovePlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      final GeoPoint[] belowCrossings = belowPlane.findCrossings(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d564e0296db7f80d73dd62b17710f61c85f38c50","date":1523483630,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      final GeoPoint[] aboveCrossings = computeCrossings(abovePlane, edge, bound1, bound2);\n      final GeoPoint[] belowCrossings = computeCrossings(belowPlane, edge, bound1, bound2);\n      \n      if (aboveCrossings != null) {\n        aboveCrossingCount += aboveCrossings.length;\n      }\n      if (belowCrossings != null) {\n        belowCrossingCount += belowCrossings.length;\n      }\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"affd6585e0a92f8483e2f9dd579c1927505c7377","date":1523947544,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);\n\n      return true;\n    }\n\n","bugFix":["7fe41964e49958f662028ea7ed8c224e0955edae"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040","date":1524832766,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.out.println(\" Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] potentially crosses travel plane \"+plane);\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        // The point is on the edge.  This means it's \"in-set\" by definition, so abort.\n        //System.out.println(\"  Point is on the edge; in-set\");\n        return false;\n      }\n      \n      //System.out.println(\"  Finding intersections between edge plane and travel plane...\");\n\n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings == null) {\n        //System.out.println(\"  Planes were identical\");\n      } else if (planeCrossings.length == 0) {\n        //System.out.println(\"  There are no intersection points within bounds.\");\n        /*\n        // For debugging purposes, let's repeat the intersection check without bounds, and figure out which bound(s) rejected it\n        final GeoPoint[] unboundedCrossings = plane.findIntersections(planetModel, edge.plane);\n        for (final GeoPoint crossing : unboundedCrossings) {\n          if (!bound1.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by bound1 (\"+((SidedPlane)bound1).evaluate(crossing)+\")\");\n          }\n          if (!bound2.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by bound2 (\"+((SidedPlane)bound2).evaluate(crossing)+\")\");\n          }\n          if (!edge.startPlane.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by edge.startPlane (\"+((SidedPlane)edge.startPlane).evaluate(crossing)+\")\");\n          }\n          if (!edge.endPlane.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by edge.endPlane (\"+((SidedPlane)edge.endPlane).evaluate(crossing)+\")\");\n          }\n        }\n        */\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          //System.out.println(\"   Endpoint(s) of edge are not on travel plane; distances: \"+plane.evaluate(edge.startPoint)+\" and \"+plane.evaluate(edge.endPoint));\n          // Edge doesn't actually intersect the travel plane.\n          return true;\n        } else {\n          //System.out.println(\"   Endpoint(s) of edge are on travel plane!\");\n        }\n      } else {\n        //System.out.println(\"  There were intersection points!\");\n      }\n      \n      //System.out.println(\" Edge intersects travel plane \"+plane);\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        return false;\n      }\n      \n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings != null && planeCrossings.length == 0) {\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          return true;\n        }\n      }\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);\n\n      return true;\n    }\n\n","bugFix":["8b879b14da40ab73551b75835099a61e622a83d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e456381ade0a256838cbf558702284e345c8d3d6","date":1524920804,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.SectorLinearCrossingEdgeIterator#matches(Edge).mjava","sourceNew":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.out.println(\" Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] potentially crosses travel plane \"+plane);\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        // The point is on the edge.  This means it's \"in-set\" by definition, so abort.\n        //System.out.println(\"  Point is on the edge; in-set\");\n        onEdge = true;\n        return false;\n      }\n      \n      //System.out.println(\"  Finding intersections between edge plane and travel plane...\");\n\n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings == null) {\n        //System.out.println(\"  Planes were identical\");\n      } else if (planeCrossings.length == 0) {\n        //System.out.println(\"  There are no intersection points within bounds.\");\n        /*\n        // For debugging purposes, let's repeat the intersection check without bounds, and figure out which bound(s) rejected it\n        final GeoPoint[] unboundedCrossings = plane.findIntersections(planetModel, edge.plane);\n        for (final GeoPoint crossing : unboundedCrossings) {\n          if (!bound1.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by bound1 (\"+((SidedPlane)bound1).evaluate(crossing)+\")\");\n          }\n          if (!bound2.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by bound2 (\"+((SidedPlane)bound2).evaluate(crossing)+\")\");\n          }\n          if (!edge.startPlane.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by edge.startPlane (\"+((SidedPlane)edge.startPlane).evaluate(crossing)+\")\");\n          }\n          if (!edge.endPlane.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by edge.endPlane (\"+((SidedPlane)edge.endPlane).evaluate(crossing)+\")\");\n          }\n        }\n        */\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          //System.out.println(\"   Endpoint(s) of edge are not on travel plane; distances: \"+plane.evaluate(edge.startPoint)+\" and \"+plane.evaluate(edge.endPoint));\n          // Edge doesn't actually intersect the travel plane.\n          return true;\n        } else {\n          //System.out.println(\"   Endpoint(s) of edge are on travel plane!\");\n        }\n      } else {\n        //System.out.println(\"  There were intersection points!\");\n      }\n      \n      //System.out.println(\"  Edge intersects travel plane\");\n\n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      //System.out.println(\"  Getting above crossings...\");\n      final int aboveCrossings = countCrossings(edge, abovePlane, bound1, bound2);\n      aboveCrossingCount += aboveCrossings;\n      //System.out.println(\"  Getting below crossings...\");\n      final int belowCrossings = countCrossings(edge, belowPlane, bound1, bound2);\n      belowCrossingCount += belowCrossings;\n      //System.out.println(\"  Above crossings = \"+aboveCrossings+\"; below crossings = \"+belowCrossings);\n\n      return true;\n    }\n\n","sourceOld":"    @Override\n    public boolean matches(final Edge edge) {\n      //System.out.println(\" Edge [\"+edge.startPoint+\" --> \"+edge.endPoint+\"] potentially crosses travel plane \"+plane);\n      // Early exit if the point is on the edge.\n      if (edge.isWithin(thePointX, thePointY, thePointZ)) {\n        // The point is on the edge.  This means it's \"in-set\" by definition, so abort.\n        //System.out.println(\"  Point is on the edge; in-set\");\n        return false;\n      }\n      \n      //System.out.println(\"  Finding intersections between edge plane and travel plane...\");\n\n      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.\n      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.\n      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound1, bound2, edge.startPlane, edge.endPlane);\n      if (planeCrossings == null) {\n        //System.out.println(\"  Planes were identical\");\n      } else if (planeCrossings.length == 0) {\n        //System.out.println(\"  There are no intersection points within bounds.\");\n        /*\n        // For debugging purposes, let's repeat the intersection check without bounds, and figure out which bound(s) rejected it\n        final GeoPoint[] unboundedCrossings = plane.findIntersections(planetModel, edge.plane);\n        for (final GeoPoint crossing : unboundedCrossings) {\n          if (!bound1.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by bound1 (\"+((SidedPlane)bound1).evaluate(crossing)+\")\");\n          }\n          if (!bound2.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by bound2 (\"+((SidedPlane)bound2).evaluate(crossing)+\")\");\n          }\n          if (!edge.startPlane.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by edge.startPlane (\"+((SidedPlane)edge.startPlane).evaluate(crossing)+\")\");\n          }\n          if (!edge.endPlane.isWithin(crossing)) {\n            System.out.println(\"   Crossing point \"+crossing+\" rejected by edge.endPlane (\"+((SidedPlane)edge.endPlane).evaluate(crossing)+\")\");\n          }\n        }\n        */\n        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.\n        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {\n          //System.out.println(\"   Endpoint(s) of edge are not on travel plane; distances: \"+plane.evaluate(edge.startPoint)+\" and \"+plane.evaluate(edge.endPoint));\n          // Edge doesn't actually intersect the travel plane.\n          return true;\n        } else {\n          //System.out.println(\"   Endpoint(s) of edge are on travel plane!\");\n        }\n      } else {\n        //System.out.println(\"  There were intersection points!\");\n      }\n      \n      //System.out.println(\" Edge intersects travel plane \"+plane);\n      \n      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.\n      aboveCrossingCount += countCrossings(edge, abovePlane, bound1, bound2);\n      belowCrossingCount += countCrossings(edge, belowPlane, bound1, bound2);\n\n      return true;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a":["65d6841593942b33f59f72a2448d918225940311"],"8b879b14da40ab73551b75835099a61e622a83d3":["1e7090fb56105afb6515b6506724359c32ec7639"],"1e7090fb56105afb6515b6506724359c32ec7639":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e456381ade0a256838cbf558702284e345c8d3d6":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"d564e0296db7f80d73dd62b17710f61c85f38c50":["1cf8d8275024d808d6f5e5a1a07e8fa2b010706a"],"65d6841593942b33f59f72a2448d918225940311":["8b879b14da40ab73551b75835099a61e622a83d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"affd6585e0a92f8483e2f9dd579c1927505c7377":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e456381ade0a256838cbf558702284e345c8d3d6"]},"commit2Childs":{"1cf8d8275024d808d6f5e5a1a07e8fa2b010706a":["d564e0296db7f80d73dd62b17710f61c85f38c50"],"8b879b14da40ab73551b75835099a61e622a83d3":["65d6841593942b33f59f72a2448d918225940311"],"1e7090fb56105afb6515b6506724359c32ec7639":["8b879b14da40ab73551b75835099a61e622a83d3"],"e456381ade0a256838cbf558702284e345c8d3d6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d564e0296db7f80d73dd62b17710f61c85f38c50":["affd6585e0a92f8483e2f9dd579c1927505c7377"],"65d6841593942b33f59f72a2448d918225940311":["1cf8d8275024d808d6f5e5a1a07e8fa2b010706a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1e7090fb56105afb6515b6506724359c32ec7639"],"d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040":["e456381ade0a256838cbf558702284e345c8d3d6"],"affd6585e0a92f8483e2f9dd579c1927505c7377":["d1ddb4f16cfdfa4f6fa9349fb90d48b0f1e6f040"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}