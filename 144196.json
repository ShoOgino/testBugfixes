{"path":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","commits":[{"id":"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3","date":1583932828,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,String,SolrConfig,IndexSchema,NamedList,CoreDescriptor,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   *\n   * @param dataDir the index directory\n   * @param config  a solr config instance\n   * @param schema  a solr schema instance\n   * @since solr 1.3\n   */\n  public SolrCore(CoreContainer coreContainer, String name, String dataDir, SolrConfig config,\n                  IndexSchema schema, NamedList configSetProperties,\n                  CoreDescriptor coreDescriptor, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      resourceLoader = config.getResourceLoader();\n      this.solrConfig = config;\n      this.configSetProperties = configSetProperties;\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(config);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, config, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, resourceLoader.getInstancePath(),\n          this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      initSchema(config, schema);\n\n      this.maxWarmingSearchers = config.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ed5005b977107bba28c700351216f1595e7abe4f","date":1585964712,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      MDCLoggingContext.setCore(this);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"140be51d03394488536f4aacedace29f9b318347","date":1587170432,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b73e9c1914a76cfa16576e9d7165e286cc35c36e","date":1593099382,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c24f8f07a3e4a885c0e19286d51575df197a611b","date":1593281672,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ef8e4fae9bcd156a117f5758819aeabdae3e963","date":1593674028,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2ed9b72e5fa27a7bd4857f222ca815341979d4a","date":1594879524,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n      IndexSchema schema = configSet.getIndexSchema();\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e80876f1ee57780ad756fa083e88c95d7c1d0c0b","date":1595653703,"type":5,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,CoreDescriptor,ConfigSet,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/SolrCore#SolrCore(CoreContainer,String,ConfigSet,CoreDescriptor,String,UpdateHandler,IndexDeletionPolicyWrapper,SolrCore,boolean).mjava","sourceNew":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, CoreDescriptor coreDescriptor, ConfigSet configSet,\n                   String dataDir, UpdateHandler updateHandler,\n                   IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    final CountDownLatch latch = new CountDownLatch(1);\n    try {\n      this.coreContainer = coreContainer;\n      this.coreDescriptor = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      setName(coreDescriptor.getName());\n\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","sourceOld":"  /**\n   * Creates a new core and register it in the list of cores. If a core with the\n   * same name already exists, it will be stopped and replaced by this one.\n   */\n  private SolrCore(CoreContainer coreContainer, String name, ConfigSet configSet, CoreDescriptor coreDescriptor,\n                  String dataDir, UpdateHandler updateHandler,\n                  IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {\n\n    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this\n\n    this.coreContainer = coreContainer;\n\n    final CountDownLatch latch = new CountDownLatch(1);\n\n    try {\n\n      CoreDescriptor cd = Objects.requireNonNull(coreDescriptor, \"coreDescriptor cannot be null\");\n      coreContainer.solrCores.addCoreDescriptor(cd);\n\n      setName(name);\n      this.solrConfig = configSet.getSolrConfig();\n      this.resourceLoader = configSet.getSolrConfig().getResourceLoader();\n      this.resourceLoader.core = this;\n      schemaPluginsLoader = new PackageListeningClassLoader(coreContainer, resourceLoader,\n              solrConfig::maxPackageVersion,\n              () -> setLatestSchema(configSet.getIndexSchema(true)));\n      this.packageListeners.addListener(schemaPluginsLoader);\n      IndexSchema schema = configSet.getIndexSchema();\n\n      this.configSetProperties = configSet.getProperties();\n      // Initialize the metrics manager\n      this.coreMetricManager = initCoreMetricManager(solrConfig);\n      this.circuitBreakerManager = initCircuitBreakerManager();\n      solrMetricsContext = coreMetricManager.getSolrMetricsContext();\n      this.coreMetricManager.loadReporters();\n\n      if (updateHandler == null) {\n        directoryFactory = initDirectoryFactory();\n        recoveryStrategyBuilder = initRecoveryStrategyBuilder();\n        solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);\n      } else {\n        solrCoreState = updateHandler.getSolrCoreState();\n        directoryFactory = solrCoreState.getDirectoryFactory();\n        recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();\n        isReloaded = true;\n      }\n\n      this.dataDir = initDataDir(dataDir, solrConfig, coreDescriptor);\n      this.ulogDir = initUpdateLogDir(coreDescriptor);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"[{}] Opening new SolrCore at [{}], dataDir=[{}]\", logid, getInstancePath(), this.dataDir);\n      }\n\n      checkVersionFieldExistsInSchema(schema, coreDescriptor);\n      setLatestSchema(schema);\n\n      // initialize core metrics\n      initializeMetrics(solrMetricsContext, null);\n\n      SolrFieldCacheBean solrFieldCacheBean = new SolrFieldCacheBean();\n      // this is registered at the CONTAINER level because it's not core-specific - for now we\n      // also register it here for back-compat\n      solrFieldCacheBean.initializeMetrics(solrMetricsContext, \"core\");\n      infoRegistry.put(\"fieldCache\", solrFieldCacheBean);\n\n      this.maxWarmingSearchers = solrConfig.maxWarmingSearchers;\n      this.slowQueryThresholdMillis = solrConfig.slowQueryThresholdMillis;\n\n      initListeners();\n\n      this.snapshotMgr = initSnapshotMetaDataManager();\n      this.solrDelPolicy = initDeletionPolicy(delPolicy);\n\n      this.codec = initCodec(solrConfig, this.schema);\n\n      memClassLoader = new MemClassLoader(\n          PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())),\n          getResourceLoader());\n      initIndex(prev != null, reload);\n\n      initWriters();\n      qParserPlugins.init(QParserPlugin.standardPlugins, this);\n      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);\n      transformerFactories.init(TransformerFactory.defaultFactories, this);\n      loadSearchComponents();\n      updateProcessors.init(Collections.emptyMap(), this);\n\n      // Processors initialized before the handlers\n      updateProcessorChains = loadUpdateProcessorChains();\n      reqHandlers = new RequestHandlers(this);\n      reqHandlers.initHandlersFromConfig(solrConfig);\n\n      // cause the executor to stall so firstSearcher events won't fire\n      // until after inform() has been called for all components.\n      // searchExecutor must be single-threaded for this to work\n      searcherExecutor.submit(() -> {\n        latch.await();\n        return null;\n      });\n\n      this.updateHandler = initUpdateHandler(updateHandler);\n\n      initSearcher(prev);\n\n      // Initialize the RestManager\n      restManager = initRestManager();\n\n      // at this point we can load jars loaded from remote urls.\n      memClassLoader.loadRemoteJars();\n\n      // Finally tell anyone who wants to know\n      resourceLoader.inform(resourceLoader);\n      resourceLoader.inform(this); // last call before the latch is released.\n      this.updateHandler.informEventListeners(this);\n\n      infoRegistry.put(\"core\", this);\n\n      // register any SolrInfoMBeans SolrResourceLoader initialized\n      //\n      // this must happen after the latch is released, because a JMX server impl may\n      // choose to block on registering until properties can be fetched from an MBean,\n      // and a SolrCoreAware MBean may have properties that depend on getting a Searcher\n      // from the core.\n      resourceLoader.inform(infoRegistry);\n\n      // Allow the directory factory to report metrics\n      if (directoryFactory instanceof SolrMetricProducer) {\n        ((SolrMetricProducer) directoryFactory).initializeMetrics(solrMetricsContext, \"directoryFactory\");\n      }\n\n      // seed version buckets with max from index during core initialization ... requires a searcher!\n      seedVersionBuckets();\n\n      bufferUpdatesIfConstructing(coreDescriptor);\n\n      this.ruleExpiryLock = new ReentrantLock();\n      this.snapshotDelLock = new ReentrantLock();\n\n      registerConfListener();\n\n    } catch (Throwable e) {\n      // release the latch, otherwise we block trying to do the close. This\n      // should be fine, since counting down on a latch of 0 is still fine\n      latch.countDown();\n      if (e instanceof OutOfMemoryError) {\n        throw (OutOfMemoryError) e;\n      }\n\n      try {\n        // close down the searcher and any other resources, if it exists, as this\n        // is not recoverable\n        close();\n      } catch (Throwable t) {\n        if (t instanceof OutOfMemoryError) {\n          throw (OutOfMemoryError) t;\n        }\n        log.error(\"Error while closing\", t);\n      }\n\n      throw new SolrException(ErrorCode.SERVER_ERROR, e.getMessage(), e);\n    } finally {\n      // allow firstSearcher events to fire and make sure it is released\n      latch.countDown();\n    }\n\n    assert ObjectReleaseTracker.track(this);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c24f8f07a3e4a885c0e19286d51575df197a611b":["b73e9c1914a76cfa16576e9d7165e286cc35c36e"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["8ef8e4fae9bcd156a117f5758819aeabdae3e963"],"140be51d03394488536f4aacedace29f9b318347":["ed5005b977107bba28c700351216f1595e7abe4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ed5005b977107bba28c700351216f1595e7abe4f":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"b73e9c1914a76cfa16576e9d7165e286cc35c36e":["140be51d03394488536f4aacedace29f9b318347"],"8ef8e4fae9bcd156a117f5758819aeabdae3e963":["c24f8f07a3e4a885c0e19286d51575df197a611b"],"e80876f1ee57780ad756fa083e88c95d7c1d0c0b":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e80876f1ee57780ad756fa083e88c95d7c1d0c0b"]},"commit2Childs":{"c24f8f07a3e4a885c0e19286d51575df197a611b":["8ef8e4fae9bcd156a117f5758819aeabdae3e963"],"ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3":["ed5005b977107bba28c700351216f1595e7abe4f"],"b2ed9b72e5fa27a7bd4857f222ca815341979d4a":["e80876f1ee57780ad756fa083e88c95d7c1d0c0b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ec5a4e4c455009870c1cb8d21cf6671b8b78d3e3"],"140be51d03394488536f4aacedace29f9b318347":["b73e9c1914a76cfa16576e9d7165e286cc35c36e"],"ed5005b977107bba28c700351216f1595e7abe4f":["140be51d03394488536f4aacedace29f9b318347"],"b73e9c1914a76cfa16576e9d7165e286cc35c36e":["c24f8f07a3e4a885c0e19286d51575df197a611b"],"8ef8e4fae9bcd156a117f5758819aeabdae3e963":["b2ed9b72e5fa27a7bd4857f222ca815341979d4a"],"e80876f1ee57780ad756fa083e88c95d7c1d0c0b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}