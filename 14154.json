{"path":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","commits":[{"id":"fb8457dd0880f5547d70dbf40ea4f1c5e7787798","date":1363378339,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","pathOld":"/dev/null","sourceNew":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    for(CategoryPath cp : paths) {\n      doc.add(new SortedSetDocValuesFacetField(fip, cp));\n    }\n\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"b\", \"baz\")));\n    // Make sure it's fine to use delim in the label (it's\n    // just not allowed in the dim):\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"b\", \"baz\" + delim + \"foo\")));\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\")));\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(fsp, state));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 2 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n  baz\" + delim + \"foo (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2","date":1363472247,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","sourceNew":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(fsp, state));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    for(CategoryPath cp : paths) {\n      doc.add(new SortedSetDocValuesFacetField(fip, cp));\n    }\n\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"b\", \"baz\")));\n    // Make sure it's fine to use delim in the label (it's\n    // just not allowed in the dim):\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"b\", \"baz\" + delim + \"foo\")));\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\")));\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    doc.add(new SortedSetDocValuesFacetField(fip, new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(fsp, state));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 2 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n  baz\" + delim + \"foo (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","date":1375103250,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","sourceNew":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(fsp, state));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","sourceNew":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(fsp, state));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","sourceNew":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<FacetLabel> paths = new ArrayList<FacetLabel>();\n    paths.add(new FacetLabel(\"a\", \"foo\"));\n    paths.add(new FacetLabel(\"a\", \"bar\"));\n    paths.add(new FacetLabel(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new FacetLabel(\"b\", \"baz\"));\n    paths.add(new FacetLabel(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new FacetLabel(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new FacetLabel(\"a\"), 10));\n    requests.add(new CountFacetRequest(new FacetLabel(\"b\"), 10));\n    requests.add(new CountFacetRequest(new FacetLabel(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new FacetLabel(\"a\", \"foo\"));\n    q.add(new FacetLabel(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new FacetLabel(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ae75def1e2525383b6e1397ed97c44387da9941c","date":1385249238,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","sourceNew":null,"sourceOld":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<FacetLabel> paths = new ArrayList<FacetLabel>();\n    paths.add(new FacetLabel(\"a\", \"foo\"));\n    paths.add(new FacetLabel(\"a\", \"bar\"));\n    paths.add(new FacetLabel(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new FacetLabel(\"b\", \"baz\"));\n    paths.add(new FacetLabel(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new FacetLabel(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new FacetLabel(\"a\"), 10));\n    requests.add(new CountFacetRequest(new FacetLabel(\"b\"), 10));\n    requests.add(new CountFacetRequest(new FacetLabel(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new FacetLabel(\"a\", \"foo\"));\n    q.add(new FacetLabel(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new FacetLabel(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/test/org/apache/lucene/facet/sortedset/TestSortedSetDocValuesFacets#testSortedSetDocValuesAccumulator().mjava","sourceNew":null,"sourceOld":"  public void testSortedSetDocValuesAccumulator() throws Exception {\n    assumeTrue(\"Test requires SortedSetDV support\", defaultCodecSupportsSortedSet());\n    Directory dir = newDirectory();\n    RandomIndexWriter writer = new RandomIndexWriter(random(), dir);\n\n    // Use a custom delim char to make sure the impls\n    // respect it:\n    final char delim = ':';\n    FacetIndexingParams fip = new FacetIndexingParams() {\n        @Override\n        public char getFacetDelimChar() {\n          return delim;\n        }\n      };\n\n    SortedSetDocValuesFacetFields dvFields = new SortedSetDocValuesFacetFields(fip);\n\n    Document doc = new Document();\n    // Mixup order we add these paths, to verify tie-break\n    // order is by label (unicode sort) and has nothing to\n    // do w/ order we added them:\n    List<CategoryPath> paths = new ArrayList<CategoryPath>();\n    paths.add(new CategoryPath(\"a\", \"foo\"));\n    paths.add(new CategoryPath(\"a\", \"bar\"));\n    paths.add(new CategoryPath(\"a\", \"zoo\"));\n    Collections.shuffle(paths, random());\n\n    paths.add(new CategoryPath(\"b\", \"baz\"));\n    paths.add(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR, \"bazfoo\"));\n\n    dvFields.addFields(doc, paths);\n\n    writer.addDocument(doc);\n    if (random().nextBoolean()) {\n      writer.commit();\n    }\n\n    doc = new Document();\n    dvFields.addFields(doc, Collections.singletonList(new CategoryPath(\"a\", \"foo\")));\n    writer.addDocument(doc);\n\n    // NRT open\n    IndexSearcher searcher = newSearcher(writer.getReader());\n    writer.close();\n\n    List<FacetRequest> requests = new ArrayList<FacetRequest>();\n    requests.add(new CountFacetRequest(new CategoryPath(\"a\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\"), 10));\n    requests.add(new CountFacetRequest(new CategoryPath(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR), 10));\n\n    final boolean doDimCount = random().nextBoolean();\n\n    CategoryListParams clp = new CategoryListParams() {\n        @Override\n        public OrdinalPolicy getOrdinalPolicy(String dimension) {\n          return doDimCount ? OrdinalPolicy.NO_PARENTS : OrdinalPolicy.ALL_BUT_DIMENSION;\n        }\n      };\n\n    FacetSearchParams fsp = new FacetSearchParams(new FacetIndexingParams(clp), requests);\n\n    // Per-top-reader state:\n    SortedSetDocValuesReaderState state = new SortedSetDocValuesReaderState(fip, searcher.getIndexReader());\n    \n    //SortedSetDocValuesCollector c = new SortedSetDocValuesCollector(state);\n    //SortedSetDocValuesCollectorMergeBySeg c = new SortedSetDocValuesCollectorMergeBySeg(state);\n\n    FacetsCollector c = FacetsCollector.create(new SortedSetDocValuesAccumulator(state, fsp));\n\n    searcher.search(new MatchAllDocsQuery(), c);\n\n    //List<FacetResult> results = c.getFacetResults(requests);\n    List<FacetResult> results = c.getFacetResults();\n\n    assertEquals(3, results.size());\n\n    int dimCount = doDimCount ? 4 : 0;\n    assertEquals(\"a (\" + dimCount + \")\\n  foo (2)\\n  bar (1)\\n  zoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(0)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b (\" + dimCount + \")\\n  baz (1)\\n\", FacetTestUtils.toSimpleString(results.get(1)));\n\n    dimCount = doDimCount ? 1 : 0;\n    assertEquals(\"b\" + FacetIndexingParams.DEFAULT_FACET_DELIM_CHAR + \" (\" + dimCount + \")\\n  bazfoo (1)\\n\", FacetTestUtils.toSimpleString(results.get(2)));\n\n    // DrillDown:\n\n    DrillDownQuery q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\", \"foo\"));\n    q.add(new CategoryPath(\"b\", \"baz\"));\n    TopDocs hits = searcher.search(q, 1);\n    assertEquals(1, hits.totalHits);\n\n    q = new DrillDownQuery(fip);\n    q.add(new CategoryPath(\"a\"));\n    hits = searcher.search(q, 1);\n    assertEquals(2, hits.totalHits);\n\n    searcher.getIndexReader().close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49","ae75def1e2525383b6e1397ed97c44387da9941c"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"ae75def1e2525383b6e1397ed97c44387da9941c":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fb8457dd0880f5547d70dbf40ea4f1c5e7787798"],"7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fb8457dd0880f5547d70dbf40ea4f1c5e7787798":["7f85b5d5a4e2cc786a3a3e9539c4ed8136a7f5e2"],"6249cba93d7ad1bf6f5a225c34fbe3d547ed9f49":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"ae75def1e2525383b6e1397ed97c44387da9941c":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["ae75def1e2525383b6e1397ed97c44387da9941c"]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}