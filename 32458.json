{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","commits":[{"id":"4356000e349e38c9fb48034695b7c309abd54557","date":1337460341,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    try {\n      // nocommit what IOCtx to use...\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, new IOContext(new FlushInfo(totalDocCount(), 0))));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // nocommit hacky!\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            write3xInfo(si);\n            // nocommit do this after, on success...\n            //si.setVersion(\"4.0\");\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        // nocommit must also remove any written .si files...\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory, Codec codec) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    \n\n    boolean success = false;\n\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      segnOutput = infosWriter.writeInfos(directory, segmentFileName, codec.getName(), this, IOContext.DEFAULT);\n      infosWriter.prepareCommit(segnOutput);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"352763be0465236f8e2ac188aa1b761cb3e1c9ee","date":1337516554,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    try {\n      // nocommit what IOCtx to use...\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, new IOContext(new FlushInfo(totalDocCount(), 0))));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // nocommit hacky!\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            write3xInfo(si);\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        // nocommit must also remove any written .si files...\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    try {\n      // nocommit what IOCtx to use...\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, new IOContext(new FlushInfo(totalDocCount(), 0))));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // nocommit hacky!\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            write3xInfo(si);\n            // nocommit do this after, on success...\n            //si.setVersion(\"4.0\");\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        // nocommit must also remove any written .si files...\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b2af6b2c05418fb9df466c739ed5b3a153eadde","date":1337520269,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    try {\n      // nocommit what IOCtx to use...\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, new IOContext(new FlushInfo(totalDocCount(), 0))));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // nocommit hacky!\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            write3xInfo(si);\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.prepareCommit();\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        // nocommit must also remove any written .si files...\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1494abe5dc85557ec2e2772f87660d48f831c3a5","date":1337614370,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            //System.out.println(\"write 3x info seg=\" + si.name + \" version=\" + si.getVersion() + \" codec=\" + si.getCodec().getName());\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a46feaa8775cb79964b568371b8eedaef5f576b","date":1337620767,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n            si.clearFilesCache();\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ace9b78896617dcee984890f3300d45c539c1b15","date":1337655022,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere that we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere taht we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      Codec codec3X = Codec.forName(\"Lucene3x\");\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfosFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere that we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.docCount;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere that we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfo si : this) {\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(si.getDelGen());\n        segnOutput.writeInt(si.getDelCount());\n        assert si.dir == directory;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f4ac68b353fb5616cfc6067741970000e8ee39a5"],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"72075e55f96fefa443288356377c83e70d94cbd2","date":1337721157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.docCount;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    // nocommit document somewhere that we store this\n    // list-of-segs plus delGen plus other stuff\n    // \"generically\" and then codec gets to write SI\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.docCount;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"203d7d3cb7712e10ef33009a63247ae40c302d7a","date":1337798111,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.docCount;\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f4ac68b353fb5616cfc6067741970000e8ee39a5"],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d71ab2bff76807be0f283d5a8819ca4af4e7ca46","date":1337862203,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || StringHelper.getVersionComparator().compare(version, \"4.0\") < 0) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || version.startsWith(\"3.\")) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee3df95012e016c229172f87a6c4077957246c4a","date":1337867023,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || StringHelper.getVersionComparator().compare(version, \"4.0\") < 0) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || StringHelper.getVersionComparator().compare(version, \"4.0\") < 0) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":1,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory,Codec).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || StringHelper.getVersionComparator().compare(version, \"4.0\") < 0) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory, Codec codec) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    \n\n    boolean success = false;\n\n    try {\n      SegmentInfosWriter infosWriter = codec.segmentInfosFormat().getSegmentInfosWriter();\n      segnOutput = infosWriter.writeInfos(directory, segmentFileName, codec.getName(), this, IOContext.DEFAULT);\n      infosWriter.prepareCommit(segnOutput);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    final Set<String> upgradedSIFiles = new HashSet<String>();\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n\n        // If this segment is pre-4.x, perform a one-time\n        // \"ugprade\" to write the .si file for it:\n        String version = si.getVersion();\n        if (version == null || StringHelper.getVersionComparator().compare(version, \"4.0\") < 0) {\n          String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION);\n          if (!directory.fileExists(fileName)) {\n            upgradedSIFiles.add(write3xInfo(directory, si, IOContext.DEFAULT));\n          }\n        }\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        for(String fileName : upgradedSIFiles) {\n          try {\n            directory.deleteFile(fileName);\n          } catch (Throwable t) {\n            // Suppress so we keep throwing the original exception\n          }\n        }\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e072d0b1fc19e0533d8ce432eed245196bca6fde","date":1379265112,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_45);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        Map<Integer,Long> docValuesUpdatesGen = siPerCommit.getFieldDocValuesGens();\n        segnOutput.writeInt(docValuesUpdatesGen.size());\n        for (Entry<Integer,Long> e : docValuesUpdatesGen.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeLong(e.getValue());\n        }\n        segnOutput.writeStringSet(siPerCommit.getUpdatesFiles());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_40);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8435160e9702b19398118ddf76b61c846612b6a4","date":1380349140,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeStringSet(siPerCommit.getUpdatesFiles());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_45);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        Map<Integer,Long> docValuesUpdatesGen = siPerCommit.getFieldDocValuesGens();\n        segnOutput.writeInt(docValuesUpdatesGen.size());\n        for (Entry<Integer,Long> e : docValuesUpdatesGen.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeLong(e.getValue());\n        }\n        segnOutput.writeStringSet(siPerCommit.getUpdatesFiles());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2f13fb377f9b5df46af44bf90a2e507a884f2c30","date":1380476222,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeStringSet(siPerCommit.getUpdatesFiles());\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0567bdc5c86c94ced64201187cfcef2417d76dda"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentInfoPerCommit siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f3b037cd083286b2af89f96e768f85dcd8072d6","date":1396337805,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0567bdc5c86c94ced64201187cfcef2417d76dda"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    ChecksumIndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = new ChecksumIndexOutput(directory.createOutput(segmentFileName, IOContext.DEFAULT));\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_46);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4ac68b353fb5616cfc6067741970000e8ee39a5","date":1397826520,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        segnOutput.writeInt(siPerCommit.getDelCount());\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n\n        assert siPerCommit.getDelCount() <= si.getDocCount();\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":["203d7d3cb7712e10ef33009a63247ae40c302d7a","4356000e349e38c9fb48034695b7c309abd54557","9d153abcf92dc5329d98571a8c3035df9bd80648"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0567bdc5c86c94ced64201187cfcef2417d76dda","date":1400678298,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_49);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":["1f3b037cd083286b2af89f96e768f85dcd8072d6","2f13fb377f9b5df46af44bf90a2e507a884f2c30"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a656b32c3aa151037a8c52e9b134acc3cbf482bc","date":1400688195,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_49);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_49);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_48);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        final Map<Long,Set<String>> genUpdatesFiles = siPerCommit.getUpdatesFiles();\n        segnOutput.writeInt(genUpdatesFiles.size());\n        for (Entry<Long,Set<String>> e : genUpdatesFiles.entrySet()) {\n          segnOutput.writeLong(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3cc329405ce41b8ef462b4cd30611eca1567620","date":1408661910,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_410);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_49);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f35160e92057203e23664ebd12f99390d92cb62","date":1408662280,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_410);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["5f6bd27530a2846413fe2d00030493c0e2d3a072"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13","date":1409346855,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n\n        try {\n          // Try not to leave a truncated segments_N file in\n          // the index:\n          directory.deleteFile(segmentFileName);\n        } catch (Throwable t) {\n          // Suppress so we keep throwing the original exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46e4a8bdfbafda795ef9c39a2bc2d47095770299","date":1410411846,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      pendingSegnOutput = segnOutput;\n      success = true;\n    } finally {\n      if (!success) {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","date":1411708843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_50);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      byte[] id = StringHelper.randomId();\n      segnOutput.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6bd27530a2846413fe2d00030493c0e2d3a072","date":1411811855,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_50);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      byte[] id = StringHelper.randomId();\n      segnOutput.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_411);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      segnOutput.writeString(StringHelper.randomId());\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":["4f35160e92057203e23664ebd12f99390d92cb62","e3cc329405ce41b8ef462b4cd30611eca1567620"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3384e6013a93e4d11b7d75388693f8d0388602bf","date":1413951663,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_50, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_50);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      byte[] id = StringHelper.randomId();\n      segnOutput.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["8f3189d15ef66702bbb45771403a68793d5cd137"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db68c63cbfaa8698b9c4475f75ed2b9c9696d238","date":1414118621,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_50, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    String segmentFileName = getNextPendingSegmentFileName();\n    \n    // Always advance the generation on write:\n    if (generation == -1) {\n      generation = 1;\n    } else {\n      generation++;\n    }\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeHeader(segnOutput, \"segments\", VERSION_50);\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      byte[] id = StringHelper.randomId();\n      segnOutput.writeBytes(id, 0, id.length);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"79700663e164dece87bed4adfd3e28bab6cb1385","date":1425241849,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_50, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"299a2348fa24151d150182211b6208a38e5e3450","date":1425304608,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_50, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0267c69e2456a3477a1ad785723f2135da3117e","date":1425317087,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b06445ae1731e049327712db0454e5643ca9b7fe","date":1425329139,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_50, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.getDocCount()) {\n          throw new IllegalStateException(\"cannot write segment: invalid docCount segment=\" + si.name + \" docCount=\" + si.getDocCount() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeStringSet(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeStringSet(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeStringStringMap(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n        assert si.dir == directory;\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f3189d15ef66702bbb45771403a68793d5cd137","date":1433872507,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                 StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeVInt(Version.LATEST.major);\n      segnOutput.writeVInt(Version.LATEST.minor);\n      segnOutput.writeVInt(Version.LATEST.bugfix);\n\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size());\n\n      if (size() > 0) {\n\n        Version minSegmentVersion = null;\n\n        // We do a separate loop up front so we can write the minSegmentVersion before\n        // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n        for (SegmentCommitInfo siPerCommit : this) {\n          Version segmentVersion = siPerCommit.info.getVersion();\n          if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n            minSegmentVersion = segmentVersion;\n          }\n        }\n\n        segnOutput.writeVInt(minSegmentVersion.major);\n        segnOutput.writeVInt(minSegmentVersion.minor);\n        segnOutput.writeVInt(minSegmentVersion.bugfix);\n      }\n\n      // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                   StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size()); // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":["3384e6013a93e4d11b7d75388693f8d0388602bf","4356000e349e38c9fb48034695b7c309abd54557"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d49a158012a8ff48f328a4558e4bfcffbaed16f","date":1453677440,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                 StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeVInt(Version.LATEST.major);\n      segnOutput.writeVInt(Version.LATEST.minor);\n      segnOutput.writeVInt(Version.LATEST.bugfix);\n\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size());\n\n      if (size() > 0) {\n\n        Version minSegmentVersion = null;\n\n        // We do a separate loop up front so we can write the minSegmentVersion before\n        // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n        for (SegmentCommitInfo siPerCommit : this) {\n          Version segmentVersion = siPerCommit.info.getVersion();\n          if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n            minSegmentVersion = segmentVersion;\n          }\n        }\n\n        segnOutput.writeVInt(minSegmentVersion.major);\n        segnOutput.writeVInt(minSegmentVersion.minor);\n        segnOutput.writeVInt(minSegmentVersion.bugfix);\n      }\n\n      // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      CodecUtil.writeIndexHeader(segnOutput, \"segments\", VERSION_CURRENT, \n                                 StringHelper.randomId(), Long.toString(nextGeneration, Character.MAX_RADIX));\n      segnOutput.writeVInt(Version.LATEST.major);\n      segnOutput.writeVInt(Version.LATEST.minor);\n      segnOutput.writeVInt(Version.LATEST.bugfix);\n\n      segnOutput.writeLong(version); \n      segnOutput.writeInt(counter); // write counter\n      segnOutput.writeInt(size());\n\n      if (size() > 0) {\n\n        Version minSegmentVersion = null;\n\n        // We do a separate loop up front so we can write the minSegmentVersion before\n        // any SegmentInfo; this makes it cleaner to throw IndexFormatTooOldExc at read time:\n        for (SegmentCommitInfo siPerCommit : this) {\n          Version segmentVersion = siPerCommit.info.getVersion();\n          if (minSegmentVersion == null || segmentVersion.onOrAfter(minSegmentVersion) == false) {\n            minSegmentVersion = segmentVersion;\n          }\n        }\n\n        segnOutput.writeVInt(minSegmentVersion.major);\n        segnOutput.writeVInt(minSegmentVersion.minor);\n        segnOutput.writeVInt(minSegmentVersion.bugfix);\n      }\n\n      // write infos\n      for (SegmentCommitInfo siPerCommit : this) {\n        SegmentInfo si = siPerCommit.info;\n        segnOutput.writeString(si.name);\n        byte segmentID[] = si.getId();\n        // TODO: remove this in lucene 6, we don't need to include 4.x segments in commits anymore\n        if (segmentID == null) {\n          segnOutput.writeByte((byte)0);\n        } else {\n          if (segmentID.length != StringHelper.ID_LENGTH) {\n            throw new IllegalStateException(\"cannot write segment: invalid id segment=\" + si.name + \"id=\" + StringHelper.idToString(segmentID));\n          }\n          segnOutput.writeByte((byte)1);\n          segnOutput.writeBytes(segmentID, segmentID.length);\n        }\n        segnOutput.writeString(si.getCodec().getName());\n        segnOutput.writeLong(siPerCommit.getDelGen());\n        int delCount = siPerCommit.getDelCount();\n        if (delCount < 0 || delCount > si.maxDoc()) {\n          throw new IllegalStateException(\"cannot write segment: invalid maxDoc segment=\" + si.name + \" maxDoc=\" + si.maxDoc() + \" delCount=\" + delCount);\n        }\n        segnOutput.writeInt(delCount);\n        segnOutput.writeLong(siPerCommit.getFieldInfosGen());\n        segnOutput.writeLong(siPerCommit.getDocValuesGen());\n        segnOutput.writeSetOfStrings(siPerCommit.getFieldInfosFiles());\n        final Map<Integer,Set<String>> dvUpdatesFiles = siPerCommit.getDocValuesUpdatesFiles();\n        segnOutput.writeInt(dvUpdatesFiles.size());\n        for (Entry<Integer,Set<String>> e : dvUpdatesFiles.entrySet()) {\n          segnOutput.writeInt(e.getKey());\n          segnOutput.writeSetOfStrings(e.getValue());\n        }\n      }\n      segnOutput.writeMapOfStrings(userData);\n      CodecUtil.writeFooter(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71e1a70f18d64b93db3ef618e606d6df5062f747","date":1466156390,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n\n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":["4356000e349e38c9fb48034695b7c309abd54557"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n\n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n    \n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14654be3f7a82c9a3c52169e365baa55bfe64f66","date":1587212697,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentInfos#write(Directory).mjava","sourceNew":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n\n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","sourceOld":"  private void write(Directory directory) throws IOException {\n\n    long nextGeneration = getNextPendingGeneration();\n    String segmentFileName = IndexFileNames.fileNameFromGeneration(IndexFileNames.PENDING_SEGMENTS,\n                                                                   \"\",\n                                                                   nextGeneration);\n\n    // Always advance the generation on write:\n    generation = nextGeneration;\n    \n    IndexOutput segnOutput = null;\n    boolean success = false;\n\n    try {\n      segnOutput = directory.createOutput(segmentFileName, IOContext.DEFAULT);\n      write(directory, segnOutput);\n      segnOutput.close();\n      directory.sync(Collections.singleton(segmentFileName));\n      success = true;\n    } finally {\n      if (success) {\n        pendingCommit = true;\n      } else {\n        // We hit an exception above; try to close the file\n        // but suppress any exception:\n        IOUtils.closeWhileHandlingException(segnOutput);\n        // Try not to leave a truncated segments_N file in\n        // the index:\n        IOUtils.deleteFilesIgnoringExceptions(directory, segmentFileName);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1f3b037cd083286b2af89f96e768f85dcd8072d6":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["2f13fb377f9b5df46af44bf90a2e507a884f2c30"],"9a46feaa8775cb79964b568371b8eedaef5f576b":["1494abe5dc85557ec2e2772f87660d48f831c3a5"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["46e4a8bdfbafda795ef9c39a2bc2d47095770299","a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["4f35160e92057203e23664ebd12f99390d92cb62"],"b7605579001505896d48b07160075a5c8b8e128e":["f4ac68b353fb5616cfc6067741970000e8ee39a5","0567bdc5c86c94ced64201187cfcef2417d76dda"],"8f3189d15ef66702bbb45771403a68793d5cd137":["618635065f043788c9e034f96ca5cd5cea1b4592"],"4f35160e92057203e23664ebd12f99390d92cb62":["e3cc329405ce41b8ef462b4cd30611eca1567620"],"1494abe5dc85557ec2e2772f87660d48f831c3a5":["9b2af6b2c05418fb9df466c739ed5b3a153eadde"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","b0267c69e2456a3477a1ad785723f2135da3117e"],"4356000e349e38c9fb48034695b7c309abd54557":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b06445ae1731e049327712db0454e5643ca9b7fe":["299a2348fa24151d150182211b6208a38e5e3450","b0267c69e2456a3477a1ad785723f2135da3117e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"79700663e164dece87bed4adfd3e28bab6cb1385":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"72075e55f96fefa443288356377c83e70d94cbd2":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"f4ac68b353fb5616cfc6067741970000e8ee39a5":["1f3b037cd083286b2af89f96e768f85dcd8072d6"],"68496c2200e559fb7802f7575427b7a482659afb":["8f3189d15ef66702bbb45771403a68793d5cd137","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"ace9b78896617dcee984890f3300d45c539c1b15":["9a46feaa8775cb79964b568371b8eedaef5f576b"],"299a2348fa24151d150182211b6208a38e5e3450":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238","79700663e164dece87bed4adfd3e28bab6cb1385"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["72075e55f96fefa443288356377c83e70d94cbd2"],"e072d0b1fc19e0533d8ce432eed245196bca6fde":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"ee3df95012e016c229172f87a6c4077957246c4a":["d71ab2bff76807be0f283d5a8819ca4af4e7ca46"],"5eb2511ababf862ea11e10761c70ee560cd84510":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","1f3b037cd083286b2af89f96e768f85dcd8072d6"],"71e1a70f18d64b93db3ef618e606d6df5062f747":["68496c2200e559fb7802f7575427b7a482659afb"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["4356000e349e38c9fb48034695b7c309abd54557"],"b0267c69e2456a3477a1ad785723f2135da3117e":["79700663e164dece87bed4adfd3e28bab6cb1385"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["ace9b78896617dcee984890f3300d45c539c1b15"],"0567bdc5c86c94ced64201187cfcef2417d76dda":["f4ac68b353fb5616cfc6067741970000e8ee39a5"],"8435160e9702b19398118ddf76b61c846612b6a4":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"9b2af6b2c05418fb9df466c739ed5b3a153eadde":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503"],"2f13fb377f9b5df46af44bf90a2e507a884f2c30":["8435160e9702b19398118ddf76b61c846612b6a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["68496c2200e559fb7802f7575427b7a482659afb","71e1a70f18d64b93db3ef618e606d6df5062f747"],"618635065f043788c9e034f96ca5cd5cea1b4592":["b0267c69e2456a3477a1ad785723f2135da3117e"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ee3df95012e016c229172f87a6c4077957246c4a"],"e3cc329405ce41b8ef462b4cd30611eca1567620":["0567bdc5c86c94ced64201187cfcef2417d76dda"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["71e1a70f18d64b93db3ef618e606d6df5062f747"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":["f4ac68b353fb5616cfc6067741970000e8ee39a5","0567bdc5c86c94ced64201187cfcef2417d76dda"],"d71ab2bff76807be0f283d5a8819ca4af4e7ca46":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["5f6bd27530a2846413fe2d00030493c0e2d3a072","3384e6013a93e4d11b7d75388693f8d0388602bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["14654be3f7a82c9a3c52169e365baa55bfe64f66"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["8f3189d15ef66702bbb45771403a68793d5cd137"]},"commit2Childs":{"1f3b037cd083286b2af89f96e768f85dcd8072d6":["f4ac68b353fb5616cfc6067741970000e8ee39a5","5eb2511ababf862ea11e10761c70ee560cd84510"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["1f3b037cd083286b2af89f96e768f85dcd8072d6","5eb2511ababf862ea11e10761c70ee560cd84510"],"9a46feaa8775cb79964b568371b8eedaef5f576b":["ace9b78896617dcee984890f3300d45c539c1b15"],"a5d957b3a23cce91c77a2c9971ecf0c9f99dd503":["5f6bd27530a2846413fe2d00030493c0e2d3a072","3384e6013a93e4d11b7d75388693f8d0388602bf"],"5f6bd27530a2846413fe2d00030493c0e2d3a072":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"98d2deb8c96c79ebef084a1f8e5a1a6c08608f13":["46e4a8bdfbafda795ef9c39a2bc2d47095770299"],"b7605579001505896d48b07160075a5c8b8e128e":[],"4f35160e92057203e23664ebd12f99390d92cb62":["98d2deb8c96c79ebef084a1f8e5a1a6c08608f13"],"8f3189d15ef66702bbb45771403a68793d5cd137":["68496c2200e559fb7802f7575427b7a482659afb","0d49a158012a8ff48f328a4558e4bfcffbaed16f"],"1494abe5dc85557ec2e2772f87660d48f831c3a5":["9a46feaa8775cb79964b568371b8eedaef5f576b"],"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["e072d0b1fc19e0533d8ce432eed245196bca6fde"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4356000e349e38c9fb48034695b7c309abd54557":["352763be0465236f8e2ac188aa1b761cb3e1c9ee"],"b06445ae1731e049327712db0454e5643ca9b7fe":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4356000e349e38c9fb48034695b7c309abd54557","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"79700663e164dece87bed4adfd3e28bab6cb1385":["299a2348fa24151d150182211b6208a38e5e3450","b0267c69e2456a3477a1ad785723f2135da3117e"],"72075e55f96fefa443288356377c83e70d94cbd2":["203d7d3cb7712e10ef33009a63247ae40c302d7a"],"f4ac68b353fb5616cfc6067741970000e8ee39a5":["b7605579001505896d48b07160075a5c8b8e128e","0567bdc5c86c94ced64201187cfcef2417d76dda","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"68496c2200e559fb7802f7575427b7a482659afb":["71e1a70f18d64b93db3ef618e606d6df5062f747","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"299a2348fa24151d150182211b6208a38e5e3450":["b06445ae1731e049327712db0454e5643ca9b7fe"],"ace9b78896617dcee984890f3300d45c539c1b15":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"203d7d3cb7712e10ef33009a63247ae40c302d7a":["d71ab2bff76807be0f283d5a8819ca4af4e7ca46"],"e072d0b1fc19e0533d8ce432eed245196bca6fde":["8435160e9702b19398118ddf76b61c846612b6a4"],"ee3df95012e016c229172f87a6c4077957246c4a":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"5eb2511ababf862ea11e10761c70ee560cd84510":[],"71e1a70f18d64b93db3ef618e606d6df5062f747":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","14654be3f7a82c9a3c52169e365baa55bfe64f66"],"352763be0465236f8e2ac188aa1b761cb3e1c9ee":["9b2af6b2c05418fb9df466c739ed5b3a153eadde"],"b0267c69e2456a3477a1ad785723f2135da3117e":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","618635065f043788c9e034f96ca5cd5cea1b4592"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["72075e55f96fefa443288356377c83e70d94cbd2"],"0567bdc5c86c94ced64201187cfcef2417d76dda":["b7605579001505896d48b07160075a5c8b8e128e","e3cc329405ce41b8ef462b4cd30611eca1567620","a656b32c3aa151037a8c52e9b134acc3cbf482bc"],"9b2af6b2c05418fb9df466c739ed5b3a153eadde":["1494abe5dc85557ec2e2772f87660d48f831c3a5"],"8435160e9702b19398118ddf76b61c846612b6a4":["2f13fb377f9b5df46af44bf90a2e507a884f2c30"],"3384e6013a93e4d11b7d75388693f8d0388602bf":["db68c63cbfaa8698b9c4475f75ed2b9c9696d238"],"2f13fb377f9b5df46af44bf90a2e507a884f2c30":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"618635065f043788c9e034f96ca5cd5cea1b4592":["8f3189d15ef66702bbb45771403a68793d5cd137"],"46e4a8bdfbafda795ef9c39a2bc2d47095770299":["a5d957b3a23cce91c77a2c9971ecf0c9f99dd503","5f6bd27530a2846413fe2d00030493c0e2d3a072"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"e3cc329405ce41b8ef462b4cd30611eca1567620":["4f35160e92057203e23664ebd12f99390d92cb62"],"14654be3f7a82c9a3c52169e365baa55bfe64f66":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a656b32c3aa151037a8c52e9b134acc3cbf482bc":[],"d71ab2bff76807be0f283d5a8819ca4af4e7ca46":["ee3df95012e016c229172f87a6c4077957246c4a"],"db68c63cbfaa8698b9c4475f75ed2b9c9696d238":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","79700663e164dece87bed4adfd3e28bab6cb1385","299a2348fa24151d150182211b6208a38e5e3450"],"0d49a158012a8ff48f328a4558e4bfcffbaed16f":["68496c2200e559fb7802f7575427b7a482659afb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b06445ae1731e049327712db0454e5643ca9b7fe","5eb2511ababf862ea11e10761c70ee560cd84510","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a656b32c3aa151037a8c52e9b134acc3cbf482bc","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}