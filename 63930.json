{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"modules/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dae862628c7a5275e1ff00ff3bc9803dedf124a9","date":1358939646,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals));\n        } // endof need to merge both AACO -- children for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b2d5244a676b83c2d551c3746e8181588ba619e1","date":1359031414,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals));\n        } // endof need to merge both AACO -- children for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children (and the residue over \n      // non included chilren)\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {\n            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];\n          }\n          while (indexIntoTFR < tfrAACO.ordinals.length) {\n            resResidue += tfrAACO.values[indexIntoTFR++];\n          }\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));\n        } // endof need to merge both AACO -- children and residue for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"571abba77e55fea386a38c0024f72ffa5b37a9ad","date":1360272747,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see #mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults) {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.numResults; // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals));\n        } // endof need to merge both AACO -- children for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)\n  throws ClassCastException, IllegalArgumentException {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.getNumResults(); // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals));\n        } // endof need to merge both AACO -- children for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see #mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults) {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.numResults; // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals));\n        } // endof need to merge both AACO -- children for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#mergeResults(IntermediateFacetResult...).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the\n   * same format\n   * \n   * @see #mergeResults(IntermediateFacetResult...)\n   */\n  @Override\n  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults) {\n\n    if (tmpResults.length == 0) {\n      return null;\n    }\n\n    int i=0;\n    // skip over null tmpResults\n    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}\n    if (i == tmpResults.length) {\n      // all inputs are null\n      return null;\n    }\n\n    // i points to the first non-null input \n    int K = this.facetRequest.numResults; // number of best result in each node\n    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];\n\n    // now loop over the rest of tmpResults and merge each into tmpToReturn\n    for ( ; i < tmpResults.length; i++) {\n      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];\n      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;\n      if (tfr.isRootNodeIncluded) {\n        tmpToReturn.isRootNodeIncluded = true;\n        tmpToReturn.rootNodeValue = tfr.rootNodeValue;\n      }\n      // now merge the HashMap of tfr into this of tmpToReturn\n      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;\n      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;\n      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();\n      //iterate over all ordinals in tfr that are maps to their children\n      while (tfrIntIterator.hasNext()) {\n        int tfrkey = tfrIntIterator.next();\n        AACO tmpToReturnAACO = null;\n        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {\n          // if tmpToReturn does not have any kids of tfrkey, map all the kids\n          // from tfr to it as one package, along with their redisude\n          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));\n        } else {\n          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr\n          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);\n          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;\n          if (K < resLength) {\n            resLength = K;\n          }\n          int[] resOrds = new int [resLength];\n          double[] resVals = new double [resLength];\n          int indexIntoTmpToReturn = 0;\n          int indexIntoTFR = 0;\n          ACComparator merger = getSuitableACComparator(); // by facet Request\n          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {\n            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {\n              //tmpToReturnAACO (former result to return) ran out of indices\n              // it is all merged into resOrds and resVal\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n              continue;\n            }\n            if (indexIntoTFR >= tfrAACO.ordinals.length) {\n              // tfr ran out of indices\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n              continue;\n            }\n            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:\n            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], \n                tmpToReturnAACO.values[indexIntoTmpToReturn], \n                tfrAACO.ordinals[indexIntoTFR], \n                tfrAACO.values[indexIntoTFR])) {\n              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];\n              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];\n              indexIntoTmpToReturn++;\n            } else {\n              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];\n              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];\n              indexIntoTFR++;\n            }\n          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr\n          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of \n          // tmpToReturn\n\n          //update the list of best kids of tfrkey as appear in tmpToReturn\n          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals));\n        } // endof need to merge both AACO -- children for same ordinal\n\n      } // endof loop over all ordinals in tfr \n    } // endof loop over all temporary facet results to merge\n\n    return tmpToReturn;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"dae862628c7a5275e1ff00ff3bc9803dedf124a9":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d33e19a97046248623a7591aeaa6547233fd15e2":["571abba77e55fea386a38c0024f72ffa5b37a9ad"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["571abba77e55fea386a38c0024f72ffa5b37a9ad","d33e19a97046248623a7591aeaa6547233fd15e2"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["dae862628c7a5275e1ff00ff3bc9803dedf124a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"b2d5244a676b83c2d551c3746e8181588ba619e1":["b89678825b68eccaf09e6ab71675fc0b0af1e099","dae862628c7a5275e1ff00ff3bc9803dedf124a9"]},"commit2Childs":{"dae862628c7a5275e1ff00ff3bc9803dedf124a9":["571abba77e55fea386a38c0024f72ffa5b37a9ad","b2d5244a676b83c2d551c3746e8181588ba619e1"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["dae862628c7a5275e1ff00ff3bc9803dedf124a9","b2d5244a676b83c2d551c3746e8181588ba619e1"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["d33e19a97046248623a7591aeaa6547233fd15e2","3cc728b07df73b197e6d940d27f9b08b63918f13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b2d5244a676b83c2d551c3746e8181588ba619e1":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b2d5244a676b83c2d551c3746e8181588ba619e1"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}