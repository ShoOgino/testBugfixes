{"path":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/src/webapp/src/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n    }\n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n    }\n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n    }\n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (server.isRunning()) {\n      server.stop();\n      server.join();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66c64e8cfded6a585100e6430238faaf416f3fea","date":1344964603,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n      RUNNING_JETTIES.remove(this);\n    }\n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n    }\n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n      RUNNING_JETTIES.remove(this);\n    }\n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n    }\n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n      RUNNING_JETTIES.remove(this);\n    }\n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n    }\n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"25959fdb8f69c74c6a5836bf42e8e98c705ad005","date":1346336175,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    // we try and do a bunch of extra stop stuff because\n    // jetty doesn't like to stop if it started\n    // and ended up in a failure state (like when it cannot get the port)\n    if (server.getState().equals(Server.FAILED)) {\n      Connector[] connectors = server.getConnectors();\n      for (Connector connector : connectors) {\n        connector.stop();\n      }\n    }\n    Filter filter = dispatchFilter.getFilter();\n    ThreadPool threadPool = server.getThreadPool();\n    server.getServer().stop();\n    server.stop();\n    if (threadPool instanceof QueuedThreadPool) {\n      ((QueuedThreadPool) threadPool).setMaxStopTimeMs(15000);\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).stop();\n    }\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n      RUNNING_JETTIES.remove(this);\n    }\n    server.join();\n  }\n\n","bugFix":null,"bugIntro":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    // we try and do a bunch of extra stop stuff because\n    // jetty doesn't like to stop if it started\n    // and ended up in a failure state (like when it cannot get the port)\n    if (server.getState().equals(Server.FAILED)) {\n      Connector[] connectors = server.getConnectors();\n      for (Connector connector : connectors) {\n        connector.stop();\n      }\n    }\n    Filter filter = dispatchFilter.getFilter();\n    ThreadPool threadPool = server.getThreadPool();\n    server.getServer().stop();\n    server.stop();\n    if (threadPool instanceof QueuedThreadPool) {\n      ((QueuedThreadPool) threadPool).setMaxStopTimeMs(15000);\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).stop();\n    }\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    if (!server.isStopped() && !server.isStopping()) {\n      server.stop();\n      RUNNING_JETTIES.remove(this);\n    }\n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n    // we try and do a bunch of extra stop stuff because\n    // jetty doesn't like to stop if it started\n    // and ended up in a failure state (like when it cannot get the port)\n    if (server.getState().equals(Server.FAILED)) {\n      Connector[] connectors = server.getConnectors();\n      for (Connector connector : connectors) {\n        connector.stop();\n      }\n    }\n    Filter filter = dispatchFilter.getFilter();\n    ThreadPool threadPool = server.getThreadPool();\n    server.getServer().stop();\n    server.stop();\n    if (threadPool instanceof QueuedThreadPool) {\n      ((QueuedThreadPool) threadPool).setMaxStopTimeMs(30000);\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).join();\n    }\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    // we try and do a bunch of extra stop stuff because\n    // jetty doesn't like to stop if it started\n    // and ended up in a failure state (like when it cannot get the port)\n    if (server.getState().equals(Server.FAILED)) {\n      Connector[] connectors = server.getConnectors();\n      for (Connector connector : connectors) {\n        connector.stop();\n      }\n    }\n    Filter filter = dispatchFilter.getFilter();\n    ThreadPool threadPool = server.getThreadPool();\n    server.getServer().stop();\n    server.stop();\n    if (threadPool instanceof QueuedThreadPool) {\n      ((QueuedThreadPool) threadPool).setMaxStopTimeMs(15000);\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).stop();\n    }\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","bugFix":["25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f4821d05931759774f7fd656e31d449de2d1436","date":1355887327,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    // we try and do a bunch of extra stop stuff because\n    // jetty doesn't like to stop if it started\n    // and ended up in a failure state (like when it cannot get the port)\n    if (server.getState().equals(Server.FAILED)) {\n      Connector[] connectors = server.getConnectors();\n      for (Connector connector : connectors) {\n        connector.stop();\n      }\n    }\n    Filter filter = dispatchFilter.getFilter();\n    ThreadPool threadPool = server.getThreadPool();\n    server.getServer().stop();\n    server.stop();\n    if (threadPool instanceof QueuedThreadPool) {\n      ((QueuedThreadPool) threadPool).setMaxStopTimeMs(30000);\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).join();\n    }\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n    // we try and do a bunch of extra stop stuff because\n    // jetty doesn't like to stop if it started\n    // and ended up in a failure state (like when it cannot get the port)\n    if (server.getState().equals(Server.FAILED)) {\n      Connector[] connectors = server.getConnectors();\n      for (Connector connector : connectors) {\n        connector.stop();\n      }\n    }\n    Filter filter = dispatchFilter.getFilter();\n    ThreadPool threadPool = server.getThreadPool();\n    server.getServer().stop();\n    server.stop();\n    if (threadPool instanceof QueuedThreadPool) {\n      ((QueuedThreadPool) threadPool).setMaxStopTimeMs(30000);\n      ((QueuedThreadPool) threadPool).stop();\n      ((QueuedThreadPool) threadPool).join();\n    }\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09bf2ac3af855efa1f7631177ce8dad43bace34b","date":1386879352,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bc766d645fa848f86c381c7f6acf2c881c99399","date":1425549246,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","sourceOld":"  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    //server.destroy();\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb5af3afeddbb803fb785098176e6e177c34261b","date":1428905393,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      server.join();\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n\n    Filter filter = dispatchFilter.getFilter();\n\n    server.stop();\n\n    if (server.getState().equals(Server.FAILED)) {\n      filter.destroy();\n      if (extraFilters != null) {\n        for (FilterHolder f : extraFilters) {\n          f.getFilter().destroy();\n        }\n      }\n    }\n    \n    server.join();\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      Thread shutdownThead = null;\n      if (sdf != null) {\n        shutdownThead = new Thread() {\n\n          public void run() {\n            try {\n              sdf.close();\n            } catch (Throwable t) {\n              log.error(\"Error shutting down Solr\", t);\n            }\n          }\n\n        };\n        sdf.closeOnDestroy(false);\n        shutdownThead.start();\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n      \n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n      \n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n      \n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n        \n        rte.stop();\n        \n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (shutdownThead != null) {\n        shutdownThead.join();\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n      \n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n      \n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String, String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      server.join();\n    } finally {\n      if (prevContext != null)  {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":["cb5af3afeddbb803fb785098176e6e177c34261b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18","date":1543645562,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      ExecutorService customThreadPool = null;\n      if (sdf != null) {\n        customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jettyShutDown\"));\n\n        sdf.closeOnDestroy(false);\n//        customThreadPool.submit(() -> {\n//          try {\n//            sdf.close();\n//          } catch (Throwable t) {\n//            log.error(\"Error shutting down Solr\", t);\n//          }\n//        });\n        try {\n          sdf.close();\n        } catch (Throwable t) {\n          log.error(\"Error shutting down Solr\", t);\n        }\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n      \n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n      \n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n      \n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n        \n        rte.stop();\n        \n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (customThreadPool != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n      \n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n      \n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      Thread shutdownThead = null;\n      if (sdf != null) {\n        shutdownThead = new Thread() {\n\n          public void run() {\n            try {\n              sdf.close();\n            } catch (Throwable t) {\n              log.error(\"Error shutting down Solr\", t);\n            }\n          }\n\n        };\n        sdf.closeOnDestroy(false);\n        shutdownThead.start();\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n      \n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n      \n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n      \n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n        \n        rte.stop();\n        \n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (shutdownThead != null) {\n        shutdownThead.join();\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n      \n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n      \n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15","date":1554259533,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      ExecutorService customThreadPool = null;\n      if (sdf != null) {\n        customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jettyShutDown\"));\n\n        sdf.closeOnDestroy(false);\n//        customThreadPool.submit(() -> {\n//          try {\n//            sdf.close();\n//          } catch (Throwable t) {\n//            log.error(\"Error shutting down Solr\", t);\n//          }\n//        });\n        try {\n          sdf.close();\n        } catch (Throwable t) {\n          log.error(\"Error shutting down Solr\", t);\n        }\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n\n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n\n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n\n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n\n        rte.stop();\n\n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (customThreadPool != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n\n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n\n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      ExecutorService customThreadPool = null;\n      if (sdf != null) {\n        customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jettyShutDown\"));\n\n        sdf.closeOnDestroy(false);\n//        customThreadPool.submit(() -> {\n//          try {\n//            sdf.close();\n//          } catch (Throwable t) {\n//            log.error(\"Error shutting down Solr\", t);\n//          }\n//        });\n        try {\n          sdf.close();\n        } catch (Throwable t) {\n          log.error(\"Error shutting down Solr\", t);\n        }\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n      \n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n      \n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n      \n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n        \n        rte.stop();\n        \n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (customThreadPool != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n      \n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n      \n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","pathOld":"solr/core/src/java/org/apache/solr/client/solrj/embedded/JettySolrRunner#stop().mjava","sourceNew":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      ExecutorService customThreadPool = null;\n      if (sdf != null) {\n        customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"jettyShutDown\"));\n\n        sdf.closeOnDestroy(false);\n//        customThreadPool.submit(() -> {\n//          try {\n//            sdf.close();\n//          } catch (Throwable t) {\n//            log.error(\"Error shutting down Solr\", t);\n//          }\n//        });\n        try {\n          sdf.close();\n        } catch (Throwable t) {\n          log.error(\"Error shutting down Solr\", t);\n        }\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n\n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n\n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n\n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n\n        rte.stop();\n\n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (customThreadPool != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n\n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n\n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Stop the Jetty server\n   *\n   * @throws Exception if an error occurs on shutdown\n   */\n  public void stop() throws Exception {\n    // Do not let Jetty/Solr pollute the MDC for this thread\n    Map<String,String> prevContext = MDC.getCopyOfContextMap();\n    MDC.clear();\n    try {\n      Filter filter = dispatchFilter.getFilter();\n\n      // we want to shutdown outside of jetty cutting us off\n      SolrDispatchFilter sdf = getSolrDispatchFilter();\n      ExecutorService customThreadPool = null;\n      if (sdf != null) {\n        customThreadPool = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jettyShutDown\"));\n\n        sdf.closeOnDestroy(false);\n//        customThreadPool.submit(() -> {\n//          try {\n//            sdf.close();\n//          } catch (Throwable t) {\n//            log.error(\"Error shutting down Solr\", t);\n//          }\n//        });\n        try {\n          sdf.close();\n        } catch (Throwable t) {\n          log.error(\"Error shutting down Solr\", t);\n        }\n      }\n\n      QueuedThreadPool qtp = (QueuedThreadPool) server.getThreadPool();\n      ReservedThreadExecutor rte = qtp.getBean(ReservedThreadExecutor.class);\n\n      server.stop();\n\n      if (server.getState().equals(Server.FAILED)) {\n        filter.destroy();\n        if (extraFilters != null) {\n          for (FilterHolder f : extraFilters) {\n            f.getFilter().destroy();\n          }\n        }\n      }\n\n      // stop timeout is 0, so we will interrupt right away\n      while(!qtp.isStopped()) {\n        qtp.stop();\n        if (qtp.isStopped()) {\n          Thread.sleep(50);\n        }\n      }\n\n      // we tried to kill everything, now we wait for executor to stop\n      qtp.setStopTimeout(Integer.MAX_VALUE);\n      qtp.stop();\n      qtp.join();\n\n      if (rte != null) {\n        // we try and wait for the reserved thread executor, but it doesn't always seem to work\n        // so we actually set 0 reserved threads at creation\n\n        rte.stop();\n\n        TimeOut timeout = new TimeOut(30, TimeUnit.SECONDS, TimeSource.NANO_TIME);\n        timeout.waitFor(\"Timeout waiting for reserved executor to stop.\", ()\n            -> rte.isStopped());\n      }\n\n      if (customThreadPool != null) {\n        ExecutorUtil.shutdownAndAwaitTermination(customThreadPool);\n      }\n\n      do {\n        try {\n          server.join();\n        } catch (InterruptedException e) {\n          // ignore\n        }\n      } while (!server.isStopped());\n\n    } finally {\n      if (enableProxy) {\n        proxy.close();\n      }\n\n      if (prevContext != null) {\n        MDC.setContextMap(prevContext);\n      } else {\n        MDC.clear();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","7f4821d05931759774f7fd656e31d449de2d1436"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["cb5af3afeddbb803fb785098176e6e177c34261b"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","66c64e8cfded6a585100e6430238faaf416f3fea"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["09bf2ac3af855efa1f7631177ce8dad43bace34b"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","66c64e8cfded6a585100e6430238faaf416f3fea"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["09bf2ac3af855efa1f7631177ce8dad43bace34b","9bc766d645fa848f86c381c7f6acf2c881c99399"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"25959fdb8f69c74c6a5836bf42e8e98c705ad005":["66c64e8cfded6a585100e6430238faaf416f3fea"],"66c64e8cfded6a585100e6430238faaf416f3fea":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["c26f00b574427b55127e869b935845554afde1fa","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"09bf2ac3af855efa1f7631177ce8dad43bace34b":["7f4821d05931759774f7fd656e31d449de2d1436"],"7f4821d05931759774f7fd656e31d449de2d1436":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["c26f00b574427b55127e869b935845554afde1fa"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["7f4821d05931759774f7fd656e31d449de2d1436","09bf2ac3af855efa1f7631177ce8dad43bace34b"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18"],"cb5af3afeddbb803fb785098176e6e177c34261b":["9bc766d645fa848f86c381c7f6acf2c881c99399"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"c26f00b574427b55127e869b935845554afde1fa":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"9bc766d645fa848f86c381c7f6acf2c881c99399":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cb5af3afeddbb803fb785098176e6e177c34261b"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7f4821d05931759774f7fd656e31d449de2d1436"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"0e34aff27dfe70db6a9f0d2da0f5d9b640fbac18":["0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","c903c3d15906a3da96b8c0c2fb704491005fdbdb","a258fbb26824fd104ed795e5d9033d2d040049ee"],"25959fdb8f69c74c6a5836bf42e8e98c705ad005":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","05a14b2611ead08655a2b2bdc61632eb31316e57"],"66c64e8cfded6a585100e6430238faaf416f3fea":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","25959fdb8f69c74c6a5836bf42e8e98c705ad005"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"09bf2ac3af855efa1f7631177ce8dad43bace34b":["9bc766d645fa848f86c381c7f6acf2c881c99399","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"7f4821d05931759774f7fd656e31d449de2d1436":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","09bf2ac3af855efa1f7631177ce8dad43bace34b","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","0d22ac6a4146774c1bc8400160fc0b6150294e92","66c64e8cfded6a585100e6430238faaf416f3fea","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"0db83f1bb855a4ac824c9a2a8e1ee9b29a039c15":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cb5af3afeddbb803fb785098176e6e177c34261b":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b05c56a41b733e02a189c48895922b5bd8c7f3d1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}