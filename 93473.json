{"path":"solr/core/src/java/org/apache/solr/handler/component/MoreLikeThisComponent#mergeSolrDocumentList(SolrDocumentList,SolrDocumentList,int,String).mjava","commits":[{"id":"b38d50314a7281b1ef90bfb3bb0bc91a38f0078f","date":1355410999,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/MoreLikeThisComponent#mergeSolrDocumentList(SolrDocumentList,SolrDocumentList,int,String).mjava","pathOld":"/dev/null","sourceNew":"  public SolrDocumentList mergeSolrDocumentList(SolrDocumentList one,\n      SolrDocumentList two, int maxSize, String idField) {\n\n    List<SolrDocument> l = new ArrayList<SolrDocument>();\n    \n    // De-dup records sets. Shouldn't happen if indexed correctly.\n    Map<String,SolrDocument> map = new HashMap<String,SolrDocument>();\n    for (SolrDocument doc : one) {\n      Object id = doc.getFieldValue(idField);\n      assert id != null : doc.toString();\n      map.put(id.toString(), doc);\n    }\n    for (SolrDocument doc : two) {\n      map.put(doc.getFieldValue(idField).toString(), doc);\n    }\n    \n    l = new ArrayList<SolrDocument>(map.values());\n    \n    // Comparator to sort docs based on score. null scores/docs are set to 0.\n    \n    // hmm...we are ordering by scores that are not really comparable...\n    Comparator<SolrDocument> c = new Comparator<SolrDocument>() {\n      public int compare(SolrDocument o1, SolrDocument o2) {\n        Float f1 = getFloat(o1);\n        Float f2 = getFloat(o2);\n        return f2.compareTo(f1);\n      }\n      \n      private Float getFloat(SolrDocument doc) {\n        Float f = 0f;\n        if (doc != null) {\n          Object o = doc.getFieldValue(\"score\");\n          if (o != null && o instanceof Float) {\n            f = (Float) o;\n          }\n        }\n        return f;\n      }\n    };\n    \n    Collections.sort(l, c);\n    \n    // Truncate list to maxSize\n    if (l.size() > maxSize) {\n      l = l.subList(0, maxSize);\n    }\n    \n    // Create SolrDocumentList Attributes from originals\n    SolrDocumentList result = new SolrDocumentList();\n    result.addAll(l);\n    result.setMaxScore(Math.max(one.getMaxScore(), two.getMaxScore()));\n    result.setNumFound(one.getNumFound() + two.getNumFound());\n    result.setStart(Math.min(one.getStart(), two.getStart()));\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/MoreLikeThisComponent#mergeSolrDocumentList(SolrDocumentList,SolrDocumentList,int,String).mjava","pathOld":"/dev/null","sourceNew":"  public SolrDocumentList mergeSolrDocumentList(SolrDocumentList one,\n      SolrDocumentList two, int maxSize, String idField) {\n\n    List<SolrDocument> l = new ArrayList<SolrDocument>();\n    \n    // De-dup records sets. Shouldn't happen if indexed correctly.\n    Map<String,SolrDocument> map = new HashMap<String,SolrDocument>();\n    for (SolrDocument doc : one) {\n      Object id = doc.getFieldValue(idField);\n      assert id != null : doc.toString();\n      map.put(id.toString(), doc);\n    }\n    for (SolrDocument doc : two) {\n      map.put(doc.getFieldValue(idField).toString(), doc);\n    }\n    \n    l = new ArrayList<SolrDocument>(map.values());\n    \n    // Comparator to sort docs based on score. null scores/docs are set to 0.\n    \n    // hmm...we are ordering by scores that are not really comparable...\n    Comparator<SolrDocument> c = new Comparator<SolrDocument>() {\n      public int compare(SolrDocument o1, SolrDocument o2) {\n        Float f1 = getFloat(o1);\n        Float f2 = getFloat(o2);\n        return f2.compareTo(f1);\n      }\n      \n      private Float getFloat(SolrDocument doc) {\n        Float f = 0f;\n        if (doc != null) {\n          Object o = doc.getFieldValue(\"score\");\n          if (o != null && o instanceof Float) {\n            f = (Float) o;\n          }\n        }\n        return f;\n      }\n    };\n    \n    Collections.sort(l, c);\n    \n    // Truncate list to maxSize\n    if (l.size() > maxSize) {\n      l = l.subList(0, maxSize);\n    }\n    \n    // Create SolrDocumentList Attributes from originals\n    SolrDocumentList result = new SolrDocumentList();\n    result.addAll(l);\n    result.setMaxScore(Math.max(one.getMaxScore(), two.getMaxScore()));\n    result.setNumFound(one.getNumFound() + two.getNumFound());\n    result.setStart(Math.min(one.getStart(), two.getStart()));\n\n    return result;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/MoreLikeThisComponent#mergeSolrDocumentList(SolrDocumentList,SolrDocumentList,int,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/MoreLikeThisComponent#mergeSolrDocumentList(SolrDocumentList,SolrDocumentList,int,String).mjava","sourceNew":"  public SolrDocumentList mergeSolrDocumentList(SolrDocumentList one,\n      SolrDocumentList two, int maxSize, String idField) {\n\n    List<SolrDocument> l = new ArrayList<>();\n    \n    // De-dup records sets. Shouldn't happen if indexed correctly.\n    Map<String,SolrDocument> map = new HashMap<>();\n    for (SolrDocument doc : one) {\n      Object id = doc.getFieldValue(idField);\n      assert id != null : doc.toString();\n      map.put(id.toString(), doc);\n    }\n    for (SolrDocument doc : two) {\n      map.put(doc.getFieldValue(idField).toString(), doc);\n    }\n    \n    l = new ArrayList<>(map.values());\n    \n    // Comparator to sort docs based on score. null scores/docs are set to 0.\n    \n    // hmm...we are ordering by scores that are not really comparable...\n    Comparator<SolrDocument> c = new Comparator<SolrDocument>() {\n      public int compare(SolrDocument o1, SolrDocument o2) {\n        Float f1 = getFloat(o1);\n        Float f2 = getFloat(o2);\n        return f2.compareTo(f1);\n      }\n      \n      private Float getFloat(SolrDocument doc) {\n        Float f = 0f;\n        if (doc != null) {\n          Object o = doc.getFieldValue(\"score\");\n          if (o != null && o instanceof Float) {\n            f = (Float) o;\n          }\n        }\n        return f;\n      }\n    };\n    \n    Collections.sort(l, c);\n    \n    // Truncate list to maxSize\n    if (l.size() > maxSize) {\n      l = l.subList(0, maxSize);\n    }\n    \n    // Create SolrDocumentList Attributes from originals\n    SolrDocumentList result = new SolrDocumentList();\n    result.addAll(l);\n    result.setMaxScore(Math.max(one.getMaxScore(), two.getMaxScore()));\n    result.setNumFound(one.getNumFound() + two.getNumFound());\n    result.setStart(Math.min(one.getStart(), two.getStart()));\n\n    return result;\n  }\n\n","sourceOld":"  public SolrDocumentList mergeSolrDocumentList(SolrDocumentList one,\n      SolrDocumentList two, int maxSize, String idField) {\n\n    List<SolrDocument> l = new ArrayList<SolrDocument>();\n    \n    // De-dup records sets. Shouldn't happen if indexed correctly.\n    Map<String,SolrDocument> map = new HashMap<String,SolrDocument>();\n    for (SolrDocument doc : one) {\n      Object id = doc.getFieldValue(idField);\n      assert id != null : doc.toString();\n      map.put(id.toString(), doc);\n    }\n    for (SolrDocument doc : two) {\n      map.put(doc.getFieldValue(idField).toString(), doc);\n    }\n    \n    l = new ArrayList<SolrDocument>(map.values());\n    \n    // Comparator to sort docs based on score. null scores/docs are set to 0.\n    \n    // hmm...we are ordering by scores that are not really comparable...\n    Comparator<SolrDocument> c = new Comparator<SolrDocument>() {\n      public int compare(SolrDocument o1, SolrDocument o2) {\n        Float f1 = getFloat(o1);\n        Float f2 = getFloat(o2);\n        return f2.compareTo(f1);\n      }\n      \n      private Float getFloat(SolrDocument doc) {\n        Float f = 0f;\n        if (doc != null) {\n          Object o = doc.getFieldValue(\"score\");\n          if (o != null && o instanceof Float) {\n            f = (Float) o;\n          }\n        }\n        return f;\n      }\n    };\n    \n    Collections.sort(l, c);\n    \n    // Truncate list to maxSize\n    if (l.size() > maxSize) {\n      l = l.subList(0, maxSize);\n    }\n    \n    // Create SolrDocumentList Attributes from originals\n    SolrDocumentList result = new SolrDocumentList();\n    result.addAll(l);\n    result.setMaxScore(Math.max(one.getMaxScore(), two.getMaxScore()));\n    result.setNumFound(one.getNumFound() + two.getNumFound());\n    result.setStart(Math.min(one.getStart(), two.getStart()));\n\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b38d50314a7281b1ef90bfb3bb0bc91a38f0078f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b38d50314a7281b1ef90bfb3bb0bc91a38f0078f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b38d50314a7281b1ef90bfb3bb0bc91a38f0078f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","b38d50314a7281b1ef90bfb3bb0bc91a38f0078f"],"b38d50314a7281b1ef90bfb3bb0bc91a38f0078f":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}