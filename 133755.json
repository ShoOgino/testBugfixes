{"path":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMapping#OrdinalMapping(SortedDocValues[]).mjava","commits":[{"id":"10cd984eebb9656e4afcd6ccf6968b710d630704","date":1360002935,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMapping#OrdinalMapping(SortedDocValues[]).mjava","pathOld":"/dev/null","sourceNew":"    OrdinalMapping(SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(globalOrd - segmentOrds[subIndex]);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(globalOrd - segmentOrds[subIndex]);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e","date":1360007824,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMap#OrdinalMap(SortedDocValues[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/MultiDocValues.OrdinalMapping#OrdinalMapping(SortedDocValues[]).mjava","sourceNew":"    OrdinalMap(SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          int delta = globalOrd - segmentOrds[subIndex];\n          assert delta >= 0;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(delta);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(delta);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","sourceOld":"    OrdinalMapping(SortedDocValues subs[]) throws IOException {\n      // create the ordinal mappings by pulling a termsenum over each sub's \n      // unique terms, and walking a multitermsenum over those\n      globalOrdDeltas = new AppendingLongBuffer();\n      subIndexes = new AppendingLongBuffer();\n      ordDeltas = new AppendingLongBuffer[subs.length];\n      for (int i = 0; i < ordDeltas.length; i++) {\n        ordDeltas[i] = new AppendingLongBuffer();\n      }\n      int segmentOrds[] = new int[subs.length];\n      ReaderSlice slices[] = new ReaderSlice[subs.length];\n      TermsEnumIndex indexes[] = new TermsEnumIndex[slices.length];\n      for (int i = 0; i < slices.length; i++) {\n        slices[i] = new ReaderSlice(0, 0, i);\n        indexes[i] = new TermsEnumIndex(new SortedDocValuesTermsEnum(subs[i]), i);\n      }\n      MultiTermsEnum mte = new MultiTermsEnum(slices);\n      mte.reset(indexes);\n      int globalOrd = 0;\n      while (mte.next() != null) {        \n        TermsEnumWithSlice matches[] = mte.getMatchArray();\n        for (int i = 0; i < mte.getMatchCount(); i++) {\n          int subIndex = matches[i].index;\n          // for each unique term, just mark the first subindex/delta where it occurs\n          if (i == 0) {\n            subIndexes.add(subIndex);\n            globalOrdDeltas.add(globalOrd - segmentOrds[subIndex]);\n          }\n          // for each per-segment ord, map it back to the global term.\n          ordDeltas[subIndex].add(globalOrd - segmentOrds[subIndex]);\n          segmentOrds[subIndex]++;\n        }\n        globalOrd++;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e":["10cd984eebb9656e4afcd6ccf6968b710d630704"],"10cd984eebb9656e4afcd6ccf6968b710d630704":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e":[],"10cd984eebb9656e4afcd6ccf6968b710d630704":["6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["10cd984eebb9656e4afcd6ccf6968b710d630704","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6509c8bbcf8f92ba1ecfaccea085eac1d5c4754e","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}