{"path":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors(SegmentWriteState).mjava","commits":[{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors(SegmentWriteState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors().mjava","sourceNew":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors(SegmentWriteState segmentWriteState) throws IOException {\n    TermVectorsWriter termVectorsWriter = new TermVectorsWriter(directory, segment, mergeState.fieldInfos, context);\n    // Used for bulk-reading raw bytes for term vectors\n    int rawDocLengths[] = new int[MAX_RAW_MERGE_DOCS];\n    int rawDocLengths2[] = new int[MAX_RAW_MERGE_DOCS];\n    try {\n      int idx = 0;\n      for (final MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n        final SegmentReader matchingSegmentReader = mergeState.matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.liveDocs != null) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader, rawDocLengths, rawDocLengths2);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader, rawDocLengths, rawDocLengths2);\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n    final int mergedDocs = segmentWriteState.numDocs;\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors() throws IOException {\n    TermVectorsWriter termVectorsWriter = new TermVectorsWriter(directory, segment, fieldInfos, context);\n\n    try {\n      int idx = 0;\n      for (final MergeState.IndexReaderAndLiveDocs reader : readers) {\n        final SegmentReader matchingSegmentReader = matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.liveDocs != null) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader);\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/src/java/org/apache/lucene/index/SegmentMerger#mergeVectors(SegmentWriteState).mjava","sourceNew":null,"sourceOld":"  /**\n   * Merge the TermVectors from each of the segments into the new one.\n   * @throws IOException\n   */\n  private final void mergeVectors(SegmentWriteState segmentWriteState) throws IOException {\n    TermVectorsWriter termVectorsWriter = new TermVectorsWriter(directory, segment, mergeState.fieldInfos, context);\n    // Used for bulk-reading raw bytes for term vectors\n    int rawDocLengths[] = new int[MAX_RAW_MERGE_DOCS];\n    int rawDocLengths2[] = new int[MAX_RAW_MERGE_DOCS];\n    try {\n      int idx = 0;\n      for (final MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n        final SegmentReader matchingSegmentReader = mergeState.matchingSegmentReaders[idx++];\n        TermVectorsReader matchingVectorsReader = null;\n        if (matchingSegmentReader != null) {\n          TermVectorsReader vectorsReader = matchingSegmentReader.getTermVectorsReader();\n\n          // If the TV* files are an older format then they cannot read raw docs:\n          if (vectorsReader != null && vectorsReader.canReadRawDocs()) {\n            matchingVectorsReader = vectorsReader;\n          }\n        }\n        if (reader.liveDocs != null) {\n          copyVectorsWithDeletions(termVectorsWriter, matchingVectorsReader, reader, rawDocLengths, rawDocLengths2);\n        } else {\n          copyVectorsNoDeletions(termVectorsWriter, matchingVectorsReader, reader, rawDocLengths, rawDocLengths2);\n        }\n      }\n    } finally {\n      termVectorsWriter.close();\n    }\n\n    final String fileName = IndexFileNames.segmentFileName(segment, \"\", IndexFileNames.VECTORS_INDEX_EXTENSION);\n    final long tvxSize = directory.fileLength(fileName);\n    final int mergedDocs = segmentWriteState.numDocs;\n\n    if (4+((long) mergedDocs)*16 != tvxSize)\n      // This is most likely a bug in Sun JRE 1.6.0_04/_05;\n      // we detect that the bug has struck, here, and\n      // throw an exception to prevent the corruption from\n      // entering the index.  See LUCENE-1282 for\n      // details.\n      throw new RuntimeException(\"mergeVectors produced an invalid result: mergedDocs is \" + mergedDocs + \" but tvx size is \" + tvxSize + \" file=\" + fileName + \" file exists?=\" + directory.fileExists(fileName) + \"; now aborting this merge to prevent index corruption\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"06584e6e98d592b34e1329b384182f368d2025e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["06584e6e98d592b34e1329b384182f368d2025e8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc749c053615f5871f3b95715fe292f34e70a53"]},"commit2Childs":{"06584e6e98d592b34e1329b384182f368d2025e8":["3cc749c053615f5871f3b95715fe292f34e70a53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06584e6e98d592b34e1329b384182f368d2025e8"],"3cc749c053615f5871f3b95715fe292f34e70a53":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}