{"path":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#manuallyConstructLegacyTRA().mjava","commits":[{"id":"105e345cf3c0abed3cb6c109274a379cb2655adc","date":1561038472,"type":0,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#manuallyConstructLegacyTRA().mjava","pathOld":"/dev/null","sourceNew":"  // here we do things not to be emulated elsewhere to create a legacy condition and ensure that we can\n  // work with both old and new formats.\n  private void manuallyConstructLegacyTRA() throws Exception {\n    // first create a \"modern\" alias\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\").setAutoDeleteAge(\"/DAY-3DAYS\")\n        .process(solrClient);\n\n    // now create collections that look like the legacy (pre __TRA__) names...\n    String legacy23 = alias + \"_\" + \"2017-10-23\";\n    CollectionAdminRequest.createCollection(legacy23, configName, numShards,numReplicas).process(solrClient);\n    String legacy24 = alias + \"_\" + \"2017-10-24\";\n    CollectionAdminRequest.createCollection(legacy24, configName, numShards,numReplicas).process(solrClient);\n\n    waitCol(1,legacy23);\n    waitCol(1,legacy24);\n    // put some data in the legacy collections:\n    assertUpdateResponse(solrClient.add(legacy23,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:01Z\")\n    ));\n    assertUpdateResponse(solrClient.add(legacy24,\n        sdoc(\"id\",\"2\",\"timestamp_dt\", \"2017-10-24T00:00:01Z\")\n    ));\n\n    solrClient.commit(legacy23);\n    solrClient.commit(legacy24);\n\n    QueryResponse resp = solrClient.query(legacy23, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    resp = solrClient.query(legacy24, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    // now knock out the collection backing our alias\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    List<String> collections = aliases.getCollectionAliasListMap().get(alias);\n    for (String collection : collections) {\n      CollectionAdminRequest.deleteCollection(collection);\n    }\n\n    // now grab the zk data so we can hack in our legacy collections..\n    byte[] data = zkStateReader.getZkClient().getData(\"/aliases.json\", null, null, true);\n\n    // some tidbits for handling zk data here are swiped from Aliases.json\n    Map<String, Map> aliasMap;\n    if (data == null || data.length == 0) {\n      aliasMap = Collections.emptyMap();\n    } else {\n      //noinspection unchecked\n      aliasMap = (Map<String, Map>) Utils.fromJSON(data);\n    }\n    assertNotEquals(0, aliasMap.size());\n\n    Map colAliases = aliasMap.getOrDefault(\"collection\", Collections.emptyMap());\n    assertNotEquals(0,colAliases.size());\n\n    String singleInitialCollection = (String) colAliases.get(alias);\n    assertFalse(singleInitialCollection.contains(\",\"));\n\n    // replace with our two new collections... in asc order!\n    colAliases.put(alias,String.join(\",\",legacy24,legacy23));\n\n    data = Utils.toJSON(aliasMap);\n    zkStateReader.getZkClient().setData(\"/aliases.json\",data,true);\n\n    zkStateReader.aliasesManager.update(); // make sure we've updated with the data we just sent\n\n    aliases = zkStateReader.aliasesManager.getAliases();\n    assertEquals(2,aliases.getCollectionAliasListMap().get(alias).size());\n\n    CollectionAdminRequest.deleteCollection(singleInitialCollection).process(solrClient);\n\n    waitCoreCount(singleInitialCollection,0);\n\n    // now make the legacy collections part of the alias\n    CollectionAdminRequest.setCollectionProperty(legacy23,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.setCollectionProperty(legacy24,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy23).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy24).process(solrClient);\n\n    cluster.getOpenOverseer().getCoreContainer().getZkController().getZkStateReader().aliasesManager.update();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#manuallyConstructLegacyTRA().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#manuallyConstructLegacyTRA().mjava","sourceNew":"  // here we do things not to be emulated elsewhere to create a legacy condition and ensure that we can\n  // work with both old and new formats.\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private void manuallyConstructLegacyTRA() throws Exception {\n    // first create a \"modern\" alias\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\").setAutoDeleteAge(\"/DAY-3DAYS\")\n        .process(solrClient);\n\n    // now create collections that look like the legacy (pre __TRA__) names...\n    String legacy23 = alias + \"_\" + \"2017-10-23\";\n    CollectionAdminRequest.createCollection(legacy23, configName, numShards,numReplicas).process(solrClient);\n    String legacy24 = alias + \"_\" + \"2017-10-24\";\n    CollectionAdminRequest.createCollection(legacy24, configName, numShards,numReplicas).process(solrClient);\n\n    waitCol(1,legacy23);\n    waitCol(1,legacy24);\n    // put some data in the legacy collections:\n    assertUpdateResponse(solrClient.add(legacy23,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:01Z\")\n    ));\n    assertUpdateResponse(solrClient.add(legacy24,\n        sdoc(\"id\",\"2\",\"timestamp_dt\", \"2017-10-24T00:00:01Z\")\n    ));\n\n    solrClient.commit(legacy23);\n    solrClient.commit(legacy24);\n\n    QueryResponse resp = solrClient.query(legacy23, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    resp = solrClient.query(legacy24, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    // now knock out the collection backing our alias\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    List<String> collections = aliases.getCollectionAliasListMap().get(alias);\n    for (String collection : collections) {\n      CollectionAdminRequest.deleteCollection(collection);\n    }\n\n    // now grab the zk data so we can hack in our legacy collections..\n    byte[] data = zkStateReader.getZkClient().getData(\"/aliases.json\", null, null, true);\n\n    // some tidbits for handling zk data here are swiped from Aliases.json\n    Map<String, Map> aliasMap;\n    if (data == null || data.length == 0) {\n      aliasMap = Collections.emptyMap();\n    } else {\n      aliasMap = (Map<String, Map>) Utils.fromJSON(data);\n    }\n    assertNotEquals(0, aliasMap.size());\n\n    Map colAliases = aliasMap.getOrDefault(\"collection\", Collections.emptyMap());\n    assertNotEquals(0,colAliases.size());\n\n    String singleInitialCollection = (String) colAliases.get(alias);\n    assertFalse(singleInitialCollection.contains(\",\"));\n\n    // replace with our two new collections... in asc order!\n    colAliases.put(alias,String.join(\",\",legacy24,legacy23));\n\n    data = Utils.toJSON(aliasMap);\n    zkStateReader.getZkClient().setData(\"/aliases.json\",data,true);\n\n    zkStateReader.aliasesManager.update(); // make sure we've updated with the data we just sent\n\n    aliases = zkStateReader.aliasesManager.getAliases();\n    assertEquals(2,aliases.getCollectionAliasListMap().get(alias).size());\n\n    CollectionAdminRequest.deleteCollection(singleInitialCollection).process(solrClient);\n\n    waitCoreCount(singleInitialCollection,0);\n\n    // now make the legacy collections part of the alias\n    CollectionAdminRequest.setCollectionProperty(legacy23,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.setCollectionProperty(legacy24,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy23).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy24).process(solrClient);\n\n    cluster.getOpenOverseer().getCoreContainer().getZkController().getZkStateReader().aliasesManager.update();\n  }\n\n","sourceOld":"  // here we do things not to be emulated elsewhere to create a legacy condition and ensure that we can\n  // work with both old and new formats.\n  private void manuallyConstructLegacyTRA() throws Exception {\n    // first create a \"modern\" alias\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\").setAutoDeleteAge(\"/DAY-3DAYS\")\n        .process(solrClient);\n\n    // now create collections that look like the legacy (pre __TRA__) names...\n    String legacy23 = alias + \"_\" + \"2017-10-23\";\n    CollectionAdminRequest.createCollection(legacy23, configName, numShards,numReplicas).process(solrClient);\n    String legacy24 = alias + \"_\" + \"2017-10-24\";\n    CollectionAdminRequest.createCollection(legacy24, configName, numShards,numReplicas).process(solrClient);\n\n    waitCol(1,legacy23);\n    waitCol(1,legacy24);\n    // put some data in the legacy collections:\n    assertUpdateResponse(solrClient.add(legacy23,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:01Z\")\n    ));\n    assertUpdateResponse(solrClient.add(legacy24,\n        sdoc(\"id\",\"2\",\"timestamp_dt\", \"2017-10-24T00:00:01Z\")\n    ));\n\n    solrClient.commit(legacy23);\n    solrClient.commit(legacy24);\n\n    QueryResponse resp = solrClient.query(legacy23, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    resp = solrClient.query(legacy24, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    // now knock out the collection backing our alias\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    List<String> collections = aliases.getCollectionAliasListMap().get(alias);\n    for (String collection : collections) {\n      CollectionAdminRequest.deleteCollection(collection);\n    }\n\n    // now grab the zk data so we can hack in our legacy collections..\n    byte[] data = zkStateReader.getZkClient().getData(\"/aliases.json\", null, null, true);\n\n    // some tidbits for handling zk data here are swiped from Aliases.json\n    Map<String, Map> aliasMap;\n    if (data == null || data.length == 0) {\n      aliasMap = Collections.emptyMap();\n    } else {\n      //noinspection unchecked\n      aliasMap = (Map<String, Map>) Utils.fromJSON(data);\n    }\n    assertNotEquals(0, aliasMap.size());\n\n    Map colAliases = aliasMap.getOrDefault(\"collection\", Collections.emptyMap());\n    assertNotEquals(0,colAliases.size());\n\n    String singleInitialCollection = (String) colAliases.get(alias);\n    assertFalse(singleInitialCollection.contains(\",\"));\n\n    // replace with our two new collections... in asc order!\n    colAliases.put(alias,String.join(\",\",legacy24,legacy23));\n\n    data = Utils.toJSON(aliasMap);\n    zkStateReader.getZkClient().setData(\"/aliases.json\",data,true);\n\n    zkStateReader.aliasesManager.update(); // make sure we've updated with the data we just sent\n\n    aliases = zkStateReader.aliasesManager.getAliases();\n    assertEquals(2,aliases.getCollectionAliasListMap().get(alias).size());\n\n    CollectionAdminRequest.deleteCollection(singleInitialCollection).process(solrClient);\n\n    waitCoreCount(singleInitialCollection,0);\n\n    // now make the legacy collections part of the alias\n    CollectionAdminRequest.setCollectionProperty(legacy23,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.setCollectionProperty(legacy24,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy23).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy24).process(solrClient);\n\n    cluster.getOpenOverseer().getCoreContainer().getZkController().getZkStateReader().aliasesManager.update();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#manuallyConstructLegacyTRA().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TimeRoutedAliasUpdateProcessorTest#manuallyConstructLegacyTRA().mjava","sourceNew":"  // here we do things not to be emulated elsewhere to create a legacy condition and ensure that we can\n  // work with both old and new formats.\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private void manuallyConstructLegacyTRA() throws Exception {\n    // first create a \"modern\" alias\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas))\n        .setPreemptiveCreateWindow(\"3HOUR\").setAutoDeleteAge(\"/DAY-3DAYS\")\n        .process(solrClient);\n\n    // now create collections that look like the legacy (pre __TRA__) names...\n    String legacy23 = alias + \"_\" + \"2017-10-23\";\n    CollectionAdminRequest.createCollection(legacy23, configName, numShards,numReplicas).process(solrClient);\n    String legacy24 = alias + \"_\" + \"2017-10-24\";\n    CollectionAdminRequest.createCollection(legacy24, configName, numShards,numReplicas).process(solrClient);\n\n    waitCol(1,legacy23);\n    waitCol(1,legacy24);\n    // put some data in the legacy collections:\n    assertUpdateResponse(solrClient.add(legacy23,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:01Z\")\n    ));\n    assertUpdateResponse(solrClient.add(legacy24,\n        sdoc(\"id\",\"2\",\"timestamp_dt\", \"2017-10-24T00:00:01Z\")\n    ));\n\n    solrClient.commit(legacy23);\n    solrClient.commit(legacy24);\n\n    QueryResponse resp = solrClient.query(legacy23, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    resp = solrClient.query(legacy24, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    // now knock out the collection backing our alias\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    List<String> collections = aliases.getCollectionAliasListMap().get(alias);\n    for (String collection : collections) {\n      CollectionAdminRequest.deleteCollection(collection);\n    }\n\n    // now grab the zk data so we can hack in our legacy collections..\n    byte[] data = zkStateReader.getZkClient().getData(\"/aliases.json\", null, null, true);\n\n    // some tidbits for handling zk data here are swiped from Aliases.json\n    Map<String, Map> aliasMap;\n    if (data == null || data.length == 0) {\n      aliasMap = Collections.emptyMap();\n    } else {\n      aliasMap = (Map<String, Map>) Utils.fromJSON(data);\n    }\n    assertNotEquals(0, aliasMap.size());\n\n    Map colAliases = aliasMap.getOrDefault(\"collection\", Collections.emptyMap());\n    assertNotEquals(0,colAliases.size());\n\n    String singleInitialCollection = (String) colAliases.get(alias);\n    assertFalse(singleInitialCollection.contains(\",\"));\n\n    // replace with our two new collections... in asc order!\n    colAliases.put(alias,String.join(\",\",legacy24,legacy23));\n\n    data = Utils.toJSON(aliasMap);\n    zkStateReader.getZkClient().setData(\"/aliases.json\",data,true);\n\n    zkStateReader.aliasesManager.update(); // make sure we've updated with the data we just sent\n\n    aliases = zkStateReader.aliasesManager.getAliases();\n    assertEquals(2,aliases.getCollectionAliasListMap().get(alias).size());\n\n    CollectionAdminRequest.deleteCollection(singleInitialCollection).process(solrClient);\n\n    waitCoreCount(singleInitialCollection,0);\n\n    // now make the legacy collections part of the alias\n    CollectionAdminRequest.setCollectionProperty(legacy23,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.setCollectionProperty(legacy24,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy23).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy24).process(solrClient);\n\n    cluster.getOpenOverseer().getCoreContainer().getZkController().getZkStateReader().aliasesManager.update();\n  }\n\n","sourceOld":"  // here we do things not to be emulated elsewhere to create a legacy condition and ensure that we can\n  // work with both old and new formats.\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  private void manuallyConstructLegacyTRA() throws Exception {\n    // first create a \"modern\" alias\n    String configName = getSaferTestName();\n    createConfigSet(configName);\n\n    final int numShards = 1 ;\n    final int numReplicas = 1 ;\n    CollectionAdminRequest.createTimeRoutedAlias(alias, \"2017-10-23T00:00:00Z\", \"+1DAY\", getTimeField(),\n        CollectionAdminRequest.createCollection(\"_unused_\", configName, numShards, numReplicas)\n            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow(\"3HOUR\").setAutoDeleteAge(\"/DAY-3DAYS\")\n        .process(solrClient);\n\n    // now create collections that look like the legacy (pre __TRA__) names...\n    String legacy23 = alias + \"_\" + \"2017-10-23\";\n    CollectionAdminRequest.createCollection(legacy23, configName, numShards,numReplicas).process(solrClient);\n    String legacy24 = alias + \"_\" + \"2017-10-24\";\n    CollectionAdminRequest.createCollection(legacy24, configName, numShards,numReplicas).process(solrClient);\n\n    waitCol(1,legacy23);\n    waitCol(1,legacy24);\n    // put some data in the legacy collections:\n    assertUpdateResponse(solrClient.add(legacy23,\n        sdoc(\"id\",\"1\",\"timestamp_dt\", \"2017-10-23T00:00:01Z\")\n    ));\n    assertUpdateResponse(solrClient.add(legacy24,\n        sdoc(\"id\",\"2\",\"timestamp_dt\", \"2017-10-24T00:00:01Z\")\n    ));\n\n    solrClient.commit(legacy23);\n    solrClient.commit(legacy24);\n\n    QueryResponse resp = solrClient.query(legacy23, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    resp = solrClient.query(legacy24, params(\n        \"q\", \"*:*\",\n        \"rows\", \"10\"));\n    assertEquals(1,resp.getResults().getNumFound());\n\n    // now knock out the collection backing our alias\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    Aliases aliases = zkStateReader.getAliases();\n    List<String> collections = aliases.getCollectionAliasListMap().get(alias);\n    for (String collection : collections) {\n      CollectionAdminRequest.deleteCollection(collection);\n    }\n\n    // now grab the zk data so we can hack in our legacy collections..\n    byte[] data = zkStateReader.getZkClient().getData(\"/aliases.json\", null, null, true);\n\n    // some tidbits for handling zk data here are swiped from Aliases.json\n    Map<String, Map> aliasMap;\n    if (data == null || data.length == 0) {\n      aliasMap = Collections.emptyMap();\n    } else {\n      aliasMap = (Map<String, Map>) Utils.fromJSON(data);\n    }\n    assertNotEquals(0, aliasMap.size());\n\n    Map colAliases = aliasMap.getOrDefault(\"collection\", Collections.emptyMap());\n    assertNotEquals(0,colAliases.size());\n\n    String singleInitialCollection = (String) colAliases.get(alias);\n    assertFalse(singleInitialCollection.contains(\",\"));\n\n    // replace with our two new collections... in asc order!\n    colAliases.put(alias,String.join(\",\",legacy24,legacy23));\n\n    data = Utils.toJSON(aliasMap);\n    zkStateReader.getZkClient().setData(\"/aliases.json\",data,true);\n\n    zkStateReader.aliasesManager.update(); // make sure we've updated with the data we just sent\n\n    aliases = zkStateReader.aliasesManager.getAliases();\n    assertEquals(2,aliases.getCollectionAliasListMap().get(alias).size());\n\n    CollectionAdminRequest.deleteCollection(singleInitialCollection).process(solrClient);\n\n    waitCoreCount(singleInitialCollection,0);\n\n    // now make the legacy collections part of the alias\n    CollectionAdminRequest.setCollectionProperty(legacy23,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.setCollectionProperty(legacy24,RoutedAlias.ROUTED_ALIAS_NAME_CORE_PROP, alias).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy23).process(solrClient);\n    CollectionAdminRequest.reloadCollection(legacy24).process(solrClient);\n\n    cluster.getOpenOverseer().getCoreContainer().getZkController().getZkStateReader().aliasesManager.update();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["e98520789adb1d5ad05afb4956eca0944a929688"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e98520789adb1d5ad05afb4956eca0944a929688":["105e345cf3c0abed3cb6c109274a379cb2655adc"]},"commit2Childs":{"105e345cf3c0abed3cb6c109274a379cb2655adc":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["105e345cf3c0abed3cb6c109274a379cb2655adc"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e98520789adb1d5ad05afb4956eca0944a929688":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}