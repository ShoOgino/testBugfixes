{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","commits":[{"id":"429beac997b503380be63cd29639faebbc60eb47","date":1339738410,"type":0,"author":"Sami Siren","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    server.add(doc);\n    server.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<String, Object>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      server.add(doc);\n      if(server instanceof HttpSolrServer) { //XXX concurrent server reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        server.commit(); //just to be sure the client has sent the doc\n        assertTrue(\"CUSS did not report an error\", ((Throwable)getCUSSExceptionField(server).get(server)).getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    server.add(doc);\n    server.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      server.add(doc);\n      if(server instanceof HttpSolrServer) { //XXX concurrent server reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        server.commit(); //just to be sure the client has sent the doc\n        assertTrue(\"CUSS did not report an error\", ((Throwable)getCUSSExceptionField(server).get(server)).getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    server.add(doc);\n    server.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<String, Object>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      server.add(doc);\n      if(server instanceof HttpSolrServer) { //XXX concurrent server reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        server.commit(); //just to be sure the client has sent the doc\n        assertTrue(\"CUSS did not report an error\", ((Throwable)getCUSSExceptionField(server).get(server)).getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", ((Throwable) getConcurrentClientExceptionField(client).get(client)).getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrServer server = getSolrServer();\n    server.deleteByQuery(\"*:*\");\n    server.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    server.add(doc);\n    server.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      server.add(doc);\n      if(server instanceof HttpSolrServer) { //XXX concurrent server reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        server.commit(); //just to be sure the client has sent the doc\n        assertTrue(\"CUSS did not report an error\", ((Throwable)getCUSSExceptionField(server).get(server)).getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    server.add(doc);\n    server.commit();\n    resp = server.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4383b91725e5b335d0a9d5f24b122b813dddd0cc","date":1442106431,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", ((Throwable) getConcurrentClientExceptionField(client).get(client)).getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f397f67677fe0a4df8bc57844ce335f657f290c8","date":1449000739,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-7339\")\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49bee3135753f5a129ce7f3eef9151efbb39fb27","date":1452189117,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/SOLR-7339\")\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3816df3ad3de1012a13891c359d86286335c44de","date":1489702248,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4b8a40b903c615a7efce52ba84df454d4609ae5","date":1490280010,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price_f\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price_f\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price_f\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price_f\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price_f\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a77e5e21cbd575a8240b0e3926164f15295f4e8","date":1544979500,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/SolrExampleTests#testUpdateField().mjava","sourceNew":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else if (client instanceof ErrorTrackingConcurrentUpdateSolrClient) {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      } else if (client instanceof SolrExampleStreamingHttp2Test.ErrorTrackingConcurrentUpdateSolrClient) {\n        client.commit(); //just to be sure the client has sent the doc\n        SolrExampleStreamingHttp2Test.ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (SolrExampleStreamingHttp2Test.ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","sourceOld":"  @Test\n  public void testUpdateField() throws Exception {\n    //no versions\n    SolrClient client = getSolrClient();\n    client.deleteByQuery(\"*:*\");\n    client.commit();\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"name\", \"gadget\");\n    doc.addField(\"price\", 1);\n    client.add(doc);\n    client.commit();\n    SolrQuery q = new SolrQuery(\"*:*\");\n    q.setFields(\"id\",\"price\",\"name\", \"_version_\");\n    QueryResponse resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    Long version = (Long)resp.getResults().get(0).getFirstValue(\"_version_\");\n    assertNotNull(\"no version returned\", version);\n    assertEquals(1.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n\n    //update \"price\" with incorrect version (optimistic locking)\n    HashMap<String, Object> oper = new HashMap<>();  //need better api for this???\n    oper.put(\"set\",100);\n\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version+1);\n    doc.addField(\"price\", oper);\n    try {\n      client.add(doc);\n      if(client instanceof HttpSolrClient) { //XXX concurrent client reports exceptions differently\n        fail(\"Operation should throw an exception!\");\n      } else {\n        client.commit(); //just to be sure the client has sent the doc\n        ErrorTrackingConcurrentUpdateSolrClient concurrentClient = (ErrorTrackingConcurrentUpdateSolrClient) client;\n        assertNotNull(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError);\n        assertTrue(\"ConcurrentUpdateSolrClient did not report an error\", concurrentClient.lastError.getMessage().contains(\"Conflict\"));\n      }\n    } catch (SolrException se) {\n      assertTrue(\"No identifiable error message\", se.getMessage().contains(\"version conflict for unique\"));\n    }\n    \n    //update \"price\", use correct version (optimistic locking)\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"_version_\", version);\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 100.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n\n    //update \"price\", no version\n    oper.put(\"set\", 200);\n    doc = new SolrInputDocument();\n    doc.addField(\"id\", \"unique\");\n    doc.addField(\"price\", oper);\n    client.add(doc);\n    client.commit();\n    resp = client.query(q);\n    assertEquals(\"Doc count does not match\", 1, resp.getResults().getNumFound());\n    assertEquals(\"price was not updated?\", 200.0f, resp.getResults().get(0).getFirstValue(\"price\"));\n    assertEquals(\"no name?\", \"gadget\", resp.getResults().get(0).getFirstValue(\"name\"));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["429beac997b503380be63cd29639faebbc60eb47"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["3816df3ad3de1012a13891c359d86286335c44de"],"3816df3ad3de1012a13891c359d86286335c44de":["49bee3135753f5a129ce7f3eef9151efbb39fb27"],"429beac997b503380be63cd29639faebbc60eb47":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4383b91725e5b335d0a9d5f24b122b813dddd0cc":["bafca15d8e408346a67f4282ad1143b88023893b"],"bafca15d8e408346a67f4282ad1143b88023893b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"f4b8a40b903c615a7efce52ba84df454d4609ae5":["49bee3135753f5a129ce7f3eef9151efbb39fb27"],"49bee3135753f5a129ce7f3eef9151efbb39fb27":["f397f67677fe0a4df8bc57844ce335f657f290c8"],"f397f67677fe0a4df8bc57844ce335f657f290c8":["4383b91725e5b335d0a9d5f24b122b813dddd0cc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bafca15d8e408346a67f4282ad1143b88023893b"],"1a77e5e21cbd575a8240b0e3926164f15295f4e8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3816df3ad3de1012a13891c359d86286335c44de":["1a77e5e21cbd575a8240b0e3926164f15295f4e8"],"429beac997b503380be63cd29639faebbc60eb47":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["429beac997b503380be63cd29639faebbc60eb47"],"4383b91725e5b335d0a9d5f24b122b813dddd0cc":["f397f67677fe0a4df8bc57844ce335f657f290c8"],"bafca15d8e408346a67f4282ad1143b88023893b":["4383b91725e5b335d0a9d5f24b122b813dddd0cc"],"f4b8a40b903c615a7efce52ba84df454d4609ae5":[],"49bee3135753f5a129ce7f3eef9151efbb39fb27":["3816df3ad3de1012a13891c359d86286335c44de","f4b8a40b903c615a7efce52ba84df454d4609ae5"],"f397f67677fe0a4df8bc57844ce335f657f290c8":["49bee3135753f5a129ce7f3eef9151efbb39fb27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["f4b8a40b903c615a7efce52ba84df454d4609ae5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}