{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","commits":[{"id":"859081acf00749f5dd462772c571d611d4a4d2db","date":1459527719,"type":0,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    if (params.get(PROP_SO_TIMEOUT) != null || params.get(PROP_CONNECTION_TIMEOUT) != null) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"The socket connect and read timeout cannot be set here and must be set\");\n    }\n    \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params == null ? new ModifiableSolrParams() : params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b3a63e635085f13be62c7e0829c70cb104e601b2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3a63e635085f13be62c7e0829c70cb104e601b2","date":1467359206,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","sourceNew":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","sourceOld":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    if (params.get(PROP_SO_TIMEOUT) != null || params.get(PROP_CONNECTION_TIMEOUT) != null) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"The socket connect and read timeout cannot be set here and must be set\");\n    }\n    \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params == null ? new ModifiableSolrParams() : params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","bugFix":["859081acf00749f5dd462772c571d611d4a4d2db"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56ae3539e829325e80cc0e8d65df4d724cc762d1","date":1467374872,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","sourceNew":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","sourceOld":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    if (params.get(PROP_SO_TIMEOUT) != null || params.get(PROP_CONNECTION_TIMEOUT) != null) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"The socket connect and read timeout cannot be set here and must be set\");\n    }\n    \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params == null ? new ModifiableSolrParams() : params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","sourceNew":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","sourceOld":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    if (params.get(PROP_SO_TIMEOUT) != null || params.get(PROP_CONNECTION_TIMEOUT) != null) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"The socket connect and read timeout cannot be set here and must be set\");\n    }\n    \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params == null ? new ModifiableSolrParams() : params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16fa358573e3c2508728b3c7c438a8c19a3f0ae4","date":1482846144,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","sourceNew":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    return createClient(params, cm, sharedConnectionManager, null);\n  }\n\n","sourceOld":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpClientUtil#createClient(SolrParams,PoolingHttpClientConnectionManager,boolean).mjava","sourceNew":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    return createClient(params, cm, sharedConnectionManager, null);\n  }\n\n","sourceOld":"  /**\n   * Creates new http client by using the provided configuration.\n   * \n   */\n  public static CloseableHttpClient createClient(final SolrParams params, PoolingHttpClientConnectionManager cm, boolean sharedConnectionManager) {\n    final ModifiableSolrParams config = new ModifiableSolrParams(params);\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Creating new http client, config:\" + config);\n    }\n \n    cm.setMaxTotal(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS, 10000));\n    cm.setDefaultMaxPerRoute(params.getInt(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, 10000));\n    cm.setValidateAfterInactivity(Integer.getInteger(VALIDATE_AFTER_INACTIVITY, VALIDATE_AFTER_INACTIVITY_DEFAULT));\n\n    \n    HttpClientBuilder newHttpClientBuilder = HttpClientBuilder.create();\n\n    if (sharedConnectionManager) {\n      newHttpClientBuilder.setConnectionManagerShared(true);\n    } else {\n      newHttpClientBuilder.setConnectionManagerShared(false);\n    }\n    \n    ConnectionKeepAliveStrategy keepAliveStrat = new ConnectionKeepAliveStrategy() {\n      @Override\n      public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n        // we only close connections based on idle time, not ttl expiration\n        return -1;\n      }\n    };\n\n    if (httpClientBuilder.getAuthSchemeRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultAuthSchemeRegistry(httpClientBuilder.getAuthSchemeRegistryProvider().getAuthSchemeRegistry());\n    }\n    if (httpClientBuilder.getCookieSpecRegistryProvider() != null) {\n      newHttpClientBuilder.setDefaultCookieSpecRegistry(httpClientBuilder.getCookieSpecRegistryProvider().getCookieSpecRegistry());\n    }\n    if (httpClientBuilder.getCredentialsProviderProvider() != null) {\n      newHttpClientBuilder.setDefaultCredentialsProvider(httpClientBuilder.getCredentialsProviderProvider().getCredentialsProvider());\n    }\n\n    newHttpClientBuilder.addInterceptorLast(new DynamicInterceptor());\n    \n    newHttpClientBuilder = newHttpClientBuilder.setKeepAliveStrategy(keepAliveStrat)\n        .evictIdleConnections((long) Integer.getInteger(EVICT_IDLE_CONNECTIONS, EVICT_IDLE_CONNECTIONS_DEFAULT), TimeUnit.MILLISECONDS);\n    \n    HttpClientBuilder builder = setupBuilder(newHttpClientBuilder, params);\n    \n    HttpClient httpClient = builder.setConnectionManager(cm).build();\n    \n    assert ObjectReleaseTracker.track(httpClient);\n    return (CloseableHttpClient) httpClient;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"859081acf00749f5dd462772c571d611d4a4d2db":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"56ae3539e829325e80cc0e8d65df4d724cc762d1":["859081acf00749f5dd462772c571d611d4a4d2db","b3a63e635085f13be62c7e0829c70cb104e601b2"],"b3a63e635085f13be62c7e0829c70cb104e601b2":["859081acf00749f5dd462772c571d611d4a4d2db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["859081acf00749f5dd462772c571d611d4a4d2db","56ae3539e829325e80cc0e8d65df4d724cc762d1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["16fa358573e3c2508728b3c7c438a8c19a3f0ae4"],"16fa358573e3c2508728b3c7c438a8c19a3f0ae4":["56ae3539e829325e80cc0e8d65df4d724cc762d1"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","16fa358573e3c2508728b3c7c438a8c19a3f0ae4"]},"commit2Childs":{"859081acf00749f5dd462772c571d611d4a4d2db":["56ae3539e829325e80cc0e8d65df4d724cc762d1","b3a63e635085f13be62c7e0829c70cb104e601b2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"56ae3539e829325e80cc0e8d65df4d724cc762d1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","16fa358573e3c2508728b3c7c438a8c19a3f0ae4"],"b3a63e635085f13be62c7e0829c70cb104e601b2":["56ae3539e829325e80cc0e8d65df4d724cc762d1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["859081acf00749f5dd462772c571d611d4a4d2db"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"16fa358573e3c2508728b3c7c438a8c19a3f0ae4":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","f03e4bed5023ec3ef93a771b8888cae991cf448d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}