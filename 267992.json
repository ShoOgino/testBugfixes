{"path":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,MatchesIteratorSupplier).mjava","commits":[{"id":"657704b225b01c6ff4bada5b6667f1f60aaaad0f","date":1523436207,"type":0,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,MatchesIteratorSupplier).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a Matches for a single field\n   */\n  static Matches forField(String field, MatchesIteratorSupplier mis) throws IOException {\n\n    // The indirection here, using a Supplier object rather than a MatchesIterator\n    // directly, is to allow for multiple calls to Matches.getMatches() to return\n    // new iterators.  We still need to call MatchesIteratorSupplier.get() eagerly\n    // to work out if we have a hit or not.\n\n    MatchesIterator mi = mis.get();\n    if (mi == null) {\n      return null;\n    }\n    return new Matches() {\n      boolean cached = true;\n      @Override\n      public MatchesIterator getMatches(String f) throws IOException {\n        if (Objects.equals(field, f) == false) {\n          return null;\n        }\n        if (cached == false) {\n          return mis.get();\n        }\n        cached = false;\n        return mi;\n      }\n\n      @Override\n      public Iterator<String> iterator() {\n        return Collections.singleton(field).iterator();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,MatchesIteratorSupplier).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a Matches for a single field\n   */\n  static Matches forField(String field, MatchesIteratorSupplier mis) throws IOException {\n\n    // The indirection here, using a Supplier object rather than a MatchesIterator\n    // directly, is to allow for multiple calls to Matches.getMatches() to return\n    // new iterators.  We still need to call MatchesIteratorSupplier.get() eagerly\n    // to work out if we have a hit or not.\n\n    MatchesIterator mi = mis.get();\n    if (mi == null) {\n      return null;\n    }\n    return new Matches() {\n      boolean cached = true;\n      @Override\n      public MatchesIterator getMatches(String f) throws IOException {\n        if (Objects.equals(field, f) == false) {\n          return null;\n        }\n        if (cached == false) {\n          return mis.get();\n        }\n        cached = false;\n        return mi;\n      }\n\n      @Override\n      public Iterator<String> iterator() {\n        return Collections.singleton(field).iterator();\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8","date":1531136112,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,IOSupplier[MatchesIterator]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,MatchesIteratorSupplier).mjava","sourceNew":"  /**\n   * Create a Matches for a single field\n   */\n  static Matches forField(String field, IOSupplier<MatchesIterator> mis) throws IOException {\n\n    // The indirection here, using a Supplier object rather than a MatchesIterator\n    // directly, is to allow for multiple calls to Matches.getMatches() to return\n    // new iterators.  We still need to call MatchesIteratorSupplier.get() eagerly\n    // to work out if we have a hit or not.\n\n    MatchesIterator mi = mis.get();\n    if (mi == null) {\n      return null;\n    }\n    return new Matches() {\n      boolean cached = true;\n      @Override\n      public MatchesIterator getMatches(String f) throws IOException {\n        if (Objects.equals(field, f) == false) {\n          return null;\n        }\n        if (cached == false) {\n          return mis.get();\n        }\n        cached = false;\n        return mi;\n      }\n\n      @Override\n      public Iterator<String> iterator() {\n        return Collections.singleton(field).iterator();\n      }\n    };\n  }\n\n","sourceOld":"  /**\n   * Create a Matches for a single field\n   */\n  static Matches forField(String field, MatchesIteratorSupplier mis) throws IOException {\n\n    // The indirection here, using a Supplier object rather than a MatchesIterator\n    // directly, is to allow for multiple calls to Matches.getMatches() to return\n    // new iterators.  We still need to call MatchesIteratorSupplier.get() eagerly\n    // to work out if we have a hit or not.\n\n    MatchesIterator mi = mis.get();\n    if (mi == null) {\n      return null;\n    }\n    return new Matches() {\n      boolean cached = true;\n      @Override\n      public MatchesIterator getMatches(String f) throws IOException {\n        if (Objects.equals(field, f) == false) {\n          return null;\n        }\n        if (cached == false) {\n          return mis.get();\n        }\n        cached = false;\n        return mi;\n      }\n\n      @Override\n      public Iterator<String> iterator() {\n        return Collections.singleton(field).iterator();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":4,"author":"Michael Braun","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,MatchesIteratorSupplier).mjava","sourceNew":null,"sourceOld":"  /**\n   * Create a Matches for a single field\n   */\n  static Matches forField(String field, MatchesIteratorSupplier mis) throws IOException {\n\n    // The indirection here, using a Supplier object rather than a MatchesIterator\n    // directly, is to allow for multiple calls to Matches.getMatches() to return\n    // new iterators.  We still need to call MatchesIteratorSupplier.get() eagerly\n    // to work out if we have a hit or not.\n\n    MatchesIterator mi = mis.get();\n    if (mi == null) {\n      return null;\n    }\n    return new Matches() {\n      boolean cached = true;\n      @Override\n      public MatchesIterator getMatches(String f) throws IOException {\n        if (Objects.equals(field, f) == false) {\n          return null;\n        }\n        if (cached == false) {\n          return mis.get();\n        }\n        cached = false;\n        return mi;\n      }\n\n      @Override\n      public Iterator<String> iterator() {\n        return Collections.singleton(field).iterator();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":4,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/Matches#forField(String,MatchesIteratorSupplier).mjava","sourceNew":null,"sourceOld":"  /**\n   * Create a Matches for a single field\n   */\n  static Matches forField(String field, MatchesIteratorSupplier mis) throws IOException {\n\n    // The indirection here, using a Supplier object rather than a MatchesIterator\n    // directly, is to allow for multiple calls to Matches.getMatches() to return\n    // new iterators.  We still need to call MatchesIteratorSupplier.get() eagerly\n    // to work out if we have a hit or not.\n\n    MatchesIterator mi = mis.get();\n    if (mi == null) {\n      return null;\n    }\n    return new Matches() {\n      boolean cached = true;\n      @Override\n      public MatchesIterator getMatches(String f) throws IOException {\n        if (Objects.equals(field, f) == false) {\n          return null;\n        }\n        if (cached == false) {\n          return mis.get();\n        }\n        cached = false;\n        return mi;\n      }\n\n      @Override\n      public Iterator<String> iterator() {\n        return Collections.singleton(field).iterator();\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["43345f1452f9510f8aaadae6156fe0c834e7d957","e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"657704b225b01c6ff4bada5b6667f1f60aaaad0f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","657704b225b01c6ff4bada5b6667f1f60aaaad0f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["43345f1452f9510f8aaadae6156fe0c834e7d957","e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["657704b225b01c6ff4bada5b6667f1f60aaaad0f","43345f1452f9510f8aaadae6156fe0c834e7d957"],"657704b225b01c6ff4bada5b6667f1f60aaaad0f":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","e616a7f02f8cf63605f55b89ebae0f1e1cb8e9d8","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}