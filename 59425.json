{"path":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","commits":[{"id":"71b83dcf02fe2854488bc83d70dee29c5baa7e5c","date":1383232808,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = loadPropertiesFile(centralizedVersionsFile);\n    SortedSet<Map.Entry> sortedEntries = new TreeSet<Map.Entry>(new Comparator<Map.Entry>() {\n      @Override public int compare(Map.Entry o1, Map.Entry o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","sourceNew":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = loadPropertiesFile(centralizedVersionsFile);\n    SortedSet<Map.Entry> sortedEntries = new TreeSet<>(new Comparator<Map.Entry>() {\n      @Override public int compare(Map.Entry o1, Map.Entry o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = loadPropertiesFile(centralizedVersionsFile);\n    SortedSet<Map.Entry> sortedEntries = new TreeSet<Map.Entry>(new Comparator<Map.Entry>() {\n      @Override public int compare(Map.Entry o1, Map.Entry o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3e4bd3aed493904d0bbb6c6e0394f619e175087","date":1401446035,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","sourceNew":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = new InterpolatedProperties();\n    try (InputStream inputStream = new FileInputStream(centralizedVersionsFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      versions.load(reader);\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading centralized versions file \" + centralizedVersionsFile.getPath(), e);\n    } \n    SortedSet<Map.Entry> sortedEntries = new TreeSet<>(new Comparator<Map.Entry>() {\n      @Override public int compare(Map.Entry o1, Map.Entry o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = loadPropertiesFile(centralizedVersionsFile);\n    SortedSet<Map.Entry> sortedEntries = new TreeSet<>(new Comparator<Map.Entry>() {\n      @Override public int compare(Map.Entry o1, Map.Entry o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec1a71fbd0f533ceb6c940816637d33e90394dc1","date":1439660103,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","sourceNew":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = new InterpolatedProperties();\n    try (InputStream inputStream = new FileInputStream(centralizedVersionsFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      versions.load(reader);\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading centralized versions file \" + centralizedVersionsFile.getPath(), e);\n    } \n    SortedSet<Map.Entry<?,?>> sortedEntries = new TreeSet<>(new Comparator<Map.Entry<?,?>>() {\n      @Override public int compare(Map.Entry<?,?> o1, Map.Entry<?,?> o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry<?,?> entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = new InterpolatedProperties();\n    try (InputStream inputStream = new FileInputStream(centralizedVersionsFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      versions.load(reader);\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading centralized versions file \" + centralizedVersionsFile.getPath(), e);\n    } \n    SortedSet<Map.Entry> sortedEntries = new TreeSet<>(new Comparator<Map.Entry>() {\n      @Override public int compare(Map.Entry o1, Map.Entry o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e025cf1c07150c8db28879d785db17eb3a66ca9f","date":1598788864,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/tools/src/java/org/apache/lucene/dependencies/GetMavenDependenciesTask#appendAllExternalDependencies(StringBuilder,Map[String,String]).mjava","sourceNew":null,"sourceOld":"  /**\n   * Append each dependency listed in the centralized Ivy versions file\n   * to the grandparent POM's &lt;dependencyManagement&gt; section.  \n   * An &lt;exclusion&gt; is added for each of the artifact's dependencies,\n   * which are collected from the artifact's ivy.xml from the Ivy cache.\n   * \n   * Also add a version property for each dependency.\n   */\n  private void appendAllExternalDependencies(StringBuilder dependenciesBuilder, Map<String,String> versionsMap) {\n    log(\"Loading centralized ivy versions from: \" + centralizedVersionsFile, verboseLevel);\n    ivyCacheDir = getIvyCacheDir();\n    Properties versions = new InterpolatedProperties();\n    try (InputStream inputStream = new FileInputStream(centralizedVersionsFile);\n         Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8)) {\n      versions.load(reader);\n    } catch (IOException e) {\n      throw new BuildException(\"Exception reading centralized versions file \" + centralizedVersionsFile.getPath(), e);\n    } \n    SortedSet<Map.Entry<?,?>> sortedEntries = new TreeSet<>(new Comparator<Map.Entry<?,?>>() {\n      @Override public int compare(Map.Entry<?,?> o1, Map.Entry<?,?> o2) {\n        return ((String)o1.getKey()).compareTo((String)o2.getKey());\n      }\n    });\n    sortedEntries.addAll(versions.entrySet());\n    for (Map.Entry<?,?> entry : sortedEntries) {\n      String key = (String)entry.getKey();\n      Matcher matcher = COORDINATE_KEY_PATTERN.matcher(key);\n      if (matcher.lookingAt()) {\n        String groupId = matcher.group(1);\n        String artifactId = matcher.group(2);\n        String coordinate = groupId + ':' + artifactId;\n        String version = (String)entry.getValue();\n        versionsMap.put(coordinate + \".version\", version);\n        if ( ! nonJarDependencies.contains(coordinate)) {\n          Set<String> classifiers = dependencyClassifiers.get(coordinate);\n          if (null != classifiers) {\n            for (String classifier : classifiers) {\n              Collection<String> exclusions = getTransitiveDependenciesFromIvyCache(groupId, artifactId, version);\n              appendDependencyXml\n                  (dependenciesBuilder, groupId, artifactId, \"      \", version, false, false, classifier, exclusions);\n            }\n          }\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["ec1a71fbd0f533ceb6c940816637d33e90394dc1"],"71b83dcf02fe2854488bc83d70dee29c5baa7e5c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ec1a71fbd0f533ceb6c940816637d33e90394dc1":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e025cf1c07150c8db28879d785db17eb3a66ca9f"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b3e4bd3aed493904d0bbb6c6e0394f619e175087"],"71b83dcf02fe2854488bc83d70dee29c5baa7e5c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"e025cf1c07150c8db28879d785db17eb3a66ca9f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["71b83dcf02fe2854488bc83d70dee29c5baa7e5c"],"ec1a71fbd0f533ceb6c940816637d33e90394dc1":["e025cf1c07150c8db28879d785db17eb3a66ca9f"],"b3e4bd3aed493904d0bbb6c6e0394f619e175087":["ec1a71fbd0f533ceb6c940816637d33e90394dc1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}