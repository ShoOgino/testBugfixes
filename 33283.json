{"path":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","commits":[{"id":"4d3fc88a06a44fc3112186e9be4562b36713955d","date":1497587751,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(Reader,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null) for (String err : errs) cmd.addError(err);\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(Reader reader, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.parse(reader);\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null) for (String err : errs) cmd.addError(err);\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(Reader,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null) for (String err : errs) cmd.addError(err);\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(Reader reader, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.parse(reader);\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n    }\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null) for (String err : errs) cmd.addError(err);\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"/dev/null","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null) for (String err : errs) cmd.addError(err);\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"26de7f978abe868807e55377d3e5837c0a7883d3","date":1516908224,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null) for (String err : errs) cmd.addError(err);\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"060a4475f4072d4ea46bb4ec479dbaf1f207901a","date":1528389530,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\",e);\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":["4d3fc88a06a44fc3112186e9be4562b36713955d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\",e);\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\",e);\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\");\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/api/ApiBag#getCommandOperations(ContentStream,Map[String,JsonSchemaValidator],boolean).mjava","sourceNew":"  @SuppressWarnings({\"rawtypes\"})\n  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\",e);\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","sourceOld":"  public static List<CommandOperation> getCommandOperations(ContentStream stream, Map<String, JsonSchemaValidator> validators, boolean validate) {\n    List<CommandOperation> parsedCommands = null;\n    try {\n      parsedCommands = CommandOperation.readCommands(Collections.singleton(stream), new NamedList());\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unable to parse commands\",e);\n    }\n\n    if (validators == null || !validate) {    // no validation possible because we do not have a spec\n      return parsedCommands;\n    }\n\n    List<CommandOperation> commandsCopy = CommandOperation.clone(parsedCommands);\n\n    for (CommandOperation cmd : commandsCopy) {\n      JsonSchemaValidator validator = validators.get(cmd.name);\n      if (validator == null) {\n        cmd.addError(formatString(\"Unknown operation ''{0}'' available ops are ''{1}''\", cmd.name,\n            validators.keySet()));\n        continue;\n      } else {\n        List<String> errs = validator.validateJson(cmd.getCommandData());\n        if (errs != null){\n          // otherwise swallowed in solrj tests, and just get \"Error in command payload\" in test log\n          // which is quite unhelpful.\n          log.error(\"Command errors for {}:{}\", cmd.name, errs );\n          for (String err : errs) cmd.addError(err);\n        }\n      }\n\n    }\n    List<Map> errs = CommandOperation.captureErrors(commandsCopy);\n    if (!errs.isEmpty()) {\n      throw new ExceptionWithErrObject(SolrException.ErrorCode.BAD_REQUEST, \"Error in command payload\", errs);\n    }\n    return commandsCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"060a4475f4072d4ea46bb4ec479dbaf1f207901a":["26de7f978abe868807e55377d3e5837c0a7883d3"],"4d3fc88a06a44fc3112186e9be4562b36713955d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["26de7f978abe868807e55377d3e5837c0a7883d3","060a4475f4072d4ea46bb4ec479dbaf1f207901a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["060a4475f4072d4ea46bb4ec479dbaf1f207901a"],"26de7f978abe868807e55377d3e5837c0a7883d3":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4d3fc88a06a44fc3112186e9be4562b36713955d"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","4d3fc88a06a44fc3112186e9be4562b36713955d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["26de7f978abe868807e55377d3e5837c0a7883d3","060a4475f4072d4ea46bb4ec479dbaf1f207901a"]},"commit2Childs":{"060a4475f4072d4ea46bb4ec479dbaf1f207901a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","06a8891f085f71282bb3ece1b1732b68f07813a3","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4d3fc88a06a44fc3112186e9be4562b36713955d":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d3fc88a06a44fc3112186e9be4562b36713955d","28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"26de7f978abe868807e55377d3e5837c0a7883d3":["060a4475f4072d4ea46bb4ec479dbaf1f207901a","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"28288370235ed02234a64753cdbf0c6ec096304a":["26de7f978abe868807e55377d3e5837c0a7883d3"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}