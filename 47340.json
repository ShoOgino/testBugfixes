{"path":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","commits":[{"id":"ba67c09b0502c261679c2324acedd77e026ad529","date":1296814792,"type":0,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ) {\n        length += resultToken.length();\n        termAtt.setLength(length);\n        finalOffset = correctOffset(length);\n        offsetAtt.setOffset(correctOffset(0), finalOffset);\n        if( added ){\n          resultToken.setLength(0);\n          resultToken.append(termAtt.buffer(), 0, length);\n        }\n        return added;\n      }\n      added = true;\n      if( c == delimiter ) {\n        if( length > 0 ){\n          endDelimiter = true;\n          break;\n        }\n        else{\n          termAtt.append(replacement);\n          length++;\n        }\n      }\n      else {\n        termAtt.append((char)c);\n        length++;\n      }\n    }\n\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(length);\n    offsetAtt.setOffset(correctOffset(0), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":0,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ) {\n        length += resultToken.length();\n        termAtt.setLength(length);\n        finalOffset = correctOffset(length);\n        offsetAtt.setOffset(correctOffset(0), finalOffset);\n        if( added ){\n          resultToken.setLength(0);\n          resultToken.append(termAtt.buffer(), 0, length);\n        }\n        return added;\n      }\n      added = true;\n      if( c == delimiter ) {\n        if( length > 0 ){\n          endDelimiter = true;\n          break;\n        }\n        else{\n          termAtt.append(replacement);\n          length++;\n        }\n      }\n      else {\n        termAtt.append((char)c);\n        length++;\n      }\n    }\n\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(length);\n    offsetAtt.setOffset(correctOffset(0), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ) {\n        length += resultToken.length();\n        termAtt.setLength(length);\n        finalOffset = correctOffset(length);\n        offsetAtt.setOffset(correctOffset(0), finalOffset);\n        if( added ){\n          resultToken.setLength(0);\n          resultToken.append(termAtt.buffer(), 0, length);\n        }\n        return added;\n      }\n      added = true;\n      if( c == delimiter ) {\n        if( length > 0 ){\n          endDelimiter = true;\n          break;\n        }\n        else{\n          termAtt.append(replacement);\n          length++;\n        }\n      }\n      else {\n        termAtt.append((char)c);\n        length++;\n      }\n    }\n\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(length);\n    offsetAtt.setOffset(correctOffset(0), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eabd392326444185db24d1533c1f69dfbb54fc71","date":1304638205,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ){\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n          finalOffset = correctOffset(startPosition + length);\n          offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          finalOffset = correctOffset(startPosition + length);\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(startPosition + length);\n    offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ) {\n        length += resultToken.length();\n        termAtt.setLength(length);\n        finalOffset = correctOffset(length);\n        offsetAtt.setOffset(correctOffset(0), finalOffset);\n        if( added ){\n          resultToken.setLength(0);\n          resultToken.append(termAtt.buffer(), 0, length);\n        }\n        return added;\n      }\n      added = true;\n      if( c == delimiter ) {\n        if( length > 0 ){\n          endDelimiter = true;\n          break;\n        }\n        else{\n          termAtt.append(replacement);\n          length++;\n        }\n      }\n      else {\n        termAtt.append((char)c);\n        length++;\n      }\n    }\n\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(length);\n    offsetAtt.setOffset(correctOffset(0), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ){\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n          finalOffset = correctOffset(startPosition + length);\n          offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          finalOffset = correctOffset(startPosition + length);\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(startPosition + length);\n    offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ) {\n        length += resultToken.length();\n        termAtt.setLength(length);\n        finalOffset = correctOffset(length);\n        offsetAtt.setOffset(correctOffset(0), finalOffset);\n        if( added ){\n          resultToken.setLength(0);\n          resultToken.append(termAtt.buffer(), 0, length);\n        }\n        return added;\n      }\n      added = true;\n      if( c == delimiter ) {\n        if( length > 0 ){\n          endDelimiter = true;\n          break;\n        }\n        else{\n          termAtt.append(replacement);\n          length++;\n        }\n      }\n      else {\n        termAtt.append((char)c);\n        length++;\n      }\n    }\n\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(length);\n    offsetAtt.setOffset(correctOffset(0), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ){\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n          finalOffset = correctOffset(startPosition + length);\n          offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          finalOffset = correctOffset(startPosition + length);\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(startPosition + length);\n    offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ) {\n        length += resultToken.length();\n        termAtt.setLength(length);\n        finalOffset = correctOffset(length);\n        offsetAtt.setOffset(correctOffset(0), finalOffset);\n        if( added ){\n          resultToken.setLength(0);\n          resultToken.append(termAtt.buffer(), 0, length);\n        }\n        return added;\n      }\n      added = true;\n      if( c == delimiter ) {\n        if( length > 0 ){\n          endDelimiter = true;\n          break;\n        }\n        else{\n          termAtt.append(replacement);\n          length++;\n        }\n      }\n      else {\n        termAtt.append((char)c);\n        length++;\n      }\n    }\n\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(length);\n    offsetAtt.setOffset(correctOffset(0), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a92b21feea3b1b4d7ad5a06439333c4f757318f","date":1333977928,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if (c >= 0) {\n        charsRead++;\n      } else {\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n           offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition + length));\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition+length));\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ){\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n          finalOffset = correctOffset(startPosition + length);\n          offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          finalOffset = correctOffset(startPosition + length);\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(startPosition + length);\n    offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e","date":1334174049,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if (c >= 0) {\n        charsRead++;\n      } else {\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n           offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition + length));\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition+length));\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if( c < 0 ){\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n          finalOffset = correctOffset(startPosition + length);\n          offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          finalOffset = correctOffset(startPosition + length);\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    finalOffset = correctOffset(startPosition + length);\n    offsetAtt.setOffset(correctOffset(startPosition), finalOffset);\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","bugFix":["eabd392326444185db24d1533c1f69dfbb54fc71"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","pathOld":"modules/analysis/common/src/java/org/apache/lucene/analysis/path/PathHierarchyTokenizer#incrementToken().mjava","sourceNew":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if (c >= 0) {\n        charsRead++;\n      } else {\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n           offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition + length));\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition+length));\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","sourceOld":"  @Override\n  public final boolean incrementToken() throws IOException {\n    clearAttributes();\n    termAtt.append( resultToken );\n    if(resultToken.length() == 0){\n      posAtt.setPositionIncrement(1);\n    }\n    else{\n      posAtt.setPositionIncrement(0);\n    }\n    int length = 0;\n    boolean added = false;\n    if( endDelimiter ){\n      termAtt.append(replacement);\n      length++;\n      endDelimiter = false;\n      added = true;\n    }\n\n    while (true) {\n      int c = input.read();\n      if (c >= 0) {\n        charsRead++;\n      } else {\n        if( skipped > skip ) {\n          length += resultToken.length();\n          termAtt.setLength(length);\n           offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition + length));\n          if( added ){\n            resultToken.setLength(0);\n            resultToken.append(termAtt.buffer(), 0, length);\n          }\n          return added;\n        }\n        else{\n          return false;\n        }\n      }\n      if( !added ){\n        added = true;\n        skipped++;\n        if( skipped > skip ){\n          termAtt.append(c == delimiter ? replacement : (char)c);\n          length++;\n        }\n        else {\n          startPosition++;\n        }\n      }\n      else {\n        if( c == delimiter ){\n          if( skipped > skip ){\n            endDelimiter = true;\n            break;\n          }\n          skipped++;\n          if( skipped > skip ){\n            termAtt.append(replacement);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n        else {\n          if( skipped > skip ){\n            termAtt.append((char)c);\n            length++;\n          }\n          else {\n            startPosition++;\n          }\n        }\n      }\n    }\n    length += resultToken.length();\n    termAtt.setLength(length);\n    offsetAtt.setOffset(correctOffset(startPosition), correctOffset(startPosition+length));\n    resultToken.setLength(0);\n    resultToken.append(termAtt.buffer(), 0, length);\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e":["eabd392326444185db24d1533c1f69dfbb54fc71","5a92b21feea3b1b4d7ad5a06439333c4f757318f"],"a3776dccca01c11e7046323cfad46a3b4a471233":["ba67c09b0502c261679c2324acedd77e026ad529","eabd392326444185db24d1533c1f69dfbb54fc71"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba67c09b0502c261679c2324acedd77e026ad529"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ba67c09b0502c261679c2324acedd77e026ad529":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["29ef99d61cda9641b6250bf9567329a6e65f901d","eabd392326444185db24d1533c1f69dfbb54fc71"],"eabd392326444185db24d1533c1f69dfbb54fc71":["ba67c09b0502c261679c2324acedd77e026ad529"],"5a92b21feea3b1b4d7ad5a06439333c4f757318f":["eabd392326444185db24d1533c1f69dfbb54fc71"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ba67c09b0502c261679c2324acedd77e026ad529"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"29ef99d61cda9641b6250bf9567329a6e65f901d":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["29ef99d61cda9641b6250bf9567329a6e65f901d","ba67c09b0502c261679c2324acedd77e026ad529","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"ba67c09b0502c261679c2324acedd77e026ad529":["a3776dccca01c11e7046323cfad46a3b4a471233","29ef99d61cda9641b6250bf9567329a6e65f901d","eabd392326444185db24d1533c1f69dfbb54fc71","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"eabd392326444185db24d1533c1f69dfbb54fc71":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e","a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","5a92b21feea3b1b4d7ad5a06439333c4f757318f"],"5a92b21feea3b1b4d7ad5a06439333c4f757318f":["ad9e3deabce40d9849c1b75ef706bfa79f4f0d1e"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}