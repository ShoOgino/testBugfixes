{"path":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","commits":[{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/src/test-framework/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/index/ThreadedIndexingAndSearchingTestCase#launchIndexingThreads(LineFileDocs,int,long,Set[String],Set[String],List[SubDocs]).mjava","sourceNew":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","sourceOld":"  private Thread[] launchIndexingThreads(final LineFileDocs docs,\n                                         int numThreads,\n                                         final long stopTime,\n                                         final Set<String> delIDs,\n                                         final Set<String> delPackIDs,\n                                         final List<SubDocs> allSubDocs)\n    throws Exception {\n    final Thread[] threads = new Thread[numThreads];\n    for(int thread=0;thread<numThreads;thread++) {\n      threads[thread] = new Thread() {\n          @Override\n          public void run() {\n            // TODO: would be better if this were cross thread, so that we make sure one thread deleting anothers added docs works:\n            final List<String> toDeleteIDs = new ArrayList<String>();\n            final List<SubDocs> toDeleteSubDocs = new ArrayList<SubDocs>();\n            while(System.currentTimeMillis() < stopTime && !failed.get()) {\n              try {\n\n                // Occasional longish pause if running\n                // nightly\n                if (LuceneTestCase.TEST_NIGHTLY && random.nextInt(6) == 3) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": now long sleep\");\n                  }\n                  Thread.sleep(_TestUtil.nextInt(random, 50, 500));\n                }\n\n                // Rate limit ingest rate:\n                if (random.nextInt(7) == 5) {\n                  Thread.sleep(_TestUtil.nextInt(random, 1, 10));\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": done sleep\");\n                  }\n                }\n\n                Document doc = docs.nextDoc();\n                if (doc == null) {\n                  break;\n                }\n\n                // Maybe add randomly named field\n                final String addedField;\n                if (random.nextBoolean()) {\n                  addedField = \"extra\" + random.nextInt(40);\n                  doc.add(newField(addedField, \"a random field\", TextField.TYPE_STORED));\n                } else {\n                  addedField = null;\n                }\n\n                if (random.nextBoolean()) {\n\n                  if (random.nextBoolean()) {\n                    // Add/update doc block:\n                    final String packID;\n                    final SubDocs delSubDocs;\n                    if (toDeleteSubDocs.size() > 0 && random.nextBoolean()) {\n                      delSubDocs = toDeleteSubDocs.get(random.nextInt(toDeleteSubDocs.size()));\n                      assert !delSubDocs.deleted;\n                      toDeleteSubDocs.remove(delSubDocs);\n                      // Update doc block, replacing prior packID\n                      packID = delSubDocs.packID;\n                    } else {\n                      delSubDocs = null;\n                      // Add doc block, using new packID\n                      packID = packCount.getAndIncrement() + \"\";\n                    }\n\n                    final Field packIDField = newField(\"packID\", packID, StringField.TYPE_STORED);\n                    final List<String> docIDs = new ArrayList<String>();\n                    final SubDocs subDocs = new SubDocs(packID, docIDs);\n                    final List<Document> docsList = new ArrayList<Document>();\n\n                    allSubDocs.add(subDocs);\n                    doc.add(packIDField);\n                    docsList.add(_TestUtil.cloneDocument(doc));\n                    docIDs.add(doc.get(\"docid\"));\n\n                    final int maxDocCount = _TestUtil.nextInt(random, 1, 10);\n                    while(docsList.size() < maxDocCount) {\n                      doc = docs.nextDoc();\n                      if (doc == null) {\n                        break;\n                      }\n                      docsList.add(_TestUtil.cloneDocument(doc));\n                      docIDs.add(doc.get(\"docid\"));\n                    }\n                    addCount.addAndGet(docsList.size());\n\n                    final Term packIDTerm = new Term(\"packID\", packID);\n\n                    if (delSubDocs != null) {\n                      delSubDocs.deleted = true;\n                      delIDs.addAll(delSubDocs.subIDs);\n                      delCount.addAndGet(delSubDocs.subIDs.size());\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": update pack packID=\" + delSubDocs.packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      updateDocuments(packIDTerm, docsList);\n                    } else {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": add pack packID=\" + packID + \" count=\" + docsList.size() + \" docs=\" + docIDs);\n                      }\n                      addDocuments(packIDTerm, docsList);\n                    }\n                    doc.removeField(\"packID\");\n\n                    if (random.nextInt(5) == 2) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + packID);\n                      }\n                      toDeleteSubDocs.add(subDocs);\n                    }\n\n                  } else {\n                    // Add single doc\n                    final String docid = doc.get(\"docid\");\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": add doc docid:\" + docid);\n                    }\n                    addDocument(new Term(\"docid\", docid), doc);\n                    addCount.getAndIncrement();\n\n                    if (random.nextInt(5) == 3) {\n                      if (VERBOSE) {\n                        System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                      }\n                      toDeleteIDs.add(docid);\n                    }\n                  }\n                } else {\n\n                  // Update single doc, but we never re-use\n                  // and ID so the delete will never\n                  // actually happen:\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": update doc id:\" + doc.get(\"docid\"));\n                  }\n                  final String docid = doc.get(\"docid\");\n                  updateDocument(new Term(\"docid\", docid), doc);\n                  addCount.getAndIncrement();\n\n                  if (random.nextInt(5) == 3) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": buffer del id:\" + doc.get(\"docid\"));\n                    }\n                    toDeleteIDs.add(docid);\n                  }\n                }\n\n                if (random.nextInt(30) == 17) {\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": apply \" + toDeleteIDs.size() + \" deletes\");\n                  }\n                  for(String id : toDeleteIDs) {\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del term=id:\" + id);\n                    }\n                    deleteDocuments(new Term(\"docid\", id));\n                  }\n                  final int count = delCount.addAndGet(toDeleteIDs.size());\n                  if (VERBOSE) {\n                    System.out.println(Thread.currentThread().getName() + \": tot \" + count + \" deletes\");\n                  }\n                  delIDs.addAll(toDeleteIDs);\n                  toDeleteIDs.clear();\n\n                  for(SubDocs subDocs : toDeleteSubDocs) {\n                    assert !subDocs.deleted;\n                    delPackIDs.add(subDocs.packID);\n                    deleteDocuments(new Term(\"packID\", subDocs.packID));\n                    subDocs.deleted = true;\n                    if (VERBOSE) {\n                      System.out.println(Thread.currentThread().getName() + \": del subs: \" + subDocs.subIDs + \" packID=\" + subDocs.packID);\n                    }\n                    delIDs.addAll(subDocs.subIDs);\n                    delCount.addAndGet(subDocs.subIDs.size());\n                  }\n                  toDeleteSubDocs.clear();\n                }\n                if (addedField != null) {\n                  doc.removeField(addedField);\n                }\n              } catch (Throwable t) {\n                System.out.println(Thread.currentThread().getName() + \": hit exc\");\n                t.printStackTrace();\n                failed.set(true);\n                throw new RuntimeException(t);\n              }\n            }\n            if (VERBOSE) {\n              System.out.println(Thread.currentThread().getName() + \": indexing done\");\n            }\n\n            doAfterIndexingThreadDone();\n          }\n        };\n      threads[thread].setDaemon(true);\n      threads[thread].start();\n    }\n\n    return threads;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"7b91922b55d15444d554721b352861d028eb8278":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["7b91922b55d15444d554721b352861d028eb8278"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7b91922b55d15444d554721b352861d028eb8278":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7b91922b55d15444d554721b352861d028eb8278"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}