{"path":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","commits":[{"id":"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","date":1346692465,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement, String leaderVoteWait)\n      throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n\n    boolean tryAgain = true;\n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        Map<String,ZkNodeProps> shards = slices.getShards();\n        Set<Entry<String,ZkNodeProps>> entrySet = shards.entrySet();\n        int found = 0;\n        tryAgain = false;\n        for (Entry<String,ZkNodeProps> entry : entrySet) {\n          ZkCoreNodeProps props = new ZkCoreNodeProps(entry.getValue());\n          if (props.getState().equals(ZkStateReader.ACTIVE)\n              && zkController.getClusterState().liveNodesContain(\n                  props.getNodeName())) {\n            found++;\n          }\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if ((afterExpiration || !weAreReplacement)\n            && found >= slices.getShards().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else if (!afterExpiration && found >= slices.getShards().size() - 1) {\n          // a previous leader went down - wait for one less than the total\n          // known shards\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\" + slices.getShards().size() + \" found=\" + found + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n  \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          break;\n        }\n      }\n      if (tryAgain) {\n        Thread.sleep(500);\n        slices = zkController.getClusterState().getSlice(collection, shardId);\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement)\n      throws InterruptedException {\n    int retries = 300; // ~ 5 min\n    boolean tryAgain = true;\n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    log.info(\"Running the leader process. afterExperiation=\" + afterExpiration);\n    while (tryAgain || slices == null) {\n      \n      // wait for everyone to be up\n      if (slices != null) {\n        Map<String,ZkNodeProps> shards = slices.getShards();\n        Set<Entry<String,ZkNodeProps>> entrySet = shards.entrySet();\n        int found = 0;\n        tryAgain = false;\n        for (Entry<String,ZkNodeProps> entry : entrySet) {\n          ZkCoreNodeProps props = new ZkCoreNodeProps(entry.getValue());\n          if (props.getState().equals(ZkStateReader.ACTIVE)\n              && zkController.getClusterState().liveNodesContain(\n                  props.getNodeName())) {\n            found++;\n          }\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if ((afterExpiration || !weAreReplacement)\n            && found >= slices.getShards().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          tryAgain = false;\n        } else if (!afterExpiration && found >= slices.getShards().size() - 1) {\n          // a previous leader went down - wait for one less than the total\n          // known shards\n          log.info(\"Enough replicas found to continue.\");\n          tryAgain = false;\n        } else {\n          log.info(\"Waiting until we see more replicas up\");\n        }\n        \n        retries--;\n        if (retries == 0) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          break;\n        }\n      }\n      if (tryAgain) {\n        Thread.sleep(1000);\n        slices = zkController.getClusterState().getSlice(collection, shardId);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement, String leaderVoteWait)\n      throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n\n    boolean tryAgain = true;\n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        Map<String,Replica> shards = slices.getReplicasMap();\n        Set<Entry<String,Replica>> entrySet = shards.entrySet();\n        int found = 0;\n        tryAgain = false;\n        for (Entry<String,Replica> entry : entrySet) {\n          ZkCoreNodeProps props = new ZkCoreNodeProps(entry.getValue());\n          if (props.getState().equals(ZkStateReader.ACTIVE)\n              && zkController.getClusterState().liveNodesContain(\n                  props.getNodeName())) {\n            found++;\n          }\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if ((afterExpiration || !weAreReplacement)\n            && found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else if (!afterExpiration && found >= slices.getReplicasMap().size() - 1) {\n          // a previous leader went down - wait for one less than the total\n          // known shards\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\" + slices.getReplicasMap().size() + \" found=\" + found + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n  \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          break;\n        }\n      }\n      if (tryAgain) {\n        Thread.sleep(500);\n        slices = zkController.getClusterState().getSlice(collection, shardId);\n      }\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement, String leaderVoteWait)\n      throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n\n    boolean tryAgain = true;\n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        Map<String,ZkNodeProps> shards = slices.getShards();\n        Set<Entry<String,ZkNodeProps>> entrySet = shards.entrySet();\n        int found = 0;\n        tryAgain = false;\n        for (Entry<String,ZkNodeProps> entry : entrySet) {\n          ZkCoreNodeProps props = new ZkCoreNodeProps(entry.getValue());\n          if (props.getState().equals(ZkStateReader.ACTIVE)\n              && zkController.getClusterState().liveNodesContain(\n                  props.getNodeName())) {\n            found++;\n          }\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if ((afterExpiration || !weAreReplacement)\n            && found >= slices.getShards().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else if (!afterExpiration && found >= slices.getShards().size() - 1) {\n          // a previous leader went down - wait for one less than the total\n          // known shards\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\" + slices.getShards().size() + \" found=\" + found + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n  \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          break;\n        }\n      }\n      if (tryAgain) {\n        Thread.sleep(500);\n        slices = zkController.getClusterState().getSlice(collection, shardId);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    \n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement, String leaderVoteWait)\n      throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n\n    boolean tryAgain = true;\n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        Map<String,Replica> shards = slices.getReplicasMap();\n        Set<Entry<String,Replica>> entrySet = shards.entrySet();\n        int found = 0;\n        tryAgain = false;\n        for (Entry<String,Replica> entry : entrySet) {\n          ZkCoreNodeProps props = new ZkCoreNodeProps(entry.getValue());\n          if (props.getState().equals(ZkStateReader.ACTIVE)\n              && zkController.getClusterState().liveNodesContain(\n                  props.getNodeName())) {\n            found++;\n          }\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if ((afterExpiration || !weAreReplacement)\n            && found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else if (!afterExpiration && found >= slices.getReplicasMap().size() - 1) {\n          // a previous leader went down - wait for one less than the total\n          // known shards\n          log.info(\"Enough replicas found to continue.\");\n          break;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\" + slices.getReplicasMap().size() + \" found=\" + found + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n  \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          break;\n        }\n      }\n      if (tryAgain) {\n        Thread.sleep(500);\n        slices = zkController.getClusterState().getSlice(collection, shardId);\n      }\n    }\n  }\n\n","bugFix":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6","fa64435b5902ce266c23755a4a00691a3285dab8","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11","344b0840364d990b29b97467bfcc766ff8325d11","344b0840364d990b29b97467bfcc766ff8325d11","344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    \n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    \n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n    }\n  }\n\n","bugFix":null,"bugIntro":["1d44b4a9eb67e68d542dc1ee2674e96f05b56eb0","1d44b4a9eb67e68d542dc1ee2674e96f05b56eb0","1d44b4a9eb67e68d542dc1ee2674e96f05b56eb0","1d44b4a9eb67e68d542dc1ee2674e96f05b56eb0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"673ee468a008722eca2bc9551e16d51f69b93f45","date":1354398680,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    \n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    \n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"709ec1e7204705625cbd074102a6ced459df9c99","date":1361046093,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":["7d307d6a381e7b6f0e272e550d925d41e3c736c4","7d307d6a381e7b6f0e272e550d925d41e3c736c4","7d307d6a381e7b6f0e272e550d925d41e3c736c4","7d307d6a381e7b6f0e272e550d925d41e3c736c4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"95303ff3749680c743b9425f9cf99e6e4065e8a8","date":1361061922,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"446d2d126e2d0a9c63a498d792c4072c820c1e95","date":1363304661,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Errir checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up for shard \" + shardId + \": total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up for shard \" + shardId + \": total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up: total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92a4da96826f502cf1a56a096929b37ce73e523a","date":1374584011,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      int timeout) throws InterruptedException {\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up for shard \" + shardId + \": total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up for shard \" + shardId + \": total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":5,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContext[ElectionContext]#waitForReplicasToComeUp(boolean,String).mjava","sourceNew":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      int timeout) throws InterruptedException {\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up for shard \" + shardId + \": total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","sourceOld":"  private void waitForReplicasToComeUp(boolean weAreReplacement,\n      String leaderVoteWait) throws InterruptedException {\n    int timeout = Integer.parseInt(leaderVoteWait);\n    long timeoutAt = System.currentTimeMillis() + timeout;\n    final String shardsElectZkPath = electionPath + LeaderElector.ELECTION_NODE;\n    \n    Slice slices = zkController.getClusterState().getSlice(collection, shardId);\n    int cnt = 0;\n    while (true && !isClosed && !cc.isShutDown()) {\n      // wait for everyone to be up\n      if (slices != null) {\n        int found = 0;\n        try {\n          found = zkClient.getChildren(shardsElectZkPath, null, true).size();\n        } catch (KeeperException e) {\n          SolrException.log(log,\n              \"Error checking for the number of election participants\", e);\n        }\n        \n        // on startup and after connection timeout, wait for all known shards\n        if (found >= slices.getReplicasMap().size()) {\n          log.info(\"Enough replicas found to continue.\");\n          return;\n        } else {\n          if (cnt % 40 == 0) {\n            log.info(\"Waiting until we see more replicas up for shard \" + shardId + \": total=\"\n              + slices.getReplicasMap().size() + \" found=\" + found\n              + \" timeoutin=\" + (timeoutAt - System.currentTimeMillis()));\n          }\n        }\n        \n        if (System.currentTimeMillis() > timeoutAt) {\n          log.info(\"Was waiting for replicas to come up, but they are taking too long - assuming they won't come back till later\");\n          return;\n        }\n      } else {\n        log.warn(\"Shard not found: \" + shardId + \" for collection \" + collection);\n\n        return;\n\n      }\n      \n      Thread.sleep(500);\n      slices = zkController.getClusterState().getSlice(collection, shardId);\n      // System.out.println(\"###### waitForReplicasToComeUp  : slices=\" + slices + \" all=\" + zkController.getClusterState().getCollectionStates() );\n      cnt++;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["37a0f60745e53927c4c876cfe5b5a58170f0646c","92a4da96826f502cf1a56a096929b37ce73e523a"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["446d2d126e2d0a9c63a498d792c4072c820c1e95","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"fa64435b5902ce266c23755a4a00691a3285dab8":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"92a4da96826f502cf1a56a096929b37ce73e523a":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a6378064655e76cd7b908b1cab4ce425b384b508","673ee468a008722eca2bc9551e16d51f69b93f45"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["446d2d126e2d0a9c63a498d792c4072c820c1e95"],"446d2d126e2d0a9c63a498d792c4072c820c1e95":["709ec1e7204705625cbd074102a6ced459df9c99"],"673ee468a008722eca2bc9551e16d51f69b93f45":["c5a558d54519c651068ddb202f03befefb1514a7"],"a6378064655e76cd7b908b1cab4ce425b384b508":["fa64435b5902ce266c23755a4a00691a3285dab8"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":["673ee468a008722eca2bc9551e16d51f69b93f45","709ec1e7204705625cbd074102a6ced459df9c99"],"c5a558d54519c651068ddb202f03befefb1514a7":["a6378064655e76cd7b908b1cab4ce425b384b508"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"709ec1e7204705625cbd074102a6ced459df9c99":["673ee468a008722eca2bc9551e16d51f69b93f45"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["92a4da96826f502cf1a56a096929b37ce73e523a"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec"],"7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6":["fa64435b5902ce266c23755a4a00691a3285dab8"],"fa64435b5902ce266c23755a4a00691a3285dab8":["a6378064655e76cd7b908b1cab4ce425b384b508"],"92a4da96826f502cf1a56a096929b37ce73e523a":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","92a4da96826f502cf1a56a096929b37ce73e523a"],"446d2d126e2d0a9c63a498d792c4072c820c1e95":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"673ee468a008722eca2bc9551e16d51f69b93f45":["407687e67faf6e1f02a211ca078d8e3eed631027","95303ff3749680c743b9425f9cf99e6e4065e8a8","709ec1e7204705625cbd074102a6ced459df9c99"],"a6378064655e76cd7b908b1cab4ce425b384b508":["407687e67faf6e1f02a211ca078d8e3eed631027","c5a558d54519c651068ddb202f03befefb1514a7"],"95303ff3749680c743b9425f9cf99e6e4065e8a8":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7157fdda82ae1a1cb77b012ef0eb72249ee2f3d6"],"c5a558d54519c651068ddb202f03befefb1514a7":["673ee468a008722eca2bc9551e16d51f69b93f45"],"709ec1e7204705625cbd074102a6ced459df9c99":["446d2d126e2d0a9c63a498d792c4072c820c1e95","95303ff3749680c743b9425f9cf99e6e4065e8a8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","407687e67faf6e1f02a211ca078d8e3eed631027","95303ff3749680c743b9425f9cf99e6e4065e8a8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}