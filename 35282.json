{"path":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"129c6e8ac0c0d9a110ba29e4b5f1889374f30076","date":1337725510,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a2a5e98a45dd6ebebdb91a9ebf1718dbbc065de","date":1337876330,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c95a819869502635864dac0a788f874787e3395b","date":1341394787,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":["06584e6e98d592b34e1329b384182f368d2025e8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a","date":1341524239,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {\n      final int maxDoc = reader.reader.maxDoc();\n      final Bits liveDocs = reader.liveDocs;\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"247f702b944ff0da1ba56a06fc13bd3eeefd2c01","date":1345138682,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d028314cced5858683a1bb4741423d0f934257b","date":1346596535,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        Document doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"52c7e49be259508735752fba88085255014a6ecf","date":1398706273,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3394716f52b34ab259ad5247e7595d9f9db6e935","date":1398791921,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","date":1398844771,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument(int)},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (LeafReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (AtomicReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2131047ecceac64b54ba70feec3d26bbd7e483d7","date":1411862069,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor();\n        storedFieldsReader.visitDocument(docID, visitor);\n        StoredDocument doc = visitor.getDocument();\n        addDocument(doc, mergeState.mergeFieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (LeafReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bb9a29a5e71a90295f175df8919802993142c9a","date":1412517673,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor();\n        storedFieldsReader.visitDocument(docID, visitor);\n        StoredDocument doc = visitor.getDocument();\n        addDocument(doc, mergeState.mergeFieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (LeafReader reader : mergeState.readers) {\n      final int maxDoc = reader.maxDoc();\n      final Bits liveDocs = reader.getLiveDocs();\n      for (int i = 0; i < maxDoc; i++) {\n        if (liveDocs != null && !liveDocs.get(i)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        StoredDocument doc = reader.document(i);\n        addDocument(doc, mergeState.fieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.fieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f756f355450b30d33fe4479d81dad3e4d100ded4","date":1419858140,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        // TODO: this could be more efficient using\n        // FieldVisitor instead of loading/writing entire\n        // doc; ie we just have to renumber the field number\n        // on the fly?\n        // NOTE: it's very important to first assign to doc then pass it to\n        // fieldsWriter.addDocument; see LUCENE-1282\n        DocumentStoredFieldVisitor visitor = new DocumentStoredFieldVisitor();\n        storedFieldsReader.visitDocument(docID, visitor);\n        StoredDocument doc = visitor.getDocument();\n        addDocument(doc, mergeState.mergeFieldInfos);\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n        mergeState.checkAbort.work(300);\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, StorableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], mergeState.liveDocs[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d8200beeffd3fa5155855f4cb8a8a5e38aeff14","date":1462698019,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], mergeState.liveDocs[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    int docCount = 0;\n    for (int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      MergeVisitor visitor = new MergeVisitor(mergeState, i);\n      int maxDoc = mergeState.maxDocs[i];\n      Bits liveDocs = mergeState.liveDocs[i];\n      for (int docID=0;docID<maxDoc;docID++) {\n        if (liveDocs != null && !liveDocs.get(docID)) {\n          // skip deleted docs\n          continue;\n        }\n        startDocument();\n        storedFieldsReader.visitDocument(docID, visitor);\n        finishDocument();\n        docCount++;\n      }\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"653128722fb3b4713ac331c621491a93f34a4a22","date":1479841816,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.segmentInfo.getIndexSort() != null);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d85b6e22926e7564c040d2a864f4887f6c59fa92","date":1482349496,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f03e4bed5023ec3ef93a771b8888cae991cf448d","date":1483469262,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/StoredFieldsWriter#merge(MergeState).mjava","sourceNew":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","sourceOld":"  /** Merges in the stored fields from the readers in \n   *  <code>mergeState</code>. The default implementation skips\n   *  over deleted documents, and uses {@link #startDocument()},\n   *  {@link #writeField(FieldInfo, IndexableField)}, and {@link #finish(FieldInfos, int)},\n   *  returning the number of documents that were written.\n   *  Implementations can override this method for more sophisticated\n   *  merging (bulk-byte copying, etc). */\n  public int merge(MergeState mergeState) throws IOException {\n    List<StoredFieldsMergeSub> subs = new ArrayList<>();\n    for(int i=0;i<mergeState.storedFieldsReaders.length;i++) {\n      StoredFieldsReader storedFieldsReader = mergeState.storedFieldsReaders[i];\n      storedFieldsReader.checkIntegrity();\n      subs.add(new StoredFieldsMergeSub(new MergeVisitor(mergeState, i), mergeState.docMaps[i], storedFieldsReader, mergeState.maxDocs[i]));\n    }\n\n    final DocIDMerger<StoredFieldsMergeSub> docIDMerger = new DocIDMerger<>(subs, mergeState.needsIndexSort);\n\n    int docCount = 0;\n    while (true) {\n      StoredFieldsMergeSub sub = docIDMerger.next();\n      if (sub == null) {\n        break;\n      }\n      assert sub.mappedDocID == docCount;\n      startDocument();\n      sub.reader.visitDocument(sub.docID, sub.visitor);\n      finishDocument();\n      docCount++;\n    }\n    finish(mergeState.mergeFieldInfos, docCount);\n    return docCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c95a819869502635864dac0a788f874787e3395b":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d85b6e22926e7564c040d2a864f4887f6c59fa92":["653128722fb3b4713ac331c621491a93f34a4a22"],"0ad30c6a479e764150a3316e57263319775f1df2":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","3d33e731a93d4b57e662ff094f64f94a745422d4"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","0ad30c6a479e764150a3316e57263319775f1df2"],"1d028314cced5858683a1bb4741423d0f934257b":["c95a819869502635864dac0a788f874787e3395b","247f702b944ff0da1ba56a06fc13bd3eeefd2c01"],"129c6e8ac0c0d9a110ba29e4b5f1889374f30076":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a":["c95a819869502635864dac0a788f874787e3395b"],"9bb9a29a5e71a90295f175df8919802993142c9a":["c9fb5f46e264daf5ba3860defe623a89d202dd87","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":["1d028314cced5858683a1bb4741423d0f934257b","3394716f52b34ab259ad5247e7595d9f9db6e935"],"f756f355450b30d33fe4479d81dad3e4d100ded4":["9bb9a29a5e71a90295f175df8919802993142c9a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","d470c8182e92b264680e34081b75e70a9f2b3c89"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":["727bb765ff2542275f6d31f67be18d7104bae148","d85b6e22926e7564c040d2a864f4887f6c59fa92"],"3394716f52b34ab259ad5247e7595d9f9db6e935":["1d028314cced5858683a1bb4741423d0f934257b","52c7e49be259508735752fba88085255014a6ecf"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","1a2a5e98a45dd6ebebdb91a9ebf1718dbbc065de"],"727bb765ff2542275f6d31f67be18d7104bae148":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","653128722fb3b4713ac331c621491a93f34a4a22"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"1a2a5e98a45dd6ebebdb91a9ebf1718dbbc065de":["129c6e8ac0c0d9a110ba29e4b5f1889374f30076"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","c95a819869502635864dac0a788f874787e3395b"],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"6d8200beeffd3fa5155855f4cb8a8a5e38aeff14":["ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["f756f355450b30d33fe4479d81dad3e4d100ded4"],"247f702b944ff0da1ba56a06fc13bd3eeefd2c01":["33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","6d8200beeffd3fa5155855f4cb8a8a5e38aeff14"],"653128722fb3b4713ac331c621491a93f34a4a22":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"52c7e49be259508735752fba88085255014a6ecf":["1d028314cced5858683a1bb4741423d0f934257b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d85b6e22926e7564c040d2a864f4887f6c59fa92"]},"commit2Childs":{"c95a819869502635864dac0a788f874787e3395b":["1d028314cced5858683a1bb4741423d0f934257b","33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["129c6e8ac0c0d9a110ba29e4b5f1889374f30076","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"d85b6e22926e7564c040d2a864f4887f6c59fa92":["f03e4bed5023ec3ef93a771b8888cae991cf448d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["9bb9a29a5e71a90295f175df8919802993142c9a","2131047ecceac64b54ba70feec3d26bbd7e483d7"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","653128722fb3b4713ac331c621491a93f34a4a22"],"1d028314cced5858683a1bb4741423d0f934257b":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","3394716f52b34ab259ad5247e7595d9f9db6e935","52c7e49be259508735752fba88085255014a6ecf"],"129c6e8ac0c0d9a110ba29e4b5f1889374f30076":["1a2a5e98a45dd6ebebdb91a9ebf1718dbbc065de"],"33e9fa3b49f4a365a04fdfc8a32dbcd0df798f5a":["247f702b944ff0da1ba56a06fc13bd3eeefd2c01"],"9bb9a29a5e71a90295f175df8919802993142c9a":["f756f355450b30d33fe4479d81dad3e4d100ded4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"c0cd85fde84cb318b4dc97710dcf15e2959a1bbe":[],"f756f355450b30d33fe4479d81dad3e4d100ded4":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["727bb765ff2542275f6d31f67be18d7104bae148"],"f03e4bed5023ec3ef93a771b8888cae991cf448d":[],"3394716f52b34ab259ad5247e7595d9f9db6e935":["c9fb5f46e264daf5ba3860defe623a89d202dd87","c0cd85fde84cb318b4dc97710dcf15e2959a1bbe"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["c95a819869502635864dac0a788f874787e3395b","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"727bb765ff2542275f6d31f67be18d7104bae148":["f03e4bed5023ec3ef93a771b8888cae991cf448d"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["6d8200beeffd3fa5155855f4cb8a8a5e38aeff14"],"1a2a5e98a45dd6ebebdb91a9ebf1718dbbc065de":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"2131047ecceac64b54ba70feec3d26bbd7e483d7":["9bb9a29a5e71a90295f175df8919802993142c9a"],"6d8200beeffd3fa5155855f4cb8a8a5e38aeff14":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"247f702b944ff0da1ba56a06fc13bd3eeefd2c01":["1d028314cced5858683a1bb4741423d0f934257b"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"653128722fb3b4713ac331c621491a93f34a4a22":["d85b6e22926e7564c040d2a864f4887f6c59fa92","727bb765ff2542275f6d31f67be18d7104bae148"],"52c7e49be259508735752fba88085255014a6ecf":["3394716f52b34ab259ad5247e7595d9f9db6e935"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c0cd85fde84cb318b4dc97710dcf15e2959a1bbe","f03e4bed5023ec3ef93a771b8888cae991cf448d","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}