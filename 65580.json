{"path":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/src/test-framework/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8","date":1328775259,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = ReaderUtil.leaves(s.getTopReaderContext());\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ceb5bb30e401cb218b31197b1a9aa47e77cda17","date":1336330521,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","date":1340090669,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final AtomicReaderContext[] readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray[leafPtr];\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray[leafPtr].reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":["e69f59b863731d864bf3047235e718f0f88f8841"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) throws IOException {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"211b1506e56f7860762fbd4698f6d1d1b57f672c","date":1344976996,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getTopReaderContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e18c86f811939bfa8cd24046c96ed026f2e9b34","date":1393893071,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54e3893378c69acef0a7c85bd25c43aeea3249c4","date":1394442120,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","date":1394564625,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"acf00221f44c5f08ccea014f2492b53af15ecd66","date":1394568293,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, true, false, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, true, false, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae73da626f97850c922c42736f808d0378e165f0","date":1396625460,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new Collector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c9fb5f46e264daf5ba3860defe623a89d202dd87","date":1411516315,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<AtomicReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final AtomicReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                AtomicReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(AtomicReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final AtomicReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              AtomicReaderContext ctx = (AtomicReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final AtomicReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          AtomicReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f","date":1421314520,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n    if (s.createNormalizedWeight(q).scoresDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n\n          @Override\n          public boolean acceptsDocsOutOfOrder() {\n            return false;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"781239fc84d36be12b84e4d3e2618f5f07a182e3","date":1423139668,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs(), true);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs(), true);\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs(), true);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":["2e18c86f811939bfa8cd24046c96ed026f2e9b34"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb17639909a369c1e64866842e5c213440acc17e","date":1423238093,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs(), true);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs(), true);\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs(), true);\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"954e59be3da8dc1b046646ad7af4b466852009d3","date":1423482367,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6a47d642ab24da1a811adce4bda9cc52c520ca13","date":1423483323,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, PostingsEnum.FLAG_FREQS);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b52f4d438f568f7beafda3cf347790a4bfe32928","date":1425545677,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":["f5d8d97303550346f85fd577f90d64cf196cebd1","492d71f81abcc186afa0074702472ecb6b7dc997"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but skipTo(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45fa1757f5581a10e9c63294cf292a14c92d23b1","date":1430234127,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n              if (!more || doc != scorerDoc || scoreDiff > maxDiff\n                  || scorerDiff > maxDiff) {\n                StringBuilder sbord = new StringBuilder();\n                for (int i = 0; i < order.length; i++)\n                  sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                throw new RuntimeException(\"ERROR matching docs:\" + \"\\n\\t\"\n                    + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                    + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                    + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                    + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                    + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                    + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                    + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                    + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                    + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                    + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                    + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                    + (op == skip_op ? \" skip()\" : \" next()\"));\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":["131a9e895609b4da33662dc087e0bc6303e1e29c","e69f59b863731d864bf3047235e718f0f88f8841","4625cb7ffd7c9caaf2d62b206ba9a382d68da82c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"485545da3b4429d6f138b4baac573a97820ee93b","date":1433876557,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context, context.reader().getLiveDocs());\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n              if (scorer != null) {\n                boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx, ctx.reader().getLiveDocs());\n          if (scorer != null) {\n            boolean more = scorer.advance(lastDoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS;\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? scorer.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = scorer.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = scorer.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","date":1457644139,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":["790e1fde4caa765b3faaad3fbcd25c6973450336"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e7bc21595222ae4f75509300fbb7726691f387f","date":1464078795,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n              \n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, true);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public boolean needsScores() {\n            return true;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, true);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, true);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68d6cb7f0f019661a784bd0e5a21e85b5f812af6","date":1515075216,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity(true));\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity(true));\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"475584d5e08a22ad3fc7babefe006d77bc744567","date":1523282824,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Query rewritten = s.rewrite(q);\n                Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Query rewritten = indexSearcher.rewrite(q);\n              Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Query rewritten = indexSearcher.rewrite(q);\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d58e44159788900f4a2113b84463dc3fbbf80f20","date":1523319203,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Query rewritten = s.rewrite(q);\n                Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Query rewritten = indexSearcher.rewrite(q);\n              Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Query rewritten = indexSearcher.rewrite(q);\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Weight w = s.createNormalizedWeight(q, ScoreMode.COMPLETE);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Weight w = indexSearcher.createNormalizedWeight(q, ScoreMode.COMPLETE);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"285244982ce6aa163d1e60a707f0e6e121736ce5","date":1536055304,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorable sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Query rewritten = s.rewrite(q);\n                Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Query rewritten = indexSearcher.rewrite(q);\n              Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Query rewritten = indexSearcher.rewrite(q);\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorer sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorer scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Query rewritten = s.rewrite(q);\n                Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Query rewritten = indexSearcher.rewrite(q);\n              Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Query rewritten = indexSearcher.rewrite(q);\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/QueryUtils#checkSkipTo(Query,IndexSearcher).mjava","sourceNew":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorable sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Query rewritten = s.rewrite(q);\n                Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Query rewritten = indexSearcher.rewrite(q);\n              Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Query rewritten = indexSearcher.rewrite(q);\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","sourceOld":"  /** alternate scorer advance(),advance(),next(),next(),advance(),advance(), etc\n   * and ensure a hitcollector receives same docs and scores\n   */\n  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {\n    //System.out.println(\"Checking \"+q);\n    final List<LeafReaderContext> readerContextArray = s.getTopReaderContext().leaves();\n\n    final int skip_op = 0;\n    final int next_op = 1;\n    final int orders [][] = {\n        {next_op},\n        {skip_op},\n        {skip_op, next_op},\n        {next_op, skip_op},\n        {skip_op, skip_op, next_op, next_op},\n        {next_op, next_op, skip_op, skip_op},\n        {skip_op, skip_op, skip_op, next_op, next_op},\n    };\n    for (int k = 0; k < orders.length; k++) {\n\n        final int order[] = orders[k];\n        // System.out.print(\"Order:\");for (int i = 0; i < order.length; i++)\n        // System.out.print(order[i]==skip_op ? \" skip()\":\" next()\");\n        // System.out.println();\n        final int opidx[] = { 0 };\n        final int lastDoc[] = {-1};\n\n        // FUTURE: ensure scorer.doc()==-1\n\n        final float maxDiff = 1e-5f;\n        final LeafReader lastReader[] = {null};\n\n        s.search(q, new SimpleCollector() {\n          private Scorable sc;\n          private Scorer scorer;\n          private DocIdSetIterator iterator;\n          private int leafPtr;\n\n          @Override\n          public void setScorer(Scorable scorer) {\n            this.sc = scorer;\n          }\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = sc.score();\n            lastDoc[0] = doc;\n            try {\n              if (scorer == null) {\n                Query rewritten = s.rewrite(q);\n                Weight w = s.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n                LeafReaderContext context = readerContextArray.get(leafPtr);\n                scorer = w.scorer(context);\n                iterator = scorer.iterator();\n              }\n\n              int op = order[(opidx[0]++) % order.length];\n              // System.out.println(op==skip_op ?\n              // \"skip(\"+(sdoc[0]+1)+\")\":\"next()\");\n              boolean more = op == skip_op ? iterator.advance(scorer.docID() + 1) != DocIdSetIterator.NO_MORE_DOCS\n                  : iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;\n              int scorerDoc = scorer.docID();\n              float scorerScore = scorer.score();\n              float scorerScore2 = scorer.score();\n              float scoreDiff = Math.abs(score - scorerScore);\n              float scorerDiff = Math.abs(scorerScore2 - scorerScore);\n\n              boolean success = false;\n              try {\n                assertTrue(more);\n                assertEquals(\"scorerDoc=\" + scorerDoc + \",doc=\" + doc, scorerDoc, doc);\n                assertTrue(\"score=\" + score + \", scorerScore=\" + scorerScore, scoreDiff <= maxDiff);\n                assertTrue(\"scorerScorer=\" + scorerScore + \", scorerScore2=\" + scorerScore2, scorerDiff <= maxDiff);\n                success = true;\n              } finally {\n                if (!success) {\n                  if (LuceneTestCase.VERBOSE) {\n                    StringBuilder sbord = new StringBuilder();\n                    for (int i = 0; i < order.length; i++) {\n                      sbord.append(order[i] == skip_op ? \" skip()\" : \" next()\");\n                    }\n                    System.out.println(\"ERROR matching docs:\" + \"\\n\\t\"\n                        + (doc != scorerDoc ? \"--> \" : \"\") + \"doc=\" + doc + \", scorerDoc=\" + scorerDoc\n                        + \"\\n\\t\" + (!more ? \"--> \" : \"\") + \"tscorer.more=\" + more\n                        + \"\\n\\t\" + (scoreDiff > maxDiff ? \"--> \" : \"\")\n                        + \"scorerScore=\" + scorerScore + \" scoreDiff=\" + scoreDiff\n                        + \" maxDiff=\" + maxDiff + \"\\n\\t\"\n                        + (scorerDiff > maxDiff ? \"--> \" : \"\") + \"scorerScore2=\"\n                        + scorerScore2 + \" scorerDiff=\" + scorerDiff\n                        + \"\\n\\thitCollector.doc=\" + doc + \" score=\" + score\n                        + \"\\n\\t Scorer=\" + scorer + \"\\n\\t Query=\" + q + \"  \"\n                        + q.getClass().getName() + \"\\n\\t Searcher=\" + s\n                        + \"\\n\\t Order=\" + sbord + \"\\n\\t Op=\"\n                        + (op == skip_op ? \" skip()\" : \" next()\"));\n                  }\n                }\n              }\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n\n          @Override\n          public ScoreMode scoreMode() {\n            return ScoreMode.COMPLETE;\n          }\n\n          @Override\n          protected void doSetNextReader(LeafReaderContext context) throws IOException {\n            // confirm that skipping beyond the last doc, on the\n            // previous reader, hits NO_MORE_DOCS\n            if (lastReader[0] != null) {\n              final LeafReader previousReader = lastReader[0];\n              IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n              indexSearcher.setSimilarity(s.getSimilarity());\n              Query rewritten = indexSearcher.rewrite(q);\n              Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n              LeafReaderContext ctx = (LeafReaderContext)indexSearcher.getTopReaderContext();\n              Scorer scorer = w.scorer(ctx);\n              if (scorer != null) {\n                DocIdSetIterator iterator = scorer.iterator();\n                boolean more = false;\n                final Bits liveDocs = context.reader().getLiveDocs();\n                for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n                  if (liveDocs == null || liveDocs.get(d)) {\n                    more = true;\n                    break;\n                  }\n                }\n                Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n              }\n              leafPtr++;\n            }\n            lastReader[0] = context.reader();\n            assert readerContextArray.get(leafPtr).reader() == context.reader();\n            this.scorer = null;\n            lastDoc[0] = -1;\n          }\n        });\n\n        if (lastReader[0] != null) {\n          // confirm that skipping beyond the last doc, on the\n          // previous reader, hits NO_MORE_DOCS\n          final LeafReader previousReader = lastReader[0];\n          IndexSearcher indexSearcher = LuceneTestCase.newSearcher(previousReader, false);\n          indexSearcher.setSimilarity(s.getSimilarity());\n          Query rewritten = indexSearcher.rewrite(q);\n          Weight w = indexSearcher.createWeight(rewritten, ScoreMode.COMPLETE, 1);\n          LeafReaderContext ctx = previousReader.getContext();\n          Scorer scorer = w.scorer(ctx);\n          if (scorer != null) {\n            DocIdSetIterator iterator = scorer.iterator();\n            boolean more = false;\n            final Bits liveDocs = lastReader[0].getLiveDocs();\n            for (int d = iterator.advance(lastDoc[0] + 1); d != DocIdSetIterator.NO_MORE_DOCS; d = iterator.nextDoc()) {\n              if (liveDocs == null || liveDocs.get(d)) {\n                more = true;\n                break;\n              }\n            }\n            Assert.assertFalse(\"query's last doc was \"+ lastDoc[0] +\" but advance(\"+(lastDoc[0]+1)+\") got to \"+scorer.docID(),more);\n          }\n        }\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["954e59be3da8dc1b046646ad7af4b466852009d3"],"fb17639909a369c1e64866842e5c213440acc17e":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"b94236357aaa22b76c10629851fe4e376e0cea82":["417142ff08fda9cf0b72d5133e63097a166c6458","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"475584d5e08a22ad3fc7babefe006d77bc744567":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0ceb5bb30e401cb218b31197b1a9aa47e77cda17":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":["2e18c86f811939bfa8cd24046c96ed026f2e9b34","54e3893378c69acef0a7c85bd25c43aeea3249c4"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["fe33227f6805edab2036cbb80645cc4e2d1fa424","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"485545da3b4429d6f138b4baac573a97820ee93b":["45fa1757f5581a10e9c63294cf292a14c92d23b1"],"45fa1757f5581a10e9c63294cf292a14c92d23b1":["b52f4d438f568f7beafda3cf347790a4bfe32928"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["ae73da626f97850c922c42736f808d0378e165f0"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["b94236357aaa22b76c10629851fe4e376e0cea82","475584d5e08a22ad3fc7babefe006d77bc744567"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["6a47d642ab24da1a811adce4bda9cc52c520ca13","b52f4d438f568f7beafda3cf347790a4bfe32928"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["acf00221f44c5f08ccea014f2492b53af15ecd66","ae73da626f97850c922c42736f808d0378e165f0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["0e7bc21595222ae4f75509300fbb7726691f387f"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["0ceb5bb30e401cb218b31197b1a9aa47e77cda17"],"54e3893378c69acef0a7c85bd25c43aeea3249c4":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"954e59be3da8dc1b046646ad7af4b466852009d3":["fb17639909a369c1e64866842e5c213440acc17e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1","0e7bc21595222ae4f75509300fbb7726691f387f"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0e7bc21595222ae4f75509300fbb7726691f387f","9fc47cb7b4346802411bb432f501ed0673d7119e"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["417142ff08fda9cf0b72d5133e63097a166c6458"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["485545da3b4429d6f138b4baac573a97820ee93b"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["c9fb5f46e264daf5ba3860defe623a89d202dd87"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"0e7bc21595222ae4f75509300fbb7726691f387f":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"ae73da626f97850c922c42736f808d0378e165f0":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["54e3893378c69acef0a7c85bd25c43aeea3249c4","a58bbbe1c866963764d3f15d3a26a6a85f6c6af4"],"b52f4d438f568f7beafda3cf347790a4bfe32928":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"6a47d642ab24da1a811adce4bda9cc52c520ca13":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","b52f4d438f568f7beafda3cf347790a4bfe32928"],"fb17639909a369c1e64866842e5c213440acc17e":["954e59be3da8dc1b046646ad7af4b466852009d3"],"b94236357aaa22b76c10629851fe4e376e0cea82":["475584d5e08a22ad3fc7babefe006d77bc744567","d58e44159788900f4a2113b84463dc3fbbf80f20"],"475584d5e08a22ad3fc7babefe006d77bc744567":["d58e44159788900f4a2113b84463dc3fbbf80f20"],"0ceb5bb30e401cb218b31197b1a9aa47e77cda17":["4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c"],"a58bbbe1c866963764d3f15d3a26a6a85f6c6af4":["acf00221f44c5f08ccea014f2492b53af15ecd66"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8"],"485545da3b4429d6f138b4baac573a97820ee93b":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"45fa1757f5581a10e9c63294cf292a14c92d23b1":["485545da3b4429d6f138b4baac573a97820ee93b"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"c9fb5f46e264daf5ba3860defe623a89d202dd87":["f582f18c13d4852b01d4fe0a0196432c5c6f2b7f"],"0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","0e7bc21595222ae4f75509300fbb7726691f387f"],"d58e44159788900f4a2113b84463dc3fbbf80f20":["285244982ce6aa163d1e60a707f0e6e121736ce5"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","211b1506e56f7860762fbd4698f6d1d1b57f672c","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"2e18c86f811939bfa8cd24046c96ed026f2e9b34":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4"],"781239fc84d36be12b84e4d3e2618f5f07a182e3":["fb17639909a369c1e64866842e5c213440acc17e"],"4c5ae929ce8aa0c4856f0d6bfd4c196bc2d3eb9c":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"54e3893378c69acef0a7c85bd25c43aeea3249c4":["a58bbbe1c866963764d3f15d3a26a6a85f6c6af4","acf00221f44c5f08ccea014f2492b53af15ecd66"],"0d4602ca2700dfd2f6159ad1499e5b6d1f3b92a8":["0ceb5bb30e401cb218b31197b1a9aa47e77cda17"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","2e18c86f811939bfa8cd24046c96ed026f2e9b34","54e3893378c69acef0a7c85bd25c43aeea3249c4"],"954e59be3da8dc1b046646ad7af4b466852009d3":["6a47d642ab24da1a811adce4bda9cc52c520ca13"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"417142ff08fda9cf0b72d5133e63097a166c6458":["b94236357aaa22b76c10629851fe4e376e0cea82","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"285244982ce6aa163d1e60a707f0e6e121736ce5":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"f582f18c13d4852b01d4fe0a0196432c5c6f2b7f":["781239fc84d36be12b84e4d3e2618f5f07a182e3"],"ae73da626f97850c922c42736f808d0378e165f0":["c9fb5f46e264daf5ba3860defe623a89d202dd87","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"0e7bc21595222ae4f75509300fbb7726691f387f":["9fc47cb7b4346802411bb432f501ed0673d7119e","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","417142ff08fda9cf0b72d5133e63097a166c6458"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["0bdb67d0b49ddf963c3bfc4975fce171ad3aacb1"],"acf00221f44c5f08ccea014f2492b53af15ecd66":["15e323346eac5e4685c0a9f2df85eb96b4239bbb","ae73da626f97850c922c42736f808d0378e165f0"],"b52f4d438f568f7beafda3cf347790a4bfe32928":["45fa1757f5581a10e9c63294cf292a14c92d23b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","15e323346eac5e4685c0a9f2df85eb96b4239bbb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}