{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","commits":[{"id":"00ec2a9d45723405cf333adce768d97877bc24a6","date":1464821414,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n    \n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          int actualThreadID = (int) docValues.get(id);\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","date":1464821470,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n    \n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          int actualThreadID = (int) docValues.get(id);\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19d35c01593b75b98b751866e41b1b24983ff42e","date":1464861489,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(id);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n    \n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n                                  \n        if (expectedThreadIDs[id] != -1) {\n          assertEquals(1, hits.totalHits);\n          int actualThreadID = (int) docValues.get(id);\n          if (expectedThreadIDs[id] != actualThreadID) {\n            System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n            for(int threadID=0;threadID<threadOps.size();threadID++) {\n              for(Operation op : threadOps.get(threadID)) {\n                if (id == op.id) {\n                  System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"deleted\"));\n                }\n              }\n            }\n            assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n          }\n        } else if (hits.totalHits != 0) {\n          System.out.println(\"FAIL: id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs totalHits=\" + hits.totalHits + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo + \" \" + (op.what == 2 ? \"updated\" : \"del\"));\n              }\n            }\n          }\n          assertEquals(0, hits.totalHits);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3246b951f8c3c2cda6e42d6cf58af30b8100c73","date":1465063897,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            if (op.what == 0) {\n              expectedThreadIDs[op.id] = threadID;\n            }\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(id);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads);\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dea8da13fd1a227ae1071e8f4ce66bff42174de","date":1471439735,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652c74b2358a0b13223817a6a793bf1c9d0749d","date":1474465301,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n      NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int actualThreadID = (int) docValues.get(hits.scoreDocs[0].doc);\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"/dev/null","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits.value);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f","date":1579652839,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexingSequenceNumbers#testStressConcurrentDocValuesUpdatesCommit().mjava","sourceNew":"  @Nightly\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits.value);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","sourceOld":"  @Slow\n  public void testStressConcurrentDocValuesUpdatesCommit() throws Exception {\n    final int opCount = atLeast(10000);\n    final int idCount = TestUtil.nextInt(random(), 10, 1000);\n\n    Directory dir = newDirectory();\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    iwc.setIndexDeletionPolicy(NoDeletionPolicy.INSTANCE);\n\n    // Cannot use RIW since it randomly commits:\n    final IndexWriter w = new IndexWriter(dir, iwc);\n\n    final int numThreads = TestUtil.nextInt(random(), 2, 10);\n    if (VERBOSE) {\n      System.out.println(\"TEST: numThreads=\" + numThreads);\n    }\n    Thread[] threads = new Thread[numThreads];\n    //System.out.println(\"TEST: iter=\" + iter + \" opCount=\" + opCount + \" idCount=\" + idCount + \" threadCount=\" + threads.length);\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    List<List<Operation>> threadOps = new ArrayList<>();\n\n    Object commitLock = new Object();\n    final List<Operation> commits = new ArrayList<>();\n\n    List<Operation> ops1 = new ArrayList<>();\n    threadOps.add(ops1);\n\n    // pre-index every ID so none are missing:\n    for(int id=0;id<idCount;id++) {\n      int threadID = 0;\n      Operation op = new Operation();\n      op.threadID = threadID;\n      op.id = id;\n\n      Document doc = new Document();\n      doc.add(new StoredField(\"thread\", threadID));\n      doc.add(new NumericDocValuesField(\"thread\", threadID));\n      doc.add(new StringField(\"id\", \"\" + id, Field.Store.NO));\n      op.seqNo = w.addDocument(doc);\n      ops1.add(op);\n    }\n\n    // multiple threads update the same set of documents, and we randomly commit, recording the commit seqNo and then opening each commit in\n    // the end to verify it reflects the correct updates\n    for(int i=0;i<threads.length;i++) {\n      final List<Operation> ops;\n      if (i == 0) {\n        ops = threadOps.get(0);\n      } else {\n        ops = new ArrayList<>();\n        threadOps.add(ops);\n      }\n\n      final int threadID = i;\n      threads[i] = new Thread() {\n          @Override\n          public void run() {\n            try {\n              startingGun.await();\n              for(int i=0;i<opCount;i++) {\n                Operation op = new Operation();\n                op.threadID = threadID;\n                if (random().nextInt(500) == 17) {\n                  op.what = 2;\n                  synchronized(commitLock) {\n                    op.seqNo = w.commit();\n                    if (op.seqNo != -1) {\n                      commits.add(op);\n                    }\n                  }\n                } else {\n                  op.id = random().nextInt(idCount);\n                  Term idTerm = new Term(\"id\", \"\" + op.id);\n                  op.seqNo = w.updateNumericDocValue(idTerm, \"thread\", threadID);\n                  op.what = 0;\n                  ops.add(op);\n                }\n              }\n            } catch (Exception e) {\n              throw new RuntimeException(e);\n            }\n          }\n        };\n      threads[i].setName(\"thread\" + i);\n      threads[i].start();\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n\n    Operation commitOp = new Operation();\n    commitOp.seqNo = w.commit();\n    if (commitOp.seqNo != -1) {\n      commits.add(commitOp);\n    }\n\n    List<IndexCommit> indexCommits = DirectoryReader.listCommits(dir);\n    assertEquals(commits.size(), indexCommits.size());\n\n    int[] expectedThreadIDs = new int[idCount];\n    long[] seqNos = new long[idCount];\n      \n    //System.out.println(\"TEST: \" + commits.size() + \" commits\");\n    for(int i=0;i<commits.size();i++) {\n      // this commit point should reflect all operations <= this seqNo\n      long commitSeqNo = commits.get(i).seqNo;\n      //System.out.println(\"  commit \" + i + \": seqNo=\" + commitSeqNo + \" segs=\" + indexCommits.get(i));\n\n      Arrays.fill(expectedThreadIDs, -1);\n      Arrays.fill(seqNos, 0);\n\n      for(int threadID=0;threadID<threadOps.size();threadID++) {\n        long lastSeqNo = 0;\n        for(Operation op : threadOps.get(threadID)) {\n          if (op.seqNo <= commitSeqNo && op.seqNo > seqNos[op.id]) {\n            seqNos[op.id] = op.seqNo;\n            assert op.what == 0;\n            expectedThreadIDs[op.id] = threadID;\n          }\n\n          assertTrue(op.seqNo > lastSeqNo);\n          lastSeqNo = op.seqNo;\n        }\n      }\n\n      DirectoryReader r = DirectoryReader.open(indexCommits.get(i));\n      IndexSearcher s = new IndexSearcher(r);\n\n      for(int id=0;id<idCount;id++) {\n        //System.out.println(\"TEST: check id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id]);\n        TopDocs hits = s.search(new TermQuery(new Term(\"id\", \"\"+id)), 1);\n        NumericDocValues docValues = MultiDocValues.getNumericValues(r, \"thread\");\n\n        // We pre-add all ids up front:\n        assert expectedThreadIDs[id] != -1;\n        assertEquals(1, hits.totalHits.value);\n        int hitDoc = hits.scoreDocs[0].doc;\n        assertEquals(hitDoc, docValues.advance(hitDoc));\n        int actualThreadID = (int) docValues.longValue();\n        if (expectedThreadIDs[id] != actualThreadID) {\n          System.out.println(\"FAIL: commit=\" + i + \" (of \" + commits.size() + \") id=\" + id + \" expectedThreadID=\" + expectedThreadIDs[id] + \" vs actualThreadID=\" + actualThreadID + \" commitSeqNo=\" + commitSeqNo + \" numThreads=\" + numThreads + \" reader=\" + r + \" commit=\" + indexCommits.get(i));\n          for(int threadID=0;threadID<threadOps.size();threadID++) {\n            for(Operation op : threadOps.get(threadID)) {\n              if (id == op.id) {\n                System.out.println(\"  threadID=\" + threadID + \" seqNo=\" + op.seqNo);\n              }\n            }\n          }\n          assertEquals(\"id=\" + id + \" docID=\" + hits.scoreDocs[0].doc, expectedThreadIDs[id], actualThreadID);\n        }\n      }\n      w.close();\n      r.close();\n    }\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"00ec2a9d45723405cf333adce768d97877bc24a6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["191128ac5b85671b1671e2c857437694283b6ebf","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"6483e4260c08168709c02238ae083a51519a28dd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b3246b951f8c3c2cda6e42d6cf58af30b8100c73"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["191128ac5b85671b1671e2c857437694283b6ebf","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"191128ac5b85671b1671e2c857437694283b6ebf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6483e4260c08168709c02238ae083a51519a28dd"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["191128ac5b85671b1671e2c857437694283b6ebf"],"19d35c01593b75b98b751866e41b1b24983ff42e":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","00ec2a9d45723405cf333adce768d97877bc24a6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"b3246b951f8c3c2cda6e42d6cf58af30b8100c73":["19d35c01593b75b98b751866e41b1b24983ff42e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"]},"commit2Childs":{"00ec2a9d45723405cf333adce768d97877bc24a6":["b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77"],"fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","6652c74b2358a0b13223817a6a793bf1c9d0749d"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["403d05f7f8d69b65659157eff1bc1d2717f04c66","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","9dea8da13fd1a227ae1071e8f4ce66bff42174de"],"9dea8da13fd1a227ae1071e8f4ce66bff42174de":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"19d35c01593b75b98b751866e41b1b24983ff42e":["b3246b951f8c3c2cda6e42d6cf58af30b8100c73"],"b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77":["19d35c01593b75b98b751866e41b1b24983ff42e"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"b3246b951f8c3c2cda6e42d6cf58af30b8100c73":["6483e4260c08168709c02238ae083a51519a28dd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["00ec2a9d45723405cf333adce768d97877bc24a6","6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","b40b1a0adcc6bdcda63b0fbd75dfa2ddd8777e77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","83788ad129a5154d5c6562c4e8ce3db48793aada"],"6652c74b2358a0b13223817a6a793bf1c9d0749d":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fc1e9ddca40a3ddf8b097f2cf1fe2547fe8e384f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}