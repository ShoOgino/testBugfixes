{"path":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","commits":[{"id":"4522ffca5a1f420c6a02198c9332d7c596a30ca5","date":1457270822,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    writeField(fieldInfo,\n               new PointReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   for (int i=0;i<mergeState.pointReaders.length;i++) {\n                     PointReader pointReader = mergeState.pointReaders[i];\n                     if (pointReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointReader.intersect(fieldInfo.name,\n                                                 new IntersectVisitor() {\n                                                   @Override\n                                                   public void visit(int docID) {\n                                                     // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                     throw new IllegalStateException();\n                                                   }\n\n                                                   @Override\n                                                   public void visit(int docID, byte[] packedValue) throws IOException {\n                                                     int newDocID = docMap.get(docID);\n                                                     if (newDocID != -1) {\n                                                       // Not deleted:\n                                                       mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                     }\n                                                   }\n\n                                                   @Override\n                                                   public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                     // Forces this segment's PointReader to always visit all docs + values:\n                                                     return Relation.CELL_CROSSES_QUERY;\n                                                   }\n                                                 });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da1c100e0e15178d145d7c3c8f38f3e553b92c12","date":1457461708,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca","date":1457777566,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"416f9e28900210be57b69bc12e2954fb98ed7ebe","date":1458479803,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ceaef6cfc68c8ab22a684192e469a8280f9e6e70","date":1462354657,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"10005c6013abbd1102f2463cf95604d4c8774c99","date":1469460814,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               },\n               // TODO: also let merging of > 1D fields tap into IW's indexing buffer size, somehow (1D fields do an optimized merge sort\n               // and don't need heap)\n               BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d08973aa47f2cf98a588293a53af4e948952ccfb","date":1469518724,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               },\n               // TODO: also let merging of > 1D fields tap into IW's indexing buffer size, somehow (1D fields do an optimized merge sort\n               // and don't need heap)\n               BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0567940defa1ea6eb8a039d9d36e3682063f8a4","date":1469815320,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               },\n               // TODO: also let merging of > 1D fields tap into IW's indexing buffer size, somehow (1D fields do an optimized merge sort\n               // and don't need heap)\n               BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               },\n               // TODO: also let merging of > 1D fields tap into IW's indexing buffer size, somehow (1D fields do an optimized merge sort\n               // and don't need heap)\n               BKDWriter.DEFAULT_MAX_MB_SORT_IN_HEAP);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6","date":1476277226,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     if (readerFieldInfo.getPointDimensionCount() == 0) {\n                       // This segment saw this field, but the field did not index points in it:\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"367f57e2ee85b7f7e28cfe73370a22cf67624f65","date":1476778467,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     if (readerFieldInfo.getPointDimensionCount() == 0) {\n                       // This segment saw this field, but the field did not index points in it:\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null) {\n          maxPointCount += pointsReader.size(fieldInfo.name);\n          docCount += pointsReader.getDocCount(fieldInfo.name);\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n               new PointsReader() {\n                 @Override\n                 public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {\n                   if (fieldName.equals(fieldInfo.name) == false) {\n                     throw new IllegalArgumentException(\"field name must match the field being merged\");\n                   }\n                   \n                   for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                     PointsReader pointsReader = mergeState.pointsReaders[i];\n                     if (pointsReader == null) {\n                       // This segment has no points\n                       continue;\n                     }\n                     FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                     if (readerFieldInfo == null) {\n                       // This segment never saw this field\n                       continue;\n                     }\n\n                     MergeState.DocMap docMap = mergeState.docMaps[i];\n                     int docBase = mergeState.docBase[i];\n                     pointsReader.intersect(fieldInfo.name,\n                                            new IntersectVisitor() {\n                                              @Override\n                                              public void visit(int docID) {\n                                                // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                                                throw new IllegalStateException();\n                                              }\n\n                                              @Override\n                                              public void visit(int docID, byte[] packedValue) throws IOException {\n                                                int newDocID = docMap.get(docID);\n                                                if (newDocID != -1) {\n                                                  // Not deleted:\n                                                  mergedVisitor.visit(docBase + newDocID, packedValue);\n                                                }\n                                              }\n\n                                              @Override\n                                              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                                                // Forces this segment's PointsReader to always visit all docs + values:\n                                                return Relation.CELL_CROSSES_QUERY;\n                                              }\n                                            });\n                   }\n                 }\n\n                 @Override\n                 public void checkIntegrity() {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long ramBytesUsed() {\n                   return 0L;\n                 }\n\n                 @Override\n                 public void close() {\n                 }\n\n                 @Override\n                 public byte[] getMinPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public byte[] getMaxPackedValue(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getNumDimensions(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public int getBytesPerDimension(String fieldName) {\n                   throw new UnsupportedOperationException();\n                 }\n\n                 @Override\n                 public long size(String fieldName) {\n                   return finalMaxPointCount;\n                 }\n\n                 @Override\n                 public int getDocCount(String fieldName) {\n                   return finalDocCount;\n                 }\n               });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dca67e06c96e95a8d9ef07418b6299bfd981523b","date":1484639518,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public long estimatePointCount(IntersectVisitor visitor) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"302d34f2c66e8d489ee13078305c330cbf67b226","date":1484754357,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public long estimatePointCount(IntersectVisitor visitor) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDataDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDataDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public long estimatePointCount(IntersectVisitor visitor) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDataDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumIndexDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public long estimatePointCount(IntersectVisitor visitor) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/PointsWriter#mergeOneField(MergeState,FieldInfo).mjava","sourceNew":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public long estimatePointCount(IntersectVisitor visitor) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumIndexDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","sourceOld":"  /** Default naive merge implementation for one field: it just re-indexes all the values\n   *  from the incoming segment.  The default codec overrides this for 1D fields and uses\n   *  a faster but more complex implementation. */\n  protected void mergeOneField(MergeState mergeState, FieldInfo fieldInfo) throws IOException {\n    long maxPointCount = 0;\n    int docCount = 0;\n    for (int i=0;i<mergeState.pointsReaders.length;i++) {\n      PointsReader pointsReader = mergeState.pointsReaders[i];\n      if (pointsReader != null) {\n        FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldInfo.name);\n        if (readerFieldInfo != null && readerFieldInfo.getPointDataDimensionCount() > 0) {\n          PointValues values = pointsReader.getValues(fieldInfo.name);\n          if (values != null) {\n            maxPointCount += values.size();\n            docCount += values.getDocCount();\n          }\n        }\n      }\n    }\n    final long finalMaxPointCount = maxPointCount;\n    final int finalDocCount = docCount;\n    writeField(fieldInfo,\n        new PointsReader() {\n          \n          @Override\n          public long ramBytesUsed() {\n            return 0;\n          }\n          \n          @Override\n          public void close() throws IOException {}\n          \n          @Override\n          public PointValues getValues(String fieldName) {\n            if (fieldName.equals(fieldInfo.name) == false) {\n              throw new IllegalArgumentException(\"field name must match the field being merged\");\n            }\n\n            return new PointValues() {\n              \n              @Override\n              public void intersect(IntersectVisitor mergedVisitor) throws IOException {\n                for (int i=0;i<mergeState.pointsReaders.length;i++) {\n                  PointsReader pointsReader = mergeState.pointsReaders[i];\n                  if (pointsReader == null) {\n                    // This segment has no points\n                    continue;\n                  }\n                  FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(fieldName);\n                  if (readerFieldInfo == null) {\n                    // This segment never saw this field\n                    continue;\n                  }\n\n                  if (readerFieldInfo.getPointDataDimensionCount() == 0) {\n                    // This segment saw this field, but the field did not index points in it:\n                    continue;\n                  }\n\n                  PointValues values = pointsReader.getValues(fieldName);\n                  if (values == null) {\n                    continue;\n                  }\n                  MergeState.DocMap docMap = mergeState.docMaps[i];\n                  values.intersect(new IntersectVisitor() {\n                    @Override\n                    public void visit(int docID) {\n                      // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY\n                      throw new IllegalStateException();\n                    }\n\n                    @Override\n                    public void visit(int docID, byte[] packedValue) throws IOException {\n                      int newDocID = docMap.get(docID);\n                      if (newDocID != -1) {\n                        // Not deleted:\n                        mergedVisitor.visit(newDocID, packedValue);\n                      }\n                    }\n\n                    @Override\n                    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n                      // Forces this segment's PointsReader to always visit all docs + values:\n                      return Relation.CELL_CROSSES_QUERY;\n                    }\n                  });\n                }\n              }\n\n              @Override\n              public long estimatePointCount(IntersectVisitor visitor) {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMinPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public byte[] getMaxPackedValue() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumDataDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getNumIndexDimensions() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public int getBytesPerDimension() {\n                throw new UnsupportedOperationException();\n              }\n\n              @Override\n              public long size() {\n                return finalMaxPointCount;\n              }\n\n              @Override\n              public int getDocCount() {\n                return finalDocCount;\n              }\n            };\n          }\n          \n          @Override\n          public void checkIntegrity() throws IOException {\n            throw new UnsupportedOperationException();\n          }\n        });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["f6652c943595e92c187ee904c382863013eae28f"],"f6652c943595e92c187ee904c382863013eae28f":["dca67e06c96e95a8d9ef07418b6299bfd981523b"],"523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6":["b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"da1c100e0e15178d145d7c3c8f38f3e553b92c12":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6"],"0ad30c6a479e764150a3316e57263319775f1df2":["416f9e28900210be57b69bc12e2954fb98ed7ebe","3d33e731a93d4b57e662ff094f64f94a745422d4"],"10005c6013abbd1102f2463cf95604d4c8774c99":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["416f9e28900210be57b69bc12e2954fb98ed7ebe","367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["416f9e28900210be57b69bc12e2954fb98ed7ebe","0ad30c6a479e764150a3316e57263319775f1df2"],"302d34f2c66e8d489ee13078305c330cbf67b226":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","dca67e06c96e95a8d9ef07418b6299bfd981523b"],"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["da1c100e0e15178d145d7c3c8f38f3e553b92c12"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["416f9e28900210be57b69bc12e2954fb98ed7ebe","ceaef6cfc68c8ab22a684192e469a8280f9e6e70"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["d470c8182e92b264680e34081b75e70a9f2b3c89","10005c6013abbd1102f2463cf95604d4c8774c99"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["d08973aa47f2cf98a588293a53af4e948952ccfb","b0567940defa1ea6eb8a039d9d36e3682063f8a4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"]},"commit2Childs":{"b0567940defa1ea6eb8a039d9d36e3682063f8a4":["523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"523b9a0ab605d725bf2b9a7a2e1040f1c6599dd6":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"da1c100e0e15178d145d7c3c8f38f3e553b92c12":["9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","dca67e06c96e95a8d9ef07418b6299bfd981523b"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"10005c6013abbd1102f2463cf95604d4c8774c99":["d08973aa47f2cf98a588293a53af4e948952ccfb"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["302d34f2c66e8d489ee13078305c330cbf67b226"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["10005c6013abbd1102f2463cf95604d4c8774c99","d08973aa47f2cf98a588293a53af4e948952ccfb"],"302d34f2c66e8d489ee13078305c330cbf67b226":[],"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["da1c100e0e15178d145d7c3c8f38f3e553b92c12"],"ceaef6cfc68c8ab22a684192e469a8280f9e6e70":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"9a5a0f27d9486cd33de88627ed3d2ff8dc5074ca":["416f9e28900210be57b69bc12e2954fb98ed7ebe"],"dca67e06c96e95a8d9ef07418b6299bfd981523b":["f6652c943595e92c187ee904c382863013eae28f","302d34f2c66e8d489ee13078305c330cbf67b226"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"416f9e28900210be57b69bc12e2954fb98ed7ebe":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","ceaef6cfc68c8ab22a684192e469a8280f9e6e70","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"d08973aa47f2cf98a588293a53af4e948952ccfb":["b0567940defa1ea6eb8a039d9d36e3682063f8a4","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["302d34f2c66e8d489ee13078305c330cbf67b226","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}