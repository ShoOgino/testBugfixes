{"path":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","commits":[{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e8d1458a2543cbd30cbfe7929be4dcb5c5251659","date":1254582241,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a046c0c310bc77931fc8441bd920053b607dd14","date":1254584734,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1326054a8d3aa66382d49decc7f330955c9c6f71","date":1257386139,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa4b66eb16ead894fa7130904af6ecf34331f050","date":1258198413,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          \n          // Make sure IW cleared the interrupted bit\n          if (interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (RuntimeException re) {\n          Throwable e = re.getCause();\n          if (e instanceof InterruptedException) {\n            // Make sure IW restored interrupted bit\n            if (!interrupted()) {\n              System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was false\");\n              e.printStackTrace(System.out);\n              failed = true;\n              break;\n            }\n          } else {\n            System.out.println(\"FAILED; unexpected exception\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1500e1f1cc03359b31815b4714f80b00e78c3775","date":1258290021,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          \n          // Make sure IW cleared the interrupted bit\n          if (interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2cc0964e95f9f205bbfc7259e04d6a78b55cd84a","date":1258310286,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n          //IndexWriter.unlock(dir);\n          w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n          ((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n          //w.setInfoStream(System.out);\n          w.setMaxBufferedDocs(2);\n          w.setMergeFactor(2);\n          Document doc = new Document();\n          doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n          for(int i=0;i<100;i++) {\n            w.addDocument(doc);\n            w.commit();\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        } finally {\n          try {\n            // Clear interrupt if pending\n            synchronized(this) {\n              interrupted();\n              if (w != null) {\n                w.close();\n              }\n            }\n          } catch (Throwable t) {\n            System.out.println(\"FAILED; unexpected exception during close\");\n            t.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["1fff768faeea6949a7d8937f06983038d4de0cd1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe0932c1d340f83fb0a611e5829b3046a1cc1152","date":1264946739,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6","date":1265808957,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(Version.LUCENE_CURRENT), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1cedb00d2dd44640194401179358a2e3ba6051bf","date":1268243626,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e52fea2c4081a1e552b98506691990be59503168","date":1268250331,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","date":1268494368,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new WhitespaceAnalyzer(TEST_VERSION_CURRENT), IndexWriter.MaxFieldLength.UNLIMITED);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            w.setMaxBufferedDocs(2);\n            w.setMergeFactor(2);\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["fe0932c1d340f83fb0a611e5829b3046a1cc1152"],"2cc0964e95f9f205bbfc7259e04d6a78b55cd84a":["1500e1f1cc03359b31815b4714f80b00e78c3775"],"0a046c0c310bc77931fc8441bd920053b607dd14":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"1500e1f1cc03359b31815b4714f80b00e78c3775":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"e52fea2c4081a1e552b98506691990be59503168":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["0a046c0c310bc77931fc8441bd920053b607dd14"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["e52fea2c4081a1e552b98506691990be59503168"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"fe0932c1d340f83fb0a611e5829b3046a1cc1152":["2cc0964e95f9f205bbfc7259e04d6a78b55cd84a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"]},"commit2Childs":{"55f083e91bb056b57de136da1dfc3b9b6ecc4ef6":["1cedb00d2dd44640194401179358a2e3ba6051bf"],"2cc0964e95f9f205bbfc7259e04d6a78b55cd84a":["fe0932c1d340f83fb0a611e5829b3046a1cc1152"],"0a046c0c310bc77931fc8441bd920053b607dd14":["1326054a8d3aa66382d49decc7f330955c9c6f71"],"1500e1f1cc03359b31815b4714f80b00e78c3775":["2cc0964e95f9f205bbfc7259e04d6a78b55cd84a"],"1cedb00d2dd44640194401179358a2e3ba6051bf":["e52fea2c4081a1e552b98506691990be59503168"],"e52fea2c4081a1e552b98506691990be59503168":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["0a046c0c310bc77931fc8441bd920053b607dd14","e8d1458a2543cbd30cbfe7929be4dcb5c5251659"],"aa4b66eb16ead894fa7130904af6ecf34331f050":["1500e1f1cc03359b31815b4714f80b00e78c3775"],"1326054a8d3aa66382d49decc7f330955c9c6f71":["aa4b66eb16ead894fa7130904af6ecf34331f050"],"84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"e8d1458a2543cbd30cbfe7929be4dcb5c5251659":["0a046c0c310bc77931fc8441bd920053b607dd14"],"fe0932c1d340f83fb0a611e5829b3046a1cc1152":["55f083e91bb056b57de136da1dfc3b9b6ecc4ef6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}