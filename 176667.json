{"path":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","commits":[{"id":"05d36e0b328ec96237035fbcca240e73631396e5","date":1020520725,"type":0,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","pathOld":"/dev/null","sourceNew":"        /**\n         * gets a robots.txt file and adds the information to the hostInfo\n         * structure\n         *\n         * @param thread  the server thread (passed by the thread pool)\n         */\n        public void run(ServerThread thread)\n        {\n            // assert hostInfo != null;\n            String threadName = Thread.currentThread().getName();\n\n            log.logThreadSafe(\"task \" + threadName + \": starting to load \" + hostInfo.hostName);\n            //hostInfo.setLoadingRobotsTxt(true);\n            String[] disallows = null;\n            boolean errorOccured = false;\n            try\n            {\n                log.logThreadSafe(\"task \" + threadName + \": getting connection\");\n                HTTPConnection conn = new HTTPConnection(hostInfo.hostName);\n                conn.setTimeout(30000);\n                // wait at most 20 secs\n\n                HTTPResponse res = conn.Get(\"/robots.txt\", (String) null, headers);\n                log.logThreadSafe(\"task \" + threadName + \": got connection.\");\n                if (res.getStatusCode() != 200)\n                {\n                    errorOccured = true;\n                }\n                else\n                {\n\n                    log.logThreadSafe(\"task \" + threadName + \": reading\");\n                    byte[] file = res.getData(40000);\n                    // max. 40 kb\n                    log.logThreadSafe(\"task \" + threadName + \": reading done. parsing\");\n                    disallows = parse(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(file))));\n                    log.logThreadSafe(\"task \" + threadName + \": parsing done. found \" + disallows.length + \" disallows\");\n                    // assert disallows != null\n                    // HostInfo hostInfo = hostManager.getHostInfo(this.hostName);\n                    // assert hostInfo != null\n                    log.logThreadSafe(\"task \" + threadName + \": setting disallows\");\n                }\n            }\n            catch (java.net.UnknownHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": unknown host. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.NoRouteToHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": no route to. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.ConnectException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": connect exception. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.io.InterruptedIOException e)\n            {\n                // time out. fatal in this case\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": time out. setting to unreachable\");\n                errorOccured = true;\n            }\n\n            catch (Throwable e)\n            {\n                errorOccured = true;\n                log.log(\"task \" + threadName + \": unknown exception: \" + e.getClass().getName() + \": \" + e.getMessage() + \". continuing\");\n                log.log(e);\n\n            }\n            finally\n            {\n                if (errorOccured)\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, null);\n                        // crawl everything\n                        hostInfo.setLoadingRobotsTxt(false);\n                        log.logThreadSafe(\"task \" + threadName + \": error occured\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.queuedRequests.size() + \" queueud requests back\");\n                        hostInfo.isLoadingRobotsTxt = false;\n                        putBackURLs();\n                    }\n                }\n                else\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, disallows);\n                        log.logThreadSafe(\"task \" + threadName + \": done\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.queuedRequests.size() + \" queueud requests back\");\n                        hostInfo.isLoadingRobotsTxt = false;\n                        putBackURLs();\n                    }\n                }\n            }\n        }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35a1a3e95f2bf9aed45087ffee78298452d7c234","date":1024322368,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","sourceNew":"        /**\n         * gets a robots.txt file and adds the information to the hostInfo\n         * structure\n         *\n         * @param thread  the server thread (passed by the thread pool)\n         */\n        public void run(ServerThread thread)\n        {\n            // assert hostInfo != null;\n            String threadName = Thread.currentThread().getName();\n\n            log.logThreadSafe(\"task \" + threadName + \": starting to load \" + hostInfo.getHostName());\n            //hostInfo.setLoadingRobotsTxt(true);\n            String[] disallows = null;\n            boolean errorOccured = false;\n            try\n            {\n                log.logThreadSafe(\"task \" + threadName + \": getting connection\");\n                HTTPConnection conn = new HTTPConnection(hostInfo.getHostName());\n                conn.setTimeout(30000);\n                // wait at most 20 secs\n\n                HTTPResponse res = conn.Get(\"/robots.txt\", (String) null, headers);\n                log.logThreadSafe(\"task \" + threadName + \": got connection.\");\n                if (res.getStatusCode() != 200)\n                {\n                    errorOccured = true;\n                }\n                else\n                {\n\n                    log.logThreadSafe(\"task \" + threadName + \": reading\");\n                    byte[] file = res.getData(40000);\n                    // max. 40 kb\n                    log.logThreadSafe(\"task \" + threadName + \": reading done. parsing\");\n                    disallows = parse(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(file))));\n                    log.logThreadSafe(\"task \" + threadName + \": parsing done. found \" + disallows.length + \" disallows\");\n                    // assert disallows != null\n                    // HostInfo hostInfo = hostManager.getHostInfo(this.hostName);\n                    // assert hostInfo != null\n                    log.logThreadSafe(\"task \" + threadName + \": setting disallows\");\n                }\n            }\n            catch (java.net.UnknownHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": unknown host. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.NoRouteToHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": no route to. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.ConnectException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": connect exception. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.io.InterruptedIOException e)\n            {\n                // time out. fatal in this case\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": time out. setting to unreachable\");\n                errorOccured = true;\n            }\n\n            catch (Throwable e)\n            {\n                errorOccured = true;\n                log.log(\"task \" + threadName + \": unknown exception: \" + e.getClass().getName() + \": \" + e.getMessage() + \". continuing\");\n                log.log(e);\n\n            }\n            finally\n            {\n                if (errorOccured)\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, null);\n                        // crawl everything\n                        hostInfo.setLoadingRobotsTxt(false);\n                        log.logThreadSafe(\"task \" + threadName + \": error occured\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n                else\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, disallows);\n                        log.logThreadSafe(\"task \" + threadName + \": done\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n            }\n        }\n\n","sourceOld":"        /**\n         * gets a robots.txt file and adds the information to the hostInfo\n         * structure\n         *\n         * @param thread  the server thread (passed by the thread pool)\n         */\n        public void run(ServerThread thread)\n        {\n            // assert hostInfo != null;\n            String threadName = Thread.currentThread().getName();\n\n            log.logThreadSafe(\"task \" + threadName + \": starting to load \" + hostInfo.hostName);\n            //hostInfo.setLoadingRobotsTxt(true);\n            String[] disallows = null;\n            boolean errorOccured = false;\n            try\n            {\n                log.logThreadSafe(\"task \" + threadName + \": getting connection\");\n                HTTPConnection conn = new HTTPConnection(hostInfo.hostName);\n                conn.setTimeout(30000);\n                // wait at most 20 secs\n\n                HTTPResponse res = conn.Get(\"/robots.txt\", (String) null, headers);\n                log.logThreadSafe(\"task \" + threadName + \": got connection.\");\n                if (res.getStatusCode() != 200)\n                {\n                    errorOccured = true;\n                }\n                else\n                {\n\n                    log.logThreadSafe(\"task \" + threadName + \": reading\");\n                    byte[] file = res.getData(40000);\n                    // max. 40 kb\n                    log.logThreadSafe(\"task \" + threadName + \": reading done. parsing\");\n                    disallows = parse(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(file))));\n                    log.logThreadSafe(\"task \" + threadName + \": parsing done. found \" + disallows.length + \" disallows\");\n                    // assert disallows != null\n                    // HostInfo hostInfo = hostManager.getHostInfo(this.hostName);\n                    // assert hostInfo != null\n                    log.logThreadSafe(\"task \" + threadName + \": setting disallows\");\n                }\n            }\n            catch (java.net.UnknownHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": unknown host. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.NoRouteToHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": no route to. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.ConnectException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": connect exception. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.io.InterruptedIOException e)\n            {\n                // time out. fatal in this case\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": time out. setting to unreachable\");\n                errorOccured = true;\n            }\n\n            catch (Throwable e)\n            {\n                errorOccured = true;\n                log.log(\"task \" + threadName + \": unknown exception: \" + e.getClass().getName() + \": \" + e.getMessage() + \". continuing\");\n                log.log(e);\n\n            }\n            finally\n            {\n                if (errorOccured)\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, null);\n                        // crawl everything\n                        hostInfo.setLoadingRobotsTxt(false);\n                        log.logThreadSafe(\"task \" + threadName + \": error occured\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.queuedRequests.size() + \" queueud requests back\");\n                        hostInfo.isLoadingRobotsTxt = false;\n                        putBackURLs();\n                    }\n                }\n                else\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, disallows);\n                        log.logThreadSafe(\"task \" + threadName + \": done\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.queuedRequests.size() + \" queueud requests back\");\n                        hostInfo.isLoadingRobotsTxt = false;\n                        putBackURLs();\n                    }\n                }\n            }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0badbfbc9869e6d3ce976803c01c6150b925393","date":1035299707,"type":3,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","sourceNew":"        /**\n         * gets a robots.txt file and adds the information to the hostInfo\n         * structure\n         *\n         * @param thread  the server thread (passed by the thread pool)\n         */\n        public void run(ServerThread thread)\n        {\n            String threadName = Thread.currentThread().getName();\n            synchronized(hostInfo)\n            {\n                if(hostInfo.isRobotTxtChecked())\n                {\n                    log.logThreadSafe(\"task \" + threadName + \": already loaded \" + hostInfo.getHostName());\n                    return;         // may happen 'cause check is not synchronized\n                }\n            }\n            // assert hostInfo != null;\n\n            log.logThreadSafe(\"task \" + threadName + \": starting to load \" + hostInfo.getHostName());\n            //hostInfo.setLoadingRobotsTxt(true);\n            String[] disallows = null;\n            boolean errorOccured = false;\n            try\n            {\n                log.logThreadSafe(\"task \" + threadName + \": getting connection\");\n                HTTPConnection conn = new HTTPConnection(hostInfo.getHostName());\n                conn.setTimeout(30000);\n                // wait at most 20 secs\n\n                HTTPResponse res = conn.Get(\"/robots.txt\", (String) null, headers);\n                log.logThreadSafe(\"task \" + threadName + \": got connection.\");\n                if (res.getStatusCode() != 200)\n                {\n                    errorOccured = true;\n                    log.log(\"task \" + threadName + \": return code was \" + res.getStatusCode());\n                }\n                else\n                {\n\n                    log.logThreadSafe(\"task \" + threadName + \": reading\");\n                    byte[] file = res.getData(40000);\n                    // max. 40 kb\n                    log.logThreadSafe(\"task \" + threadName + \": reading done. parsing\");\n                    disallows = parse(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(file))));\n                    log.logThreadSafe(\"task \" + threadName + \": parsing done. found \" + disallows.length + \" disallows\");\n                    // assert disallows != null\n                    // HostInfo hostInfo = hostManager.getHostInfo(this.hostName);\n                    // assert hostInfo != null\n                    log.logThreadSafe(\"task \" + threadName + \": setting disallows\");\n                }\n            }\n            catch (java.net.UnknownHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": unknown host '\" + hostInfo.getHostName() + \"'. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.NoRouteToHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": no route to '\"+hostInfo.getHostName()+\"'. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.ConnectException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": connect exception while connecting to '\"+hostInfo.getHostName()+\"'. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.io.InterruptedIOException e)\n            {\n                // time out. fatal in this case\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": time out while connecting to '\" +hostInfo.getHostName() + \"'. setting to unreachable\");\n                errorOccured = true;\n            }\n\n            catch (Throwable e)\n            {\n                errorOccured = true;\n                log.log(\"task \" + threadName + \": unknown exception: \" + e.getClass().getName() + \": \" + e.getMessage() + \". continuing\");\n                log.log(e);\n\n            }\n            finally\n            {\n                if (errorOccured)\n                {\n                    log.logThreadSafe(\"task \" + threadName + \": error occured. putback...\");\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, null);\n                        // crawl everything\n                        hostInfo.setLoadingRobotsTxt(false);\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        //hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n                else\n                {\n                    log.logThreadSafe(\"task \" + threadName + \": finished. putback...\");\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, disallows);\n                        log.logThreadSafe(\"task \" + threadName + \": done\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n            }\n        }\n\n","sourceOld":"        /**\n         * gets a robots.txt file and adds the information to the hostInfo\n         * structure\n         *\n         * @param thread  the server thread (passed by the thread pool)\n         */\n        public void run(ServerThread thread)\n        {\n            // assert hostInfo != null;\n            String threadName = Thread.currentThread().getName();\n\n            log.logThreadSafe(\"task \" + threadName + \": starting to load \" + hostInfo.getHostName());\n            //hostInfo.setLoadingRobotsTxt(true);\n            String[] disallows = null;\n            boolean errorOccured = false;\n            try\n            {\n                log.logThreadSafe(\"task \" + threadName + \": getting connection\");\n                HTTPConnection conn = new HTTPConnection(hostInfo.getHostName());\n                conn.setTimeout(30000);\n                // wait at most 20 secs\n\n                HTTPResponse res = conn.Get(\"/robots.txt\", (String) null, headers);\n                log.logThreadSafe(\"task \" + threadName + \": got connection.\");\n                if (res.getStatusCode() != 200)\n                {\n                    errorOccured = true;\n                }\n                else\n                {\n\n                    log.logThreadSafe(\"task \" + threadName + \": reading\");\n                    byte[] file = res.getData(40000);\n                    // max. 40 kb\n                    log.logThreadSafe(\"task \" + threadName + \": reading done. parsing\");\n                    disallows = parse(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(file))));\n                    log.logThreadSafe(\"task \" + threadName + \": parsing done. found \" + disallows.length + \" disallows\");\n                    // assert disallows != null\n                    // HostInfo hostInfo = hostManager.getHostInfo(this.hostName);\n                    // assert hostInfo != null\n                    log.logThreadSafe(\"task \" + threadName + \": setting disallows\");\n                }\n            }\n            catch (java.net.UnknownHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": unknown host. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.NoRouteToHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": no route to. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.ConnectException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": connect exception. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.io.InterruptedIOException e)\n            {\n                // time out. fatal in this case\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": time out. setting to unreachable\");\n                errorOccured = true;\n            }\n\n            catch (Throwable e)\n            {\n                errorOccured = true;\n                log.log(\"task \" + threadName + \": unknown exception: \" + e.getClass().getName() + \": \" + e.getMessage() + \". continuing\");\n                log.log(e);\n\n            }\n            finally\n            {\n                if (errorOccured)\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, null);\n                        // crawl everything\n                        hostInfo.setLoadingRobotsTxt(false);\n                        log.logThreadSafe(\"task \" + threadName + \": error occured\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n                else\n                {\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, disallows);\n                        log.logThreadSafe(\"task \" + threadName + \": done\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n            }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/src/de/lanlab/larm/fetcher/RobotExclusionFilter.RobotExclusionTask#run(ServerThread).mjava","sourceNew":null,"sourceOld":"        /**\n         * gets a robots.txt file and adds the information to the hostInfo\n         * structure\n         *\n         * @param thread  the server thread (passed by the thread pool)\n         */\n        public void run(ServerThread thread)\n        {\n            String threadName = Thread.currentThread().getName();\n            synchronized(hostInfo)\n            {\n                if(hostInfo.isRobotTxtChecked())\n                {\n                    log.logThreadSafe(\"task \" + threadName + \": already loaded \" + hostInfo.getHostName());\n                    return;         // may happen 'cause check is not synchronized\n                }\n            }\n            // assert hostInfo != null;\n\n            log.logThreadSafe(\"task \" + threadName + \": starting to load \" + hostInfo.getHostName());\n            //hostInfo.setLoadingRobotsTxt(true);\n            String[] disallows = null;\n            boolean errorOccured = false;\n            try\n            {\n                log.logThreadSafe(\"task \" + threadName + \": getting connection\");\n                HTTPConnection conn = new HTTPConnection(hostInfo.getHostName());\n                conn.setTimeout(30000);\n                // wait at most 20 secs\n\n                HTTPResponse res = conn.Get(\"/robots.txt\", (String) null, headers);\n                log.logThreadSafe(\"task \" + threadName + \": got connection.\");\n                if (res.getStatusCode() != 200)\n                {\n                    errorOccured = true;\n                    log.log(\"task \" + threadName + \": return code was \" + res.getStatusCode());\n                }\n                else\n                {\n\n                    log.logThreadSafe(\"task \" + threadName + \": reading\");\n                    byte[] file = res.getData(40000);\n                    // max. 40 kb\n                    log.logThreadSafe(\"task \" + threadName + \": reading done. parsing\");\n                    disallows = parse(new BufferedReader(new InputStreamReader(new ByteArrayInputStream(file))));\n                    log.logThreadSafe(\"task \" + threadName + \": parsing done. found \" + disallows.length + \" disallows\");\n                    // assert disallows != null\n                    // HostInfo hostInfo = hostManager.getHostInfo(this.hostName);\n                    // assert hostInfo != null\n                    log.logThreadSafe(\"task \" + threadName + \": setting disallows\");\n                }\n            }\n            catch (java.net.UnknownHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": unknown host '\" + hostInfo.getHostName() + \"'. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.NoRouteToHostException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": no route to '\"+hostInfo.getHostName()+\"'. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.net.ConnectException e)\n            {\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": connect exception while connecting to '\"+hostInfo.getHostName()+\"'. setting to unreachable\");\n                errorOccured = true;\n            }\n            catch (java.io.InterruptedIOException e)\n            {\n                // time out. fatal in this case\n                hostInfo.setReachable(false);\n                log.logThreadSafe(\"task \" + threadName + \": time out while connecting to '\" +hostInfo.getHostName() + \"'. setting to unreachable\");\n                errorOccured = true;\n            }\n\n            catch (Throwable e)\n            {\n                errorOccured = true;\n                log.log(\"task \" + threadName + \": unknown exception: \" + e.getClass().getName() + \": \" + e.getMessage() + \". continuing\");\n                log.log(e);\n\n            }\n            finally\n            {\n                if (errorOccured)\n                {\n                    log.logThreadSafe(\"task \" + threadName + \": error occured. putback...\");\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, null);\n                        // crawl everything\n                        hostInfo.setLoadingRobotsTxt(false);\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        //hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n                else\n                {\n                    log.logThreadSafe(\"task \" + threadName + \": finished. putback...\");\n                    synchronized (hostInfo)\n                    {\n                        hostInfo.setRobotsChecked(true, disallows);\n                        log.logThreadSafe(\"task \" + threadName + \": done\");\n                        log.logThreadSafe(\"task \" + threadName + \": now put \" + hostInfo.getQueueSize() + \" queueud requests back\");\n                        hostInfo.setLoadingRobotsTxt(false);\n                        putBackURLs();\n                    }\n                }\n            }\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b0badbfbc9869e6d3ce976803c01c6150b925393":["35a1a3e95f2bf9aed45087ffee78298452d7c234"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["b0badbfbc9869e6d3ce976803c01c6150b925393"],"05d36e0b328ec96237035fbcca240e73631396e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"35a1a3e95f2bf9aed45087ffee78298452d7c234":["05d36e0b328ec96237035fbcca240e73631396e5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"b0badbfbc9869e6d3ce976803c01c6150b925393":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05d36e0b328ec96237035fbcca240e73631396e5"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"05d36e0b328ec96237035fbcca240e73631396e5":["35a1a3e95f2bf9aed45087ffee78298452d7c234"],"35a1a3e95f2bf9aed45087ffee78298452d7c234":["b0badbfbc9869e6d3ce976803c01c6150b925393"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}