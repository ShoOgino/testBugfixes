{"path":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","commits":[{"id":"60596f28be69b10c37a56a303c2dbea07b2ca4ba","date":1425060541,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator() {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n            \n            @Override\n            public DocIdSetIterator approximation() {\n              return approximation;\n            }\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["0bf09e549fa47b894ce44baafdf8031eba2445c6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a6b1be5d2b36d6a30913778ef61374103d55e33","date":1427303640,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator() {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n            \n            @Override\n            public DocIdSetIterator approximation() {\n              return approximation;\n            }\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":0,"author":"Ryan Ernst","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29efba95465cc25f76d9f92aec35c9f71b1a55ca","date":1428692677,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      protected Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05c52ac194342b760b830342ee8423fcf00e54d0","date":1429197275,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      protected Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      protected Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a7f94ff172f40ff68a926d112e25b96bc38e5a27","date":1431002360,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator disi = docIdSet.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // We apply acceptDocs as an approximation\n        if (acceptDocs == null) {\n          return new ConstantScoreScorer(this, 0f, disi);\n        } else {\n          final TwoPhaseIterator twoPhaseView = new TwoPhaseIterator(disi) {\n\n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          return new ConstantScoreScorer(this, 0f, twoPhaseView);\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      protected Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator approximation = docIdSet.iterator();\n        if (approximation == null) {\n          return null;\n        }\n\n        final DocIdSetIterator disi;\n        final TwoPhaseIterator twoPhaseView;\n        if (acceptDocs == null) {\n          twoPhaseView = null;\n          disi = approximation;\n        } else {\n          twoPhaseView = new TwoPhaseIterator(approximation) {\n            \n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseView);\n        }\n        return new Scorer(weight) {\n\n          @Override\n          public TwoPhaseIterator asTwoPhaseIterator() {\n            return twoPhaseView;\n          }\n\n          @Override\n          public float score() throws IOException {\n            return 0f;\n          }\n\n          @Override\n          public int freq() throws IOException {\n            return 1;\n          }\n\n          @Override\n          public int docID() {\n            return disi.docID();\n          }\n\n          @Override\n          public int nextDoc() throws IOException {\n            return disi.nextDoc();\n          }\n\n          @Override\n          public int advance(int target) throws IOException {\n            return disi.advance(target);\n          }\n\n          @Override\n          public long cost() {\n            return disi.cost();\n          }\n          \n        };\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator disi = docIdSet.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, 0f, disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context, null);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context, acceptDocs);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator disi = docIdSet.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        // We apply acceptDocs as an approximation\n        if (acceptDocs == null) {\n          return new ConstantScoreScorer(this, 0f, disi);\n        } else {\n          final TwoPhaseIterator twoPhaseView = new TwoPhaseIterator(disi) {\n\n            @Override\n            public boolean matches() throws IOException {\n              final int doc = approximation.docID();\n              return acceptDocs.get(doc);\n            }\n\n          };\n          return new ConstantScoreScorer(this, 0f, twoPhaseView);\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0bf09e549fa47b894ce44baafdf8031eba2445c6","date":1436204317,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n\n    return new ConstantScoreWeight(weight.getQuery()) {\n\n      final AtomicBoolean used = new AtomicBoolean(false);\n\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        if (used.compareAndSet(false, true)) {\n          policy.onUse(getQuery());\n        }\n\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator disi = docIdSet.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, 0f, disi);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n    policy.onUse(weight.getQuery());\n    return new ConstantScoreWeight(weight.getQuery()) {\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator disi = docIdSet.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, 0f, disi);\n      }\n    };\n  }\n\n","bugFix":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cfc8e07724f6bd95be343b1c03ae917c9de69cc","date":1446026743,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/search/CachingWrapperQuery#createWeight(IndexSearcher,boolean).mjava","sourceNew":null,"sourceOld":"  @Override\n  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {\n    final Weight weight = query.createWeight(searcher, needsScores);\n    if (needsScores) {\n      // our cache is not sufficient, we need scores too\n      return weight;\n    }\n\n    return new ConstantScoreWeight(weight.getQuery()) {\n\n      final AtomicBoolean used = new AtomicBoolean(false);\n\n      @Override\n      public void extractTerms(Set<Term> terms) {\n        weight.extractTerms(terms);\n      }\n\n      @Override\n      public Scorer scorer(LeafReaderContext context) throws IOException {\n        if (used.compareAndSet(false, true)) {\n          policy.onUse(getQuery());\n        }\n\n        final LeafReader reader = context.reader();\n        final Object key = reader.getCoreCacheKey();\n\n        DocIdSet docIdSet = cache.get(key);\n        if (docIdSet != null) {\n          hitCount++;\n        } else if (policy.shouldCache(query, context)) {\n          missCount++;\n          final Scorer scorer = weight.scorer(context);\n          if (scorer == null) {\n            docIdSet = DocIdSet.EMPTY;\n          } else {\n            docIdSet = cacheImpl(scorer, context.reader());\n          }\n          cache.put(key, docIdSet);\n        } else {\n          return weight.scorer(context);\n        }\n\n        assert docIdSet != null;\n        if (docIdSet == DocIdSet.EMPTY) {\n          return null;\n        }\n        final DocIdSetIterator disi = docIdSet.iterator();\n        if (disi == null) {\n          return null;\n        }\n\n        return new ConstantScoreScorer(this, 0f, disi);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"29efba95465cc25f76d9f92aec35c9f71b1a55ca":["7a6b1be5d2b36d6a30913778ef61374103d55e33"],"7a6b1be5d2b36d6a30913778ef61374103d55e33":["60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7a6b1be5d2b36d6a30913778ef61374103d55e33"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["a7f94ff172f40ff68a926d112e25b96bc38e5a27"],"a7f94ff172f40ff68a926d112e25b96bc38e5a27":["05c52ac194342b760b830342ee8423fcf00e54d0"],"4cfc8e07724f6bd95be343b1c03ae917c9de69cc":["0bf09e549fa47b894ce44baafdf8031eba2445c6"],"0bf09e549fa47b894ce44baafdf8031eba2445c6":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05c52ac194342b760b830342ee8423fcf00e54d0":["29efba95465cc25f76d9f92aec35c9f71b1a55ca"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4cfc8e07724f6bd95be343b1c03ae917c9de69cc"]},"commit2Childs":{"29efba95465cc25f76d9f92aec35c9f71b1a55ca":["05c52ac194342b760b830342ee8423fcf00e54d0"],"7a6b1be5d2b36d6a30913778ef61374103d55e33":["29efba95465cc25f76d9f92aec35c9f71b1a55ca","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0f4464508ee83288c8c4585b533f9faaa93aa314":["0bf09e549fa47b894ce44baafdf8031eba2445c6"],"a7f94ff172f40ff68a926d112e25b96bc38e5a27":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"60596f28be69b10c37a56a303c2dbea07b2ca4ba":["7a6b1be5d2b36d6a30913778ef61374103d55e33"],"4cfc8e07724f6bd95be343b1c03ae917c9de69cc":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0bf09e549fa47b894ce44baafdf8031eba2445c6":["4cfc8e07724f6bd95be343b1c03ae917c9de69cc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","60596f28be69b10c37a56a303c2dbea07b2ca4ba"],"05c52ac194342b760b830342ee8423fcf00e54d0":["a7f94ff172f40ff68a926d112e25b96bc38e5a27"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}