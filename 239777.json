{"path":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","commits":[{"id":"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8","date":1195335263,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","pathOld":"/dev/null","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // the index hasn't changed - nothing to do here\n      return this;\n    }\n\n    return (DirectoryIndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    }.run();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58de0ad8c77e6bac7af01b4b955ad53a4137acdd","date":1207967154,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // this has changes, therefore we have the lock and don't need to reopen\n      // OR: the index in the directory hasn't changed - nothing to do here\n      return this;\n    }\n\n    return (DirectoryIndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    }.run();\n  }\n\n","sourceOld":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // the index hasn't changed - nothing to do here\n      return this;\n    }\n\n    return (DirectoryIndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    }.run();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5712975970a595c28f1988efd007e1b8a617a92f","date":1219499238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // this has changes, therefore we have the lock and don't need to reopen\n      // OR: the index in the directory hasn't changed - nothing to do here\n      return this;\n    }\n\n    return (DirectoryIndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory, readOnly);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    }.run();\n  }\n\n","sourceOld":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // this has changes, therefore we have the lock and don't need to reopen\n      // OR: the index in the directory hasn't changed - nothing to do here\n      return this;\n    }\n\n    return (DirectoryIndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    }.run();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6817596a5666fa3e3979682dea4a2bc8d70fc570","date":1227002271,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // this has changes, therefore we have the lock and don't need to reopen\n      // OR: the index in the directory hasn't changed - nothing to do here\n      return this;\n    }\n\n    final SegmentInfos.FindSegmentsFile finder = new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory, readOnly);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    };\n\n    DirectoryIndexReader reader = null;\n\n    // While trying to reopen, we temporarily mark our\n    // closeDirectory as false.  This way any exceptions hit\n    // partway while opening the reader, which is expected\n    // eg if writer is committing, won't close our\n    // directory.  We restore this value below:\n    final boolean myCloseDirectory = closeDirectory;\n    closeDirectory = false;\n\n    try {\n      reader = (DirectoryIndexReader) finder.run();\n    } finally {\n      if (myCloseDirectory) {\n        assert directory instanceof FSDirectory;\n        // Restore my closeDirectory\n        closeDirectory = true;\n        if (reader != null && reader != this) {\n          // Success, and a new reader was actually opened\n          reader.closeDirectory = true;\n          // Clone the directory\n          reader.directory = FSDirectory.getDirectory(((FSDirectory) directory).getFile());\n        }\n      }\n    }\n\n    return reader;\n  }\n\n","sourceOld":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // this has changes, therefore we have the lock and don't need to reopen\n      // OR: the index in the directory hasn't changed - nothing to do here\n      return this;\n    }\n\n    return (DirectoryIndexReader) new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory, readOnly);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    }.run();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6db660b56f04fdb2853d25cdee8ee0d36559a521","date":1233313968,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    // Preserve current readOnly\n    return doReopen(readOnly);\n  }\n\n","sourceOld":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (this.hasChanges || this.isCurrent()) {\n      // this has changes, therefore we have the lock and don't need to reopen\n      // OR: the index in the directory hasn't changed - nothing to do here\n      return this;\n    }\n\n    final SegmentInfos.FindSegmentsFile finder = new SegmentInfos.FindSegmentsFile(directory) {\n\n      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {\n        SegmentInfos infos = new SegmentInfos();\n        infos.read(directory, segmentFileName);\n\n        DirectoryIndexReader newReader = doReopen(infos);\n        \n        if (DirectoryIndexReader.this != newReader) {\n          newReader.init(directory, infos, closeDirectory, readOnly);\n          newReader.deletionPolicy = deletionPolicy;\n        }\n\n        return newReader;\n      }\n    };\n\n    DirectoryIndexReader reader = null;\n\n    // While trying to reopen, we temporarily mark our\n    // closeDirectory as false.  This way any exceptions hit\n    // partway while opening the reader, which is expected\n    // eg if writer is committing, won't close our\n    // directory.  We restore this value below:\n    final boolean myCloseDirectory = closeDirectory;\n    closeDirectory = false;\n\n    try {\n      reader = (DirectoryIndexReader) finder.run();\n    } finally {\n      if (myCloseDirectory) {\n        assert directory instanceof FSDirectory;\n        // Restore my closeDirectory\n        closeDirectory = true;\n        if (reader != null && reader != this) {\n          // Success, and a new reader was actually opened\n          reader.closeDirectory = true;\n          // Clone the directory\n          reader.directory = FSDirectory.getDirectory(((FSDirectory) directory).getFile());\n        }\n      }\n    }\n\n    return reader;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e268f08b3f32b86396577dee4e99e0384af9fd70","date":1236792757,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    // Preserve current readOnly\n    return doReopen(readOnly, null);\n  }\n\n","sourceOld":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    // Preserve current readOnly\n    return doReopen(readOnly);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/DirectoryReader#reopen().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#reopen().mjava","sourceNew":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    // Preserve current readOnly\n    return doReopen(readOnly, null);\n  }\n\n","sourceOld":"  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {\n    // Preserve current readOnly\n    return doReopen(readOnly, null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6db660b56f04fdb2853d25cdee8ee0d36559a521":["6817596a5666fa3e3979682dea4a2bc8d70fc570"],"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["e268f08b3f32b86396577dee4e99e0384af9fd70"],"5712975970a595c28f1988efd007e1b8a617a92f":["58de0ad8c77e6bac7af01b4b955ad53a4137acdd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e268f08b3f32b86396577dee4e99e0384af9fd70":["6db660b56f04fdb2853d25cdee8ee0d36559a521"],"58de0ad8c77e6bac7af01b4b955ad53a4137acdd":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"6817596a5666fa3e3979682dea4a2bc8d70fc570":["5712975970a595c28f1988efd007e1b8a617a92f"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"]},"commit2Childs":{"6db660b56f04fdb2853d25cdee8ee0d36559a521":["e268f08b3f32b86396577dee4e99e0384af9fd70"],"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5712975970a595c28f1988efd007e1b8a617a92f":["6817596a5666fa3e3979682dea4a2bc8d70fc570"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3b9d7142a399ac70a71ce5b40ee66695eda5b7e8"],"e268f08b3f32b86396577dee4e99e0384af9fd70":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"58de0ad8c77e6bac7af01b4b955ad53a4137acdd":["5712975970a595c28f1988efd007e1b8a617a92f"],"6817596a5666fa3e3979682dea4a2bc8d70fc570":["6db660b56f04fdb2853d25cdee8ee0d36559a521"],"3b9d7142a399ac70a71ce5b40ee66695eda5b7e8":["58de0ad8c77e6bac7af01b4b955ad53a4137acdd"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}