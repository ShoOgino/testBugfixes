{"path":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame#scanToTermLeaf(BytesRef,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"        // Target's prefix matches this block's prefix; we\n        // scan the entries check if the suffix matches.\n        public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n          assert nextEnt != -1;\n\n          termExists = true;\n          subCode = 0;\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            return SeekStatus.END;\n          }\n\n          assert prefixMatches(target);\n\n          // Loop over each entry (term or sub-block) in this block:\n          //nextTerm: while(nextEnt < entCount) {\n          nextTerm: while (true) {\n            nextEnt++;\n\n            suffix = suffixesReader.readVInt();\n\n            // if (DEBUG) {\n            //   BytesRef suffixBytesRef = new BytesRef();\n            //   suffixBytesRef.bytes = suffixBytes;\n            //   suffixBytesRef.offset = suffixesReader.getPosition();\n            //   suffixBytesRef.length = suffix;\n            //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n            // }\n\n            final int termLen = prefix + suffix;\n            startBytePos = suffixesReader.getPosition();\n            suffixesReader.skipBytes(suffix);\n\n            final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n            int targetPos = target.offset + prefix;\n\n            // Loop over bytes in the suffix, comparing to\n            // the target\n            int bytePos = startBytePos;\n            while(true) {\n              final int cmp;\n              final boolean stop;\n              if (targetPos < targetLimit) {\n                cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n                stop = false;\n              } else {\n                assert targetPos == targetLimit;\n                cmp = termLen - target.length;\n                stop = true;\n              }\n\n              if (cmp < 0) {\n                // Current entry is still before the target;\n                // keep scanning\n\n                if (nextEnt == entCount) {\n                  if (exactOnly) {\n                    fillTerm();\n                  }\n                  // We are done scanning this block\n                  break nextTerm;\n                } else {\n                  continue nextTerm;\n                }\n              } else if (cmp > 0) {\n\n                // Done!  Current entry is after target --\n                // return NOT_FOUND:\n                fillTerm();\n\n                if (!exactOnly && !termExists) {\n                  // We are on a sub-block, and caller wants\n                  // us to position to the next term after\n                  // the target, so we must recurse into the\n                  // sub-frame(s):\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                  currentFrame.loadBlock();\n                  while (currentFrame.next()) {\n                    currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                    currentFrame.loadBlock();\n                  }\n                }\n                \n                //if (DEBUG) System.out.println(\"        not found\");\n                return SeekStatus.NOT_FOUND;\n              } else if (stop) {\n                // Exact match!\n\n                // This cannot be a sub-block because we\n                // would have followed the index to this\n                // sub-block from the start:\n\n                assert termExists;\n                fillTerm();\n                //if (DEBUG) System.out.println(\"        found!\");\n                return SeekStatus.FOUND;\n              }\n            }\n          }\n\n          // It is possible (and OK) that terms index pointed us\n          // at this block, but, we scanned the entire block and\n          // did not find the term to position to.  This happens\n          // when the target is after the last term in the block\n          // (but, before the next term in the index).  EG\n          // target could be foozzz, and terms index pointed us\n          // to the foo* block, but the last term in this block\n          // was fooz (and, eg, first term in the next block will\n          // bee fop).\n          //if (DEBUG) System.out.println(\"      block end\");\n          if (exactOnly) {\n            fillTerm();\n          }\n\n          // TODO: not consistent that in the\n          // not-exact case we don't next() into the next\n          // frame here\n          return SeekStatus.END;\n        }\n\n","sourceOld":"        // Target's prefix matches this block's prefix; we\n        // scan the entries check if the suffix matches.\n        public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n          assert nextEnt != -1;\n\n          termExists = true;\n          subCode = 0;\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            return SeekStatus.END;\n          }\n\n          assert prefixMatches(target);\n\n          // Loop over each entry (term or sub-block) in this block:\n          //nextTerm: while(nextEnt < entCount) {\n          nextTerm: while (true) {\n            nextEnt++;\n\n            suffix = suffixesReader.readVInt();\n\n            // if (DEBUG) {\n            //   BytesRef suffixBytesRef = new BytesRef();\n            //   suffixBytesRef.bytes = suffixBytes;\n            //   suffixBytesRef.offset = suffixesReader.getPosition();\n            //   suffixBytesRef.length = suffix;\n            //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n            // }\n\n            final int termLen = prefix + suffix;\n            startBytePos = suffixesReader.getPosition();\n            suffixesReader.skipBytes(suffix);\n\n            final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n            int targetPos = target.offset + prefix;\n\n            // Loop over bytes in the suffix, comparing to\n            // the target\n            int bytePos = startBytePos;\n            while(true) {\n              final int cmp;\n              final boolean stop;\n              if (targetPos < targetLimit) {\n                cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n                stop = false;\n              } else {\n                assert targetPos == targetLimit;\n                cmp = termLen - target.length;\n                stop = true;\n              }\n\n              if (cmp < 0) {\n                // Current entry is still before the target;\n                // keep scanning\n\n                if (nextEnt == entCount) {\n                  if (exactOnly) {\n                    fillTerm();\n                  }\n                  // We are done scanning this block\n                  break nextTerm;\n                } else {\n                  continue nextTerm;\n                }\n              } else if (cmp > 0) {\n\n                // Done!  Current entry is after target --\n                // return NOT_FOUND:\n                fillTerm();\n\n                if (!exactOnly && !termExists) {\n                  // We are on a sub-block, and caller wants\n                  // us to position to the next term after\n                  // the target, so we must recurse into the\n                  // sub-frame(s):\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                  currentFrame.loadBlock();\n                  while (currentFrame.next()) {\n                    currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                    currentFrame.loadBlock();\n                  }\n                }\n                \n                //if (DEBUG) System.out.println(\"        not found\");\n                return SeekStatus.NOT_FOUND;\n              } else if (stop) {\n                // Exact match!\n\n                // This cannot be a sub-block because we\n                // would have followed the index to this\n                // sub-block from the start:\n\n                assert termExists;\n                fillTerm();\n                //if (DEBUG) System.out.println(\"        found!\");\n                return SeekStatus.FOUND;\n              }\n            }\n          }\n\n          // It is possible (and OK) that terms index pointed us\n          // at this block, but, we scanned the entire block and\n          // did not find the term to position to.  This happens\n          // when the target is after the last term in the block\n          // (but, before the next term in the index).  EG\n          // target could be foozzz, and terms index pointed us\n          // to the foo* block, but the last term in this block\n          // was fooz (and, eg, first term in the next block will\n          // bee fop).\n          //if (DEBUG) System.out.println(\"      block end\");\n          if (exactOnly) {\n            fillTerm();\n          }\n\n          // TODO: not consistent that in the\n          // not-exact case we don't next() into the next\n          // frame here\n          return SeekStatus.END;\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5ad80176d91a6f70fe93880e43dfd697dc4e63ed","date":1400176913,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame#scanToTermLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":"        // Target's prefix matches this block's prefix; we\n        // scan the entries check if the suffix matches.\n        public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n          assert nextEnt != -1;\n\n          termExists = true;\n          subCode = 0;\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            return SeekStatus.END;\n          }\n\n          assert prefixMatches(target);\n\n          // Loop over each entry (term or sub-block) in this block:\n          //nextTerm: while(nextEnt < entCount) {\n          nextTerm: while (true) {\n            nextEnt++;\n\n            suffix = suffixesReader.readVInt();\n\n            // if (DEBUG) {\n            //   BytesRef suffixBytesRef = new BytesRef();\n            //   suffixBytesRef.bytes = suffixBytes;\n            //   suffixBytesRef.offset = suffixesReader.getPosition();\n            //   suffixBytesRef.length = suffix;\n            //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n            // }\n\n            final int termLen = prefix + suffix;\n            startBytePos = suffixesReader.getPosition();\n            suffixesReader.skipBytes(suffix);\n\n            final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n            int targetPos = target.offset + prefix;\n\n            // Loop over bytes in the suffix, comparing to\n            // the target\n            int bytePos = startBytePos;\n            while(true) {\n              final int cmp;\n              final boolean stop;\n              if (targetPos < targetLimit) {\n                cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n                stop = false;\n              } else {\n                assert targetPos == targetLimit;\n                cmp = termLen - target.length;\n                stop = true;\n              }\n\n              if (cmp < 0) {\n                // Current entry is still before the target;\n                // keep scanning\n\n                if (nextEnt == entCount) {\n                  if (exactOnly) {\n                    fillTerm();\n                  }\n                  // We are done scanning this block\n                  break nextTerm;\n                } else {\n                  continue nextTerm;\n                }\n              } else if (cmp > 0) {\n\n                // Done!  Current entry is after target --\n                // return NOT_FOUND:\n                fillTerm();\n\n                if (!exactOnly && !termExists) {\n                  // We are on a sub-block, and caller wants\n                  // us to position to the next term after\n                  // the target, so we must recurse into the\n                  // sub-frame(s):\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                  currentFrame.loadBlock();\n                  while (currentFrame.next()) {\n                    currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                    currentFrame.loadBlock();\n                  }\n                }\n                \n                //if (DEBUG) System.out.println(\"        not found\");\n                return SeekStatus.NOT_FOUND;\n              } else if (stop) {\n                // Exact match!\n\n                // This cannot be a sub-block because we\n                // would have followed the index to this\n                // sub-block from the start:\n\n                assert termExists;\n                fillTerm();\n                //if (DEBUG) System.out.println(\"        found!\");\n                return SeekStatus.FOUND;\n              }\n            }\n          }\n\n          // It is possible (and OK) that terms index pointed us\n          // at this block, but, we scanned the entire block and\n          // did not find the term to position to.  This happens\n          // when the target is after the last term in the block\n          // (but, before the next term in the index).  EG\n          // target could be foozzz, and terms index pointed us\n          // to the foo* block, but the last term in this block\n          // was fooz (and, eg, first term in the next block will\n          // bee fop).\n          //if (DEBUG) System.out.println(\"      block end\");\n          if (exactOnly) {\n            fillTerm();\n          }\n\n          // TODO: not consistent that in the\n          // not-exact case we don't next() into the next\n          // frame here\n          return SeekStatus.END;\n        }\n\n","sourceOld":"        // Target's prefix matches this block's prefix; we\n        // scan the entries check if the suffix matches.\n        public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n          assert nextEnt != -1;\n\n          termExists = true;\n          subCode = 0;\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            return SeekStatus.END;\n          }\n\n          assert prefixMatches(target);\n\n          // Loop over each entry (term or sub-block) in this block:\n          //nextTerm: while(nextEnt < entCount) {\n          nextTerm: while (true) {\n            nextEnt++;\n\n            suffix = suffixesReader.readVInt();\n\n            // if (DEBUG) {\n            //   BytesRef suffixBytesRef = new BytesRef();\n            //   suffixBytesRef.bytes = suffixBytes;\n            //   suffixBytesRef.offset = suffixesReader.getPosition();\n            //   suffixBytesRef.length = suffix;\n            //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n            // }\n\n            final int termLen = prefix + suffix;\n            startBytePos = suffixesReader.getPosition();\n            suffixesReader.skipBytes(suffix);\n\n            final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n            int targetPos = target.offset + prefix;\n\n            // Loop over bytes in the suffix, comparing to\n            // the target\n            int bytePos = startBytePos;\n            while(true) {\n              final int cmp;\n              final boolean stop;\n              if (targetPos < targetLimit) {\n                cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n                stop = false;\n              } else {\n                assert targetPos == targetLimit;\n                cmp = termLen - target.length;\n                stop = true;\n              }\n\n              if (cmp < 0) {\n                // Current entry is still before the target;\n                // keep scanning\n\n                if (nextEnt == entCount) {\n                  if (exactOnly) {\n                    fillTerm();\n                  }\n                  // We are done scanning this block\n                  break nextTerm;\n                } else {\n                  continue nextTerm;\n                }\n              } else if (cmp > 0) {\n\n                // Done!  Current entry is after target --\n                // return NOT_FOUND:\n                fillTerm();\n\n                if (!exactOnly && !termExists) {\n                  // We are on a sub-block, and caller wants\n                  // us to position to the next term after\n                  // the target, so we must recurse into the\n                  // sub-frame(s):\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                  currentFrame.loadBlock();\n                  while (currentFrame.next()) {\n                    currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                    currentFrame.loadBlock();\n                  }\n                }\n                \n                //if (DEBUG) System.out.println(\"        not found\");\n                return SeekStatus.NOT_FOUND;\n              } else if (stop) {\n                // Exact match!\n\n                // This cannot be a sub-block because we\n                // would have followed the index to this\n                // sub-block from the start:\n\n                assert termExists;\n                fillTerm();\n                //if (DEBUG) System.out.println(\"        found!\");\n                return SeekStatus.FOUND;\n              }\n            }\n          }\n\n          // It is possible (and OK) that terms index pointed us\n          // at this block, but, we scanned the entire block and\n          // did not find the term to position to.  This happens\n          // when the target is after the last term in the block\n          // (but, before the next term in the index).  EG\n          // target could be foozzz, and terms index pointed us\n          // to the foo* block, but the last term in this block\n          // was fooz (and, eg, first term in the next block will\n          // bee fop).\n          //if (DEBUG) System.out.println(\"      block end\");\n          if (exactOnly) {\n            fillTerm();\n          }\n\n          // TODO: not consistent that in the\n          // not-exact case we don't next() into the next\n          // frame here\n          return SeekStatus.END;\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame#scanToTermLeaf(BytesRef,boolean).mjava","sourceNew":null,"sourceOld":"        // Target's prefix matches this block's prefix; we\n        // scan the entries check if the suffix matches.\n        public SeekStatus scanToTermLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n          // if (DEBUG) System.out.println(\"    scanToTermLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n          assert nextEnt != -1;\n\n          termExists = true;\n          subCode = 0;\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n            }\n            return SeekStatus.END;\n          }\n\n          assert prefixMatches(target);\n\n          // Loop over each entry (term or sub-block) in this block:\n          //nextTerm: while(nextEnt < entCount) {\n          nextTerm: while (true) {\n            nextEnt++;\n\n            suffix = suffixesReader.readVInt();\n\n            // if (DEBUG) {\n            //   BytesRef suffixBytesRef = new BytesRef();\n            //   suffixBytesRef.bytes = suffixBytes;\n            //   suffixBytesRef.offset = suffixesReader.getPosition();\n            //   suffixBytesRef.length = suffix;\n            //   System.out.println(\"      cycle: term \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n            // }\n\n            final int termLen = prefix + suffix;\n            startBytePos = suffixesReader.getPosition();\n            suffixesReader.skipBytes(suffix);\n\n            final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n            int targetPos = target.offset + prefix;\n\n            // Loop over bytes in the suffix, comparing to\n            // the target\n            int bytePos = startBytePos;\n            while(true) {\n              final int cmp;\n              final boolean stop;\n              if (targetPos < targetLimit) {\n                cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n                stop = false;\n              } else {\n                assert targetPos == targetLimit;\n                cmp = termLen - target.length;\n                stop = true;\n              }\n\n              if (cmp < 0) {\n                // Current entry is still before the target;\n                // keep scanning\n\n                if (nextEnt == entCount) {\n                  if (exactOnly) {\n                    fillTerm();\n                  }\n                  // We are done scanning this block\n                  break nextTerm;\n                } else {\n                  continue nextTerm;\n                }\n              } else if (cmp > 0) {\n\n                // Done!  Current entry is after target --\n                // return NOT_FOUND:\n                fillTerm();\n\n                if (!exactOnly && !termExists) {\n                  // We are on a sub-block, and caller wants\n                  // us to position to the next term after\n                  // the target, so we must recurse into the\n                  // sub-frame(s):\n                  currentFrame = pushFrame(null, currentFrame.lastSubFP, termLen);\n                  currentFrame.loadBlock();\n                  while (currentFrame.next()) {\n                    currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n                    currentFrame.loadBlock();\n                  }\n                }\n                \n                //if (DEBUG) System.out.println(\"        not found\");\n                return SeekStatus.NOT_FOUND;\n              } else if (stop) {\n                // Exact match!\n\n                // This cannot be a sub-block because we\n                // would have followed the index to this\n                // sub-block from the start:\n\n                assert termExists;\n                fillTerm();\n                //if (DEBUG) System.out.println(\"        found!\");\n                return SeekStatus.FOUND;\n              }\n            }\n          }\n\n          // It is possible (and OK) that terms index pointed us\n          // at this block, but, we scanned the entire block and\n          // did not find the term to position to.  This happens\n          // when the target is after the last term in the block\n          // (but, before the next term in the index).  EG\n          // target could be foozzz, and terms index pointed us\n          // to the foo* block, but the last term in this block\n          // was fooz (and, eg, first term in the next block will\n          // bee fop).\n          //if (DEBUG) System.out.println(\"      block end\");\n          if (exactOnly) {\n            fillTerm();\n          }\n\n          // TODO: not consistent that in the\n          // not-exact case we don't next() into the next\n          // frame here\n          return SeekStatus.END;\n        }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4d637064d608752565d4f9f41b2497dfdfdde50e":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","5ad80176d91a6f70fe93880e43dfd697dc4e63ed"],"5ad80176d91a6f70fe93880e43dfd697dc4e63ed":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4d637064d608752565d4f9f41b2497dfdfdde50e"]},"commit2Childs":{"4d637064d608752565d4f9f41b2497dfdfdde50e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ad80176d91a6f70fe93880e43dfd697dc4e63ed":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4d637064d608752565d4f9f41b2497dfdfdde50e","5ad80176d91a6f70fe93880e43dfd697dc4e63ed"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}