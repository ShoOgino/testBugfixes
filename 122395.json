{"path":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","commits":[{"id":"3cd7782b032787117c986a2278d05b25056b2eba","date":1326755795,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"/dev/null","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random, 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random.nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(IndexReader.AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76ea4531bf2fa6dd07ba0b7fb4bb86881bbe5f62","date":1327853020,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random, 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random.nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random, 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random.nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(IndexReader.AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random, 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random.nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random, 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random.nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(IndexReader.AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"629c38c4ae4e303d0617e05fbfe508140b32f0a3","date":1334500904,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random,\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random, 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random.nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["c8376c8b9c659015b6e2a23a8c7275ea203eeef3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","pathOld":"modules/join/src/test/org/apache/lucene/search/join/TestJoinUtil#executeRandomJoin(boolean,int,int).mjava","sourceNew":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  private void executeRandomJoin(boolean multipleValuesPerDocument, int maxIndexIter, int maxSearchIter) throws Exception {\n    for (int indexIter = 1; indexIter <= maxIndexIter; indexIter++) {\n      if (VERBOSE) {\n        System.out.println(\"indexIter=\" + indexIter);\n      }\n      Directory dir = newDirectory();\n      RandomIndexWriter w = new RandomIndexWriter(\n          random(),\n          dir,\n          newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random(), MockTokenizer.KEYWORD, false)).setMergePolicy(newLogMergePolicy())\n      );\n      int numberOfDocumentsToIndex = _TestUtil.nextInt(random(), 87, 764);\n      IndexIterationContext context = createContext(numberOfDocumentsToIndex, w, multipleValuesPerDocument);\n\n      IndexReader topLevelReader = w.getReader();\n      w.close();\n      for (int searchIter = 1; searchIter <= maxSearchIter; searchIter++) {\n        if (VERBOSE) {\n          System.out.println(\"searchIter=\" + searchIter);\n        }\n        IndexSearcher indexSearcher = newSearcher(topLevelReader);\n\n        int r = random().nextInt(context.randomUniqueValues.length);\n        boolean from = context.randomFrom[r];\n        String randomValue = context.randomUniqueValues[r];\n        FixedBitSet expectedResult = createExpectedResult(randomValue, from, indexSearcher.getIndexReader(), context);\n\n        Query actualQuery = new TermQuery(new Term(\"value\", randomValue));\n        if (VERBOSE) {\n          System.out.println(\"actualQuery=\" + actualQuery);\n        }\n        Query joinQuery;\n        if (from) {\n          joinQuery = JoinUtil.createJoinQuery(\"from\", multipleValuesPerDocument, \"to\", actualQuery, indexSearcher);\n        } else {\n          joinQuery = JoinUtil.createJoinQuery(\"to\", multipleValuesPerDocument, \"from\", actualQuery, indexSearcher);\n        }\n        if (VERBOSE) {\n          System.out.println(\"joinQuery=\" + joinQuery);\n        }\n\n        // Need to know all documents that have matches. TopDocs doesn't give me that and then I'd be also testing TopDocsCollector...\n        final FixedBitSet actualResult = new FixedBitSet(indexSearcher.getIndexReader().maxDoc());\n        indexSearcher.search(joinQuery, new Collector() {\n\n          int docBase;\n\n          public void collect(int doc) throws IOException {\n            actualResult.set(doc + docBase);\n          }\n\n          public void setNextReader(AtomicReaderContext context) throws IOException {\n            docBase = context.docBase;\n          }\n\n          public void setScorer(Scorer scorer) throws IOException {\n          }\n\n          public boolean acceptsDocsOutOfOrder() {\n            return true;\n          }\n        });\n\n        if (VERBOSE) {\n          System.out.println(\"expected cardinality:\" + expectedResult.cardinality());\n          DocIdSetIterator iterator = expectedResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Expected doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n          System.out.println(\"actual cardinality:\" + actualResult.cardinality());\n          iterator = actualResult.iterator();\n          for (int doc = iterator.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = iterator.nextDoc()) {\n            System.out.println(String.format(\"Actual doc[%d] with id value %s\", doc, indexSearcher.doc(doc).get(\"id\")));\n          }\n        }\n\n        assertEquals(expectedResult, actualResult);\n      }\n      topLevelReader.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"3cd7782b032787117c986a2278d05b25056b2eba":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"76ea4531bf2fa6dd07ba0b7fb4bb86881bbe5f62":["3cd7782b032787117c986a2278d05b25056b2eba"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3cd7782b032787117c986a2278d05b25056b2eba","76ea4531bf2fa6dd07ba0b7fb4bb86881bbe5f62"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cd7782b032787117c986a2278d05b25056b2eba":["76ea4531bf2fa6dd07ba0b7fb4bb86881bbe5f62","5cab9a86bd67202d20b6adc463008c8e982b070a"],"76ea4531bf2fa6dd07ba0b7fb4bb86881bbe5f62":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cd7782b032787117c986a2278d05b25056b2eba"],"629c38c4ae4e303d0617e05fbfe508140b32f0a3":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["629c38c4ae4e303d0617e05fbfe508140b32f0a3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}