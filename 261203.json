{"path":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"/dev/null","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":null,"sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"/dev/null","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/JdbcDataSource#createConnectionFactory(Context,Properties).mjava","sourceNew":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","sourceOld":"  protected Callable<Connection> createConnectionFactory(final Context context,\n                                       final Properties initProps) {\n//    final VariableResolver resolver = context.getVariableResolver();\n    resolveVariables(context, initProps);\n    final String jndiName = initProps.getProperty(JNDI_NAME);\n    final String url = initProps.getProperty(URL);\n    final String driver = initProps.getProperty(DRIVER);\n\n    if (url == null && jndiName == null)\n      throw new DataImportHandlerException(SEVERE,\n              \"JDBC URL or JNDI name has to be specified\");\n\n    if (driver != null) {\n      try {\n        DocBuilder.loadClass(driver, context.getSolrCore());\n      } catch (ClassNotFoundException e) {\n        wrapAndThrow(SEVERE, e, \"Could not load driver: \" + driver);\n      }\n    } else {\n      if(jndiName == null){\n        throw new DataImportHandlerException(SEVERE, \"One of driver or jndiName must be specified in the data source\");\n      }\n    }\n\n    String s = initProps.getProperty(\"maxRows\");\n    if (s != null) {\n      maxRows = Integer.parseInt(s);\n    }\n\n    return factory = new Callable<Connection>() {\n      public Connection call() throws Exception {\n        LOG.info(\"Creating a connection for entity \"\n                + context.getEntityAttribute(DataImporter.NAME) + \" with URL: \"\n                + url);\n        long start = System.currentTimeMillis();\n        Connection c = null;\n        try {\n          if(url != null){\n            c = DriverManager.getConnection(url, initProps);\n          } else if(jndiName != null){\n            InitialContext ctx =  new InitialContext();\n            Object jndival =  ctx.lookup(jndiName);\n            if (jndival instanceof javax.sql.DataSource) {\n              javax.sql.DataSource dataSource = (javax.sql.DataSource) jndival;\n              String user = (String) initProps.get(\"user\");\n              String pass = (String) initProps.get(\"password\");\n              if(user == null || user.trim().equals(\"\")){\n                c = dataSource.getConnection();\n              } else {\n                c = dataSource.getConnection(user, pass);\n              }\n            } else {\n              throw new DataImportHandlerException(SEVERE,\n                      \"the jndi name : '\"+jndiName +\"' is not a valid javax.sql.DataSource\");\n            }\n          }\n        } catch (SQLException e) {\n          // DriverManager does not allow you to use a driver which is not loaded through\n          // the class loader of the class which is trying to make the connection.\n          // This is a workaround for cases where the user puts the driver jar in the\n          // solr.home/lib or solr.home/core/lib directories.\n          Driver d = (Driver) DocBuilder.loadClass(driver, context.getSolrCore()).newInstance();\n          c = d.connect(url, initProps);\n        }\n        if (c != null) {\n          if (Boolean.parseBoolean(initProps.getProperty(\"readOnly\"))) {\n            c.setReadOnly(true);\n            // Add other sane defaults\n            c.setAutoCommit(true);\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          }\n          if (!Boolean.parseBoolean(initProps.getProperty(\"autoCommit\"))) {\n            c.setAutoCommit(false);\n          }\n          String transactionIsolation = initProps.getProperty(\"transactionIsolation\");\n          if (\"TRANSACTION_READ_UNCOMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);\n          } else if (\"TRANSACTION_READ_COMMITTED\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n          } else if (\"TRANSACTION_REPEATABLE_READ\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);\n          } else if (\"TRANSACTION_SERIALIZABLE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);\n          } else if (\"TRANSACTION_NONE\".equals(transactionIsolation)) {\n            c.setTransactionIsolation(Connection.TRANSACTION_NONE);\n          }\n          String holdability = initProps.getProperty(\"holdability\");\n          if (\"CLOSE_CURSORS_AT_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n          } else if (\"HOLD_CURSORS_OVER_COMMIT\".equals(holdability)) {\n            c.setHoldability(ResultSet.HOLD_CURSORS_OVER_COMMIT);\n          }\n        }\n        LOG.info(\"Time taken for getConnection(): \"\n                + (System.currentTimeMillis() - start));\n        return c;\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["1da8d55113b689b06716246649de6f62430f15c0","1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["1da8d55113b689b06716246649de6f62430f15c0","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"1da8d55113b689b06716246649de6f62430f15c0":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","c26f00b574427b55127e869b935845554afde1fa"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"pathCommit":null}