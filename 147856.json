{"path":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String],boolean).mjava","commits":[{"id":"a3584d3db8b472772e3329d9d95d584b68ae997e","date":1551710517,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   * @param trackJettyMetrics supply jetties with metrics registry\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson, boolean trackJettyMetrics) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n    this.trackJettyMetrics = trackJettyMetrics;\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1778938cb7fb298e6e07a43e2d5acaf552d61518","date":1559609435,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String],boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String],boolean).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   * @param trackJettyMetrics supply jetties with metrics registry\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson, boolean trackJettyMetrics) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n    this.trackJettyMetrics = trackJettyMetrics;\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      Path zkDir = baseDir.resolve(\"zookeeper/server1/data\");\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   * @param trackJettyMetrics supply jetties with metrics registry\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson, boolean trackJettyMetrics) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n    this.trackJettyMetrics = trackJettyMetrics;\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      String zkDir = baseDir.resolve(\"zookeeper/server1/data\").toString();\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String],boolean).mjava","pathOld":"solr/test-framework/src/java/org/apache/solr/cloud/MiniSolrCloudCluster#MiniSolrCloudCluster(int,Path,String,JettyConfig,ZkTestServer,Optional[String],boolean).mjava","sourceNew":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   * @param trackJettyMetrics supply jetties with metrics registry\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson, boolean trackJettyMetrics) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n    this.trackJettyMetrics = trackJettyMetrics;\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      Path zkDir = baseDir.resolve(\"zookeeper/server1/data\");\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","sourceOld":"  /**\n   * Create a MiniSolrCloudCluster.\n   * Note - this constructor visibility is changed to package protected so as to\n   * discourage its usage. Ideally *new* functionality should use {@linkplain SolrCloudTestCase}\n   * to configure any additional parameters.\n   *\n   * @param numServers number of Solr servers to start\n   * @param baseDir base directory that the mini cluster should be run from\n   * @param solrXml solr.xml file to be uploaded to ZooKeeper\n   * @param jettyConfig Jetty configuration\n   * @param zkTestServer ZkTestServer to use.  If null, one will be created\n   * @param securityJson A string representation of security.json file (optional).\n   * @param trackJettyMetrics supply jetties with metrics registry\n   *\n   * @throws Exception if there was an error starting the cluster\n   */\n   MiniSolrCloudCluster(int numServers, Path baseDir, String solrXml, JettyConfig jettyConfig,\n      ZkTestServer zkTestServer, Optional<String> securityJson, boolean trackJettyMetrics) throws Exception {\n\n    Objects.requireNonNull(securityJson);\n    this.baseDir = Objects.requireNonNull(baseDir);\n    this.jettyConfig = Objects.requireNonNull(jettyConfig);\n    this.trackJettyMetrics = trackJettyMetrics;\n\n    log.info(\"Starting cluster of {} servers in {}\", numServers, baseDir);\n\n    Files.createDirectories(baseDir);\n\n    this.externalZkServer = zkTestServer != null;\n    if (!externalZkServer) {\n      Path zkDir = baseDir.resolve(\"zookeeper/server1/data\");\n      zkTestServer = new ZkTestServer(zkDir);\n      try {\n        zkTestServer.run();\n      } catch (Exception e) {\n        log.error(\"Error starting Zk Test Server, trying again ...\");\n        zkTestServer.shutdown();\n        zkTestServer = new ZkTestServer(zkDir);\n        zkTestServer.run();\n      }\n    }\n    this.zkServer = zkTestServer;\n\n    try (SolrZkClient zkClient = new SolrZkClient(zkServer.getZkHost(), AbstractZkTestCase.TIMEOUT)) {\n      zkClient.makePath(\"/solr/solr.xml\", solrXml.getBytes(Charset.defaultCharset()), true);\n      if (jettyConfig.sslConfig != null && jettyConfig.sslConfig.isSSLMode()) {\n        zkClient.makePath(\"/solr\" + ZkStateReader.CLUSTER_PROPS, \"{'urlScheme':'https'}\".getBytes(StandardCharsets.UTF_8), true);\n      }\n      if (securityJson.isPresent()) { // configure Solr security\n        zkClient.makePath(\"/solr/security.json\", securityJson.get().getBytes(Charset.defaultCharset()), true);\n      }\n    }\n\n    // tell solr to look in zookeeper for solr.xml\n    System.setProperty(\"zkHost\", zkServer.getZkAddress());\n\n    List<Callable<JettySolrRunner>> startups = new ArrayList<>(numServers);\n    for (int i = 0; i < numServers; ++i) {\n      startups.add(() -> startJettySolrRunner(newNodeName(), jettyConfig.context, jettyConfig));\n    }\n\n    final ExecutorService executorLauncher = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory(\"jetty-launcher\"));\n    Collection<Future<JettySolrRunner>> futures = executorLauncher.invokeAll(startups);\n    ExecutorUtil.shutdownAndAwaitTermination(executorLauncher);\n    Exception startupError = checkForExceptions(\"Error starting up MiniSolrCloudCluster\", futures);\n    if (startupError != null) {\n      try {\n        this.shutdown();\n      }\n      catch (Throwable t) {\n        startupError.addSuppressed(t);\n      }\n      throw startupError;\n    }\n\n    solrClient = buildSolrClient();\n    \n    if (numServers > 0) {\n      waitForAllNodes(numServers, 60);\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["1778938cb7fb298e6e07a43e2d5acaf552d61518"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1778938cb7fb298e6e07a43e2d5acaf552d61518":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3584d3db8b472772e3329d9d95d584b68ae997e"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a3584d3db8b472772e3329d9d95d584b68ae997e":["1778938cb7fb298e6e07a43e2d5acaf552d61518"],"1778938cb7fb298e6e07a43e2d5acaf552d61518":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}