{"path":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","commits":[{"id":"b9c5c0e8e826d8fd169840564bcf8606cf81d15b","date":1473715404,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      Set<String>[] expected = new Set[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new HashSet<String>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        if (Math.min(queryTerm.length(), term.length()) > ed) {\n          while (ed < 3) {\n            expected[ed].add(term);\n            ed++;\n          }\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, terms.size(), true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n        }\n        if (actual.equals(expected[ed]) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expected[ed].contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expected[ed]) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["71da933d30aea361ccc224d6544c451cbf49916d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a2bd7751724d7c4054fbf0f8ea7fd1d14444065","date":1473757458,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        if (Math.min(queryTerm.length(), term.length()) > ed) {        \n          float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n          while (ed < 3) {\n            expected[ed].add(new TermAndScore(term, score));\n            ed++;\n          }\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      Set<String>[] expected = new Set[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new HashSet<String>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        if (Math.min(queryTerm.length(), term.length()) > ed) {\n          while (ed < 3) {\n            expected[ed].add(term);\n            ed++;\n          }\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, terms.size(), true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n        }\n        if (actual.equals(expected[ed]) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expected[ed].contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expected[ed]) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"89424def13674ea17829b41c5883c54ecc31a132","date":1473767373,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        if (Math.min(queryTerm.length(), term.length()) > ed) {        \n          float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n          while (ed < 3) {\n            expected[ed].add(new TermAndScore(term, score));\n            ed++;\n          }\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d3dec8619cc5a67c810bd49ad697d0170a32637","date":1473965066,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        if (Math.min(queryTerm.length(), term.length()) > ed) {        \n          float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n          while (ed < 3) {\n            expected[ed].add(new TermAndScore(term, score));\n            ed++;\n          }\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"/dev/null","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8fab75b7fda57c9365788e2a8ef73012ec9e76eb","date":1488279230,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    // underestimated total number of unique terms that randomSimpleString\n    // maybe generate, it assumes all terms have a length of 7\n    int vocabularySize = digits << 7;\n    int numTerms = Math.min(atLeast(100), vocabularySize);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int numTerms = atLeast(100);\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    // underestimated total number of unique terms that randomSimpleString\n    // maybe generate, it assumes all terms have a length of 7\n    int vocabularySize = digits << 7;\n    int numTerms = Math.min(atLeast(100), vocabularySize);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(200);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    // underestimated total number of unique terms that randomSimpleString\n    // maybe generate, it assumes all terms have a length of 7\n    int vocabularySize = digits << 7;\n    int numTerms = Math.min(atLeast(100), vocabularySize);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(1000);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","bugFix":["b9c5c0e8e826d8fd169840564bcf8606cf81d15b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c37ab80ad12b466f3dc92e4baa7b0cbf9aded429","date":1590107358,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/search/TestFuzzyQuery#testRandom().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    // underestimated total number of unique terms that randomSimpleString\n    // maybe generate, it assumes all terms have a length of 7\n    int vocabularySize = digits << 7;\n    int numTerms = Math.min(atLeast(100), vocabularySize);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    w.close();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(200);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, dir);\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\",\"rawtypes\"})\n  public void testRandom() throws Exception {\n    int digits = TestUtil.nextInt(random(), 2, 3);\n    // underestimated total number of unique terms that randomSimpleString\n    // maybe generate, it assumes all terms have a length of 7\n    int vocabularySize = digits << 7;\n    int numTerms = Math.min(atLeast(100), vocabularySize);\n    Set<String> terms = new HashSet<>();\n    while (terms.size() < numTerms) {\n      terms.add(randomSimpleString(digits));\n    }\n\n    Directory dir = newDirectory();\n    RandomIndexWriter w = new RandomIndexWriter(random(), dir);\n    for(String term : terms) {\n      Document doc = new Document();\n      doc.add(new StringField(\"field\", term, Field.Store.YES));\n      w.addDocument(doc);\n    }\n    DirectoryReader r = w.getReader();\n    //System.out.println(\"TEST: reader=\" + r);\n    IndexSearcher s = newSearcher(r);\n    int iters = atLeast(200);\n    for(int iter=0;iter<iters;iter++) {\n      String queryTerm = randomSimpleString(digits);\n      int prefixLength = random().nextInt(queryTerm.length());\n      String queryPrefix = queryTerm.substring(0, prefixLength);\n\n      // we don't look at scores here:\n      List<TermAndScore>[] expected = new List[3];\n      for(int ed=0;ed<3;ed++) {\n        expected[ed] = new ArrayList<TermAndScore>();\n      }\n      for(String term : terms) {\n        if (term.startsWith(queryPrefix) == false) {\n          continue;\n        }\n        int ed = getDistance(term, queryTerm);\n        float score = 1f - (float) ed / (float) Math.min(queryTerm.length(), term.length());\n        while (ed < 3) {\n          expected[ed].add(new TermAndScore(term, score));\n          ed++;\n        }\n      }\n\n      for(int ed=0;ed<3;ed++) {\n        Collections.sort(expected[ed]);\n        int queueSize = TestUtil.nextInt(random(), 1, terms.size());\n        /*\n        System.out.println(\"\\nTEST: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength);\n        for(TermAndScore ent : expected[ed]) {\n          System.out.println(\"  \" + ent);\n        }\n        */\n        FuzzyQuery query = new FuzzyQuery(new Term(\"field\", queryTerm), ed, prefixLength, queueSize, true);\n        TopDocs hits = s.search(query, terms.size());\n        Set<String> actual = new HashSet<>();\n        for(ScoreDoc hit : hits.scoreDocs) {\n          Document doc = s.doc(hit.doc);\n          actual.add(doc.get(\"field\"));\n          //System.out.println(\"   actual: \" + doc.get(\"field\") + \" score=\" + hit.score);\n        }\n        Set<String> expectedTop = new HashSet<>();\n        int limit = Math.min(queueSize, expected[ed].size());\n        for(int i=0;i<limit;i++) {\n          expectedTop.add(expected[ed].get(i).term);\n        }\n        \n        if (actual.equals(expectedTop) == false) {\n          StringBuilder sb = new StringBuilder();\n          sb.append(\"FAILED: query=\" + queryTerm + \" ed=\" + ed + \" queueSize=\" + queueSize + \" vs expected match size=\" + expected[ed].size() + \" prefixLength=\" + prefixLength + \"\\n\");\n\n          boolean first = true;\n          for(String term : actual) {\n            if (expectedTop.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these matched but shouldn't:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          first = true;\n          for(String term : expectedTop) {\n            if (actual.contains(term) == false) {\n              if (first) {\n                sb.append(\"  these did not match but should:\\n\");\n                first = false;\n              }\n              sb.append(\"    \" + term + \"\\n\");\n            }\n          }\n          throw new AssertionError(sb.toString());\n        }\n      }\n    }\n    \n    IOUtils.close(r, w, dir);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8fab75b7fda57c9365788e2a8ef73012ec9e76eb":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7d3dec8619cc5a67c810bd49ad697d0170a32637":["89424def13674ea17829b41c5883c54ecc31a132"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7d3dec8619cc5a67c810bd49ad697d0170a32637"],"3a2bd7751724d7c4054fbf0f8ea7fd1d14444065":["b9c5c0e8e826d8fd169840564bcf8606cf81d15b"],"b9c5c0e8e826d8fd169840564bcf8606cf81d15b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c37ab80ad12b466f3dc92e4baa7b0cbf9aded429"],"c37ab80ad12b466f3dc92e4baa7b0cbf9aded429":["71da933d30aea361ccc224d6544c451cbf49916d"],"71da933d30aea361ccc224d6544c451cbf49916d":["8fab75b7fda57c9365788e2a8ef73012ec9e76eb"],"89424def13674ea17829b41c5883c54ecc31a132":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3a2bd7751724d7c4054fbf0f8ea7fd1d14444065"]},"commit2Childs":{"8fab75b7fda57c9365788e2a8ef73012ec9e76eb":["71da933d30aea361ccc224d6544c451cbf49916d"],"7d3dec8619cc5a67c810bd49ad697d0170a32637":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["8fab75b7fda57c9365788e2a8ef73012ec9e76eb","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","b9c5c0e8e826d8fd169840564bcf8606cf81d15b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","89424def13674ea17829b41c5883c54ecc31a132"],"3a2bd7751724d7c4054fbf0f8ea7fd1d14444065":["89424def13674ea17829b41c5883c54ecc31a132"],"b9c5c0e8e826d8fd169840564bcf8606cf81d15b":["3a2bd7751724d7c4054fbf0f8ea7fd1d14444065"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"89424def13674ea17829b41c5883c54ecc31a132":["7d3dec8619cc5a67c810bd49ad697d0170a32637"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"c37ab80ad12b466f3dc92e4baa7b0cbf9aded429":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"71da933d30aea361ccc224d6544c451cbf49916d":["c37ab80ad12b466f3dc92e4baa7b0cbf9aded429"]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}