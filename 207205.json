{"path":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","commits":[{"id":"f653aecb322b74d99e6ecdb93765e453a3d7aa71","date":1082107025,"type":0,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"/dev/null","sourceNew":"  protected final void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted \n      deletedDocs.write(directory(), segment + \".tmp\");\n      directory().renameFile(segment + \".tmp\", segment + \".del\");\n    }\n    if(undeleteAll && directory().fileExists(segment + \".del\")){\n      directory().deleteFile(segment + \".del\");\n    }\n    if (normsDirty) {               // re-write norms \n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite();\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["15633975e2cb95a0c6eee9a600583708438ebd76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6e5d88b55f1b57feab6da94a5c635a224539bd2a","date":1095877947,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted \n      deletedDocs.write(directory(), segment + \".tmp\");\n      directory().renameFile(segment + \".tmp\", segment + \".del\");\n    }\n    if(undeleteAll && directory().fileExists(segment + \".del\")){\n      directory().deleteFile(segment + \".del\");\n    }\n    if (normsDirty) {               // re-write norms \n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite();\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":"  protected final void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted \n      deletedDocs.write(directory(), segment + \".tmp\");\n      directory().renameFile(segment + \".tmp\", segment + \".del\");\n    }\n    if(undeleteAll && directory().fileExists(segment + \".del\")){\n      directory().deleteFile(segment + \".del\");\n    }\n    if (normsDirty) {               // re-write norms \n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite();\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"950f3c7592cb559e2534e5089c78833250e156a3","date":1130557968,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      deletedDocs.write(directory(), segment + \".tmp\");\n      directory().renameFile(segment + \".tmp\", segment + \".del\");\n    }\n    if(undeleteAll && directory().fileExists(segment + \".del\")){\n      directory().deleteFile(segment + \".del\");\n    }\n    if (normsDirty) {               // re-write norms\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite();\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted \n      deletedDocs.write(directory(), segment + \".tmp\");\n      directory().renameFile(segment + \".tmp\", segment + \".del\");\n    }\n    if(undeleteAll && directory().fileExists(segment + \".del\")){\n      directory().deleteFile(segment + \".del\");\n    }\n    if (normsDirty) {               // re-write norms \n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite();\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"284c1d3c8b19931bf6f312fae7470487f5d9e580","date":1163805527,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumField(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      deletedDocs.write(directory(), segment + \".tmp\");\n      directory().renameFile(segment + \".tmp\", segment + \".del\");\n    }\n    if(undeleteAll && directory().fileExists(segment + \".del\")){\n      directory().deleteFile(segment + \".del\");\n    }\n    if (normsDirty) {               // re-write norms\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite();\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","bugFix":null,"bugIntro":["15633975e2cb95a0c6eee9a600583708438ebd76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8969a184df55d25d61e85be785987fbf830d4028","date":1168143561,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumFields(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumField(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b6187898fc4413ccd18229711786550a280383c","date":1173776782,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumFields(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      String oldDelFileName = si.getDelFileName();\n      if (oldDelFileName != null) {\n        // Mark this file for deletion.  Note that we don't\n        // actually try to delete it until the new segments files is\n        // successfully written:\n        deleter.addPendingFile(oldDelFileName);\n      }\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumFields(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"125b5699f11b58d9be0820c6ce8b1648812902e8","date":1190273227,"type":5,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#commitChanges().mjava","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":"  protected void commitChanges() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumFields(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","sourceOld":"  protected void doCommit() throws IOException {\n    if (deletedDocsDirty) {               // re-write deleted\n      si.advanceDelGen();\n\n      // We can write directly to the actual name (vs to a\n      // .tmp & renaming it) because the file is not live\n      // until segments file is written:\n      deletedDocs.write(directory(), si.getDelFileName());\n    }\n    if (undeleteAll && si.hasDeletions()) {\n      si.clearDelGen();\n    }\n    if (normsDirty) {               // re-write norms\n      si.setNumFields(fieldInfos.size());\n      Enumeration values = norms.elements();\n      while (values.hasMoreElements()) {\n        Norm norm = (Norm) values.nextElement();\n        if (norm.dirty) {\n          norm.reWrite(si);\n        }\n      }\n    }\n    deletedDocsDirty = false;\n    normsDirty = false;\n    undeleteAll = false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1","date":1244392278,"type":2,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","pathOld":"src/java/org/apache/lucene/index/DirectoryIndexReader#doCommit().mjava","sourceNew":"  /** @deprecated  */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","sourceOld":"  /** @deprecated */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7","date":1255555265,"type":4,"author":"Michael Busch","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/SegmentReader#doCommit().mjava","sourceNew":null,"sourceOld":"  /** @deprecated  */\n  protected void doCommit() throws IOException {\n    doCommit(null);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"125b5699f11b58d9be0820c6ce8b1648812902e8":["8b6187898fc4413ccd18229711786550a280383c"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["950f3c7592cb559e2534e5089c78833250e156a3"],"950f3c7592cb559e2534e5089c78833250e156a3":["6e5d88b55f1b57feab6da94a5c635a224539bd2a"],"6e5d88b55f1b57feab6da94a5c635a224539bd2a":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"8b6187898fc4413ccd18229711786550a280383c":["8969a184df55d25d61e85be785987fbf830d4028"],"8969a184df55d25d61e85be785987fbf830d4028":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7"]},"commit2Childs":{"0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1":["560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7"],"125b5699f11b58d9be0820c6ce8b1648812902e8":["0f4b0a12e9aa5d9fd24932c99a893fb6a04c74c1"],"284c1d3c8b19931bf6f312fae7470487f5d9e580":["8969a184df55d25d61e85be785987fbf830d4028"],"950f3c7592cb559e2534e5089c78833250e156a3":["284c1d3c8b19931bf6f312fae7470487f5d9e580"],"6e5d88b55f1b57feab6da94a5c635a224539bd2a":["950f3c7592cb559e2534e5089c78833250e156a3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f653aecb322b74d99e6ecdb93765e453a3d7aa71"],"8b6187898fc4413ccd18229711786550a280383c":["125b5699f11b58d9be0820c6ce8b1648812902e8"],"560b3a3bb8efcae105d6ae5fbee0f8b03c7decc7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f653aecb322b74d99e6ecdb93765e453a3d7aa71":["6e5d88b55f1b57feab6da94a5c635a224539bd2a"],"8969a184df55d25d61e85be785987fbf830d4028":["8b6187898fc4413ccd18229711786550a280383c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}