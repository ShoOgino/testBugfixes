{"path":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","pathOld":"/dev/null","sourceNew":"  /*** use DocumentBuilder now...\n  private final void addField(Document doc, String name, String val) {\n      SchemaField ftype = schema.getField(name);\n\n      // we don't check for a null val ourselves because a solr.FieldType\n      // might actually want to map it to something.  If createField()\n      // returns null, then we don't store the field.\n\n      Field field = ftype.createField(val, boost);\n      if (field != null) doc.add(field);\n  }\n\n\n  public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n    Document doc = new Document();\n    for (int i=0; i<fieldNames.length; i++) {\n      String name = fieldNames[i];\n      String val = fieldNames[i];\n\n      // first null is end of list.  client can reuse arrays if they want\n      // and just write a single null if there is unused space.\n      if (name==null) break;\n\n      addField(doc,name,val);\n    }\n    addDocument(doc);\n  }\n  ******/\n\n  public void close() throws IOException {\n    log.fine(\"Closing Writer \" + name);\n    super.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f7f08509420d59592367d932f6b559dd709ca7","date":1204748616,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","pathOld":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","sourceNew":"  /**\n   * use DocumentBuilder now...\n   * private final void addField(Document doc, String name, String val) {\n   * SchemaField ftype = schema.getField(name);\n   * <p/>\n   * // we don't check for a null val ourselves because a solr.FieldType\n   * // might actually want to map it to something.  If createField()\n   * // returns null, then we don't store the field.\n   * <p/>\n   * Field field = ftype.createField(val, boost);\n   * if (field != null) doc.add(field);\n   * }\n   * <p/>\n   * <p/>\n   * public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n   * Document doc = new Document();\n   * for (int i=0; i<fieldNames.length; i++) {\n   * String name = fieldNames[i];\n   * String val = fieldNames[i];\n   * <p/>\n   * // first null is end of list.  client can reuse arrays if they want\n   * // and just write a single null if there is unused space.\n   * if (name==null) break;\n   * <p/>\n   * addField(doc,name,val);\n   * }\n   * addDocument(doc);\n   * }\n   * ****\n   */\n\n  public void close() throws IOException {\n    log.fine(\"Closing Writer \" + name);\n    super.close();\n  }\n\n","sourceOld":"  /*** use DocumentBuilder now...\n  private final void addField(Document doc, String name, String val) {\n      SchemaField ftype = schema.getField(name);\n\n      // we don't check for a null val ourselves because a solr.FieldType\n      // might actually want to map it to something.  If createField()\n      // returns null, then we don't store the field.\n\n      Field field = ftype.createField(val, boost);\n      if (field != null) doc.add(field);\n  }\n\n\n  public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n    Document doc = new Document();\n    for (int i=0; i<fieldNames.length; i++) {\n      String name = fieldNames[i];\n      String val = fieldNames[i];\n\n      // first null is end of list.  client can reuse arrays if they want\n      // and just write a single null if there is unused space.\n      if (name==null) break;\n\n      addField(doc,name,val);\n    }\n    addDocument(doc);\n  }\n  ******/\n\n  public void close() throws IOException {\n    log.fine(\"Closing Writer \" + name);\n    super.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"00da8b51bdeae168a5b26ec506db372b219ca7a2","date":1221704186,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","pathOld":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","sourceNew":"  /**\n   * use DocumentBuilder now...\n   * private final void addField(Document doc, String name, String val) {\n   * SchemaField ftype = schema.getField(name);\n   * <p/>\n   * // we don't check for a null val ourselves because a solr.FieldType\n   * // might actually want to map it to something.  If createField()\n   * // returns null, then we don't store the field.\n   * <p/>\n   * Field field = ftype.createField(val, boost);\n   * if (field != null) doc.add(field);\n   * }\n   * <p/>\n   * <p/>\n   * public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n   * Document doc = new Document();\n   * for (int i=0; i<fieldNames.length; i++) {\n   * String name = fieldNames[i];\n   * String val = fieldNames[i];\n   * <p/>\n   * // first null is end of list.  client can reuse arrays if they want\n   * // and just write a single null if there is unused space.\n   * if (name==null) break;\n   * <p/>\n   * addField(doc,name,val);\n   * }\n   * addDocument(doc);\n   * }\n   * ****\n   */\n\n  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    super.close();\n  }\n\n","sourceOld":"  /**\n   * use DocumentBuilder now...\n   * private final void addField(Document doc, String name, String val) {\n   * SchemaField ftype = schema.getField(name);\n   * <p/>\n   * // we don't check for a null val ourselves because a solr.FieldType\n   * // might actually want to map it to something.  If createField()\n   * // returns null, then we don't store the field.\n   * <p/>\n   * Field field = ftype.createField(val, boost);\n   * if (field != null) doc.add(field);\n   * }\n   * <p/>\n   * <p/>\n   * public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n   * Document doc = new Document();\n   * for (int i=0; i<fieldNames.length; i++) {\n   * String name = fieldNames[i];\n   * String val = fieldNames[i];\n   * <p/>\n   * // first null is end of list.  client can reuse arrays if they want\n   * // and just write a single null if there is unused space.\n   * if (name==null) break;\n   * <p/>\n   * addField(doc,name,val);\n   * }\n   * addDocument(doc);\n   * }\n   * ****\n   */\n\n  public void close() throws IOException {\n    log.fine(\"Closing Writer \" + name);\n    super.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e0bc4832caa5a5ed426b1618dedc1faf34f43ec","date":1246908697,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","pathOld":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","sourceNew":"  /**\n   * use DocumentBuilder now...\n   * private final void addField(Document doc, String name, String val) {\n   * SchemaField ftype = schema.getField(name);\n   * <p/>\n   * // we don't check for a null val ourselves because a solr.FieldType\n   * // might actually want to map it to something.  If createField()\n   * // returns null, then we don't store the field.\n   * <p/>\n   * Field field = ftype.createField(val, boost);\n   * if (field != null) doc.add(field);\n   * }\n   * <p/>\n   * <p/>\n   * public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n   * Document doc = new Document();\n   * for (int i=0; i<fieldNames.length; i++) {\n   * String name = fieldNames[i];\n   * String val = fieldNames[i];\n   * <p/>\n   * // first null is end of list.  client can reuse arrays if they want\n   * // and just write a single null if there is unused space.\n   * if (name==null) break;\n   * <p/>\n   * addField(doc,name,val);\n   * }\n   * addDocument(doc);\n   * }\n   * ****\n   */\n\n  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    super.close();\n    if(infoStream != null) {\n      infoStream.close();\n    }\n  }\n\n","sourceOld":"  /**\n   * use DocumentBuilder now...\n   * private final void addField(Document doc, String name, String val) {\n   * SchemaField ftype = schema.getField(name);\n   * <p/>\n   * // we don't check for a null val ourselves because a solr.FieldType\n   * // might actually want to map it to something.  If createField()\n   * // returns null, then we don't store the field.\n   * <p/>\n   * Field field = ftype.createField(val, boost);\n   * if (field != null) doc.add(field);\n   * }\n   * <p/>\n   * <p/>\n   * public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n   * Document doc = new Document();\n   * for (int i=0; i<fieldNames.length; i++) {\n   * String name = fieldNames[i];\n   * String val = fieldNames[i];\n   * <p/>\n   * // first null is end of list.  client can reuse arrays if they want\n   * // and just write a single null if there is unused space.\n   * if (name==null) break;\n   * <p/>\n   * addField(doc,name,val);\n   * }\n   * addDocument(doc);\n   * }\n   * ****\n   */\n\n  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    super.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0d8dceae0594e66ce62ce0f775689af35a2266c","date":1251260302,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","pathOld":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","sourceNew":"  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    try {\n      super.close();\n      if(infoStream != null) {\n        infoStream.close();\n      }\n    } finally {\n      isClosed = true;\n    }\n  }\n\n","sourceOld":"  /**\n   * use DocumentBuilder now...\n   * private final void addField(Document doc, String name, String val) {\n   * SchemaField ftype = schema.getField(name);\n   * <p/>\n   * // we don't check for a null val ourselves because a solr.FieldType\n   * // might actually want to map it to something.  If createField()\n   * // returns null, then we don't store the field.\n   * <p/>\n   * Field field = ftype.createField(val, boost);\n   * if (field != null) doc.add(field);\n   * }\n   * <p/>\n   * <p/>\n   * public void addRecord(String[] fieldNames, String[] fieldValues) throws IOException {\n   * Document doc = new Document();\n   * for (int i=0; i<fieldNames.length; i++) {\n   * String name = fieldNames[i];\n   * String val = fieldNames[i];\n   * <p/>\n   * // first null is end of list.  client can reuse arrays if they want\n   * // and just write a single null if there is unused space.\n   * if (name==null) break;\n   * <p/>\n   * addField(doc,name,val);\n   * }\n   * addDocument(doc);\n   * }\n   * ****\n   */\n\n  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    super.close();\n    if(infoStream != null) {\n      infoStream.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":["1cb61792cbeba6c44e2530ca5836b96d956adb25","1cb61792cbeba6c44e2530ca5836b96d956adb25","1cb61792cbeba6c44e2530ca5836b96d956adb25","ab20a04a303d3d2a5078076f4633e0482d643cc0","ab20a04a303d3d2a5078076f4633e0482d643cc0","ab20a04a303d3d2a5078076f4633e0482d643cc0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","pathOld":"src/java/org/apache/solr/update/SolrIndexWriter#close().mjava","sourceNew":"  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    try {\n      super.close();\n      if(infoStream != null) {\n        infoStream.close();\n      }\n    } finally {\n      isClosed = true;\n    }\n  }\n\n","sourceOld":"  public void close() throws IOException {\n    log.debug(\"Closing Writer \" + name);\n    try {\n      super.close();\n      if(infoStream != null) {\n        infoStream.close();\n      }\n    } finally {\n      isClosed = true;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"41f7f08509420d59592367d932f6b559dd709ca7":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"c0d8dceae0594e66ce62ce0f775689af35a2266c":["2e0bc4832caa5a5ed426b1618dedc1faf34f43ec"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"ad94625fb8d088209f46650c8097196fec67f00c":["c0d8dceae0594e66ce62ce0f775689af35a2266c"],"2e0bc4832caa5a5ed426b1618dedc1faf34f43ec":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["41f7f08509420d59592367d932f6b559dd709ca7"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"41f7f08509420d59592367d932f6b559dd709ca7":["00da8b51bdeae168a5b26ec506db372b219ca7a2"],"c0d8dceae0594e66ce62ce0f775689af35a2266c":["ad94625fb8d088209f46650c8097196fec67f00c"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["41f7f08509420d59592367d932f6b559dd709ca7"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2e0bc4832caa5a5ed426b1618dedc1faf34f43ec":["c0d8dceae0594e66ce62ce0f775689af35a2266c"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"00da8b51bdeae168a5b26ec506db372b219ca7a2":["2e0bc4832caa5a5ed426b1618dedc1faf34f43ec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}