{"path":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","commits":[{"id":"9d22d0f5940f155267b250876fa797ff69e8e6e7","date":1400540695,"type":0,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"/dev/null","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"/dev/null","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3426e338f3c13b9647f5332ce8d1a747deb5ce01","date":1402937055,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6f080a2ab37c464dd98db173f6cbf10dc74f211","date":1402946779,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f9043cd220362869f58e50f635c13c362f8377da","date":1404227796,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 10);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"37e7502644cd23597431d66e301299b1ead2fb9b","date":1422636984,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplica(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplica(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplica(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ac97ea104d893f16aab430d9904473bc1f233f3c","date":1496249396,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3217321f3e1d7922898c6c633d17acfa840d6875","date":1496257480,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","date":1496281877,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.Delete req = new CollectionAdminRequest.Delete();\n      req.setCollectionName(testCollectionName);\n      req.process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"197bbedf08450ade98a11f4a0001448059666bec","date":1498534625,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","date":1498540685,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615bf5b56d95ed8c9bf06a402db6c817d6bff21a","date":1509492118,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n\n    createCollectionWithRetry(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n\n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);\n\n    // Insure nothing is tricky about a delete where only one shard needs to delete anything.\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n\n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas =\n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n\n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n\n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n\n    // Whether the replication factor is 1 or 2 in the delete-by-id case depends on whether the doc IDs happen to fall\n    // on a single shard or not.\n\n    Set<Integer> byIDs;\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(leader,\n        byIDs, calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), byIDs,\n        calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n    \n    CollectionAdminResponse resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n    \n    if (resp.getResponse().get(\"failure\") != null) {\n      CollectionAdminRequest.deleteCollection(testCollectionName).process(cloudClient);\n      \n      resp = createCollection(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n      \n      if (resp.getResponse().get(\"failure\") != null) {\n        fail(\"Could not create \" + testCollectionName);\n      }\n    }\n    \n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n    \n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);    \n    \n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas = \n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n    \n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n    \n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);    \n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n    \n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    \n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43f5f8344e80b4bfb2069917069430266753d2f0","date":1538584815,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n\n    createCollectionWithRetry(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n\n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    maybeAddMinRfExplicitly(2, up);\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);\n\n    // Insure nothing is tricky about a delete where only one shard needs to delete anything.\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n\n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas =\n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n\n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n\n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n\n    // Whether the replication factor is 1 or 2 in the delete-by-id case depends on whether the doc IDs happen to fall\n    // on a single shard or not.\n\n    Set<Integer> byIDs;\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(leader,\n        byIDs, calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), byIDs,\n        calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n    int minRf = 2;\n\n    createCollectionWithRetry(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n\n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    up.setParam(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);\n\n    // Insure nothing is tricky about a delete where only one shard needs to delete anything.\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n\n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas =\n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n\n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n\n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n\n    // Whether the replication factor is 1 or 2 in the delete-by-id case depends on whether the doc IDs happen to fall\n    // on a single shard or not.\n\n    Set<Integer> byIDs;\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(leader,\n        byIDs, calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), byIDs,\n        calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ReplicationFactorTest#testRf2NotUsingDirectUpdates().mjava","sourceNew":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n\n    createCollectionWithRetry(testCollectionName, \"conf1\", numShards, replicationFactor);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n\n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    maybeAddMinRfExplicitly(2, up);\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);\n\n    // Insure nothing is tricky about a delete where only one shard needs to delete anything.\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n\n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas =\n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n\n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n\n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n\n    // Whether the replication factor is 1 or 2 in the delete-by-id case depends on whether the doc IDs happen to fall\n    // on a single shard or not.\n\n    Set<Integer> byIDs;\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(leader,\n        byIDs, calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), byIDs,\n        calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    Thread.sleep(2000);\n  }\n\n","sourceOld":"  protected void testRf2NotUsingDirectUpdates() throws Exception {\n    int numShards = 2;\n    int replicationFactor = 2;\n    int maxShardsPerNode = 1;\n    String testCollectionName = \"repfacttest_c8n_2x2\";\n    String shardId = \"shard1\";\n\n    createCollectionWithRetry(testCollectionName, \"conf1\", numShards, replicationFactor, maxShardsPerNode);\n\n    cloudClient.setDefaultCollection(testCollectionName);\n    \n    List<Replica> replicas = \n        ensureAllReplicasAreActive(testCollectionName, shardId, numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n                \n    List<SolrInputDocument> batch = new ArrayList<SolrInputDocument>(10);\n    for (int i=0; i < 15; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(id, String.valueOf(i));\n      doc.addField(\"a_t\", \"hello\" + i);\n      batch.add(doc);\n    }\n\n    // send directly to the leader using HttpSolrServer instead of CloudSolrServer (to test support for non-direct updates)\n    UpdateRequest up = new UpdateRequest();\n    maybeAddMinRfExplicitly(2, up);\n    up.add(batch);\n\n    Replica leader = cloudClient.getZkStateReader().getLeaderRetry(testCollectionName, shardId);\n\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 2, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 2, testCollectionName);\n\n    // Insure nothing is tricky about a delete where only one shard needs to delete anything.\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(1), 2,\n        getSomeIds(1), 2, testCollectionName);\n\n    sendNonDirectDeletesRequestReplicaWithRetry(leader, getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), getSomeIds(2), 2,\n        getSomeIds(2), 2, testCollectionName);\n\n    // so now kill the replica of shard2 and verify the achieved rf is only 1\n    List<Replica> shard2Replicas =\n        ensureAllReplicasAreActive(testCollectionName, \"shard2\", numShards, replicationFactor, 30);\n    assertTrue(\"Expected active 1 replicas for \"+testCollectionName, replicas.size() == 1);\n\n    getProxyForReplica(shard2Replicas.get(0)).close();\n\n    Thread.sleep(2000);\n\n    // shard1 will have rf=2 but shard2 will only have rf=1\n    sendNonDirectUpdateRequestReplicaWithRetry(leader, up, 1, testCollectionName);\n    sendNonDirectUpdateRequestReplicaWithRetry(replicas.get(0), up, 1, testCollectionName);\n\n    // Whether the replication factor is 1 or 2 in the delete-by-id case depends on whether the doc IDs happen to fall\n    // on a single shard or not.\n\n    Set<Integer> byIDs;\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(leader,\n        byIDs, calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    byIDs = getSomeIds(2);\n    sendNonDirectDeletesRequestReplicaWithRetry(replicas.get(0), byIDs,\n        calcByIdRf(byIDs, testCollectionName, \"shard2\"),\n        getSomeIds(2), 1, testCollectionName);\n    // heal the partition\n    getProxyForReplica(shard2Replicas.get(0)).reopen();\n    Thread.sleep(2000);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"43f5f8344e80b4bfb2069917069430266753d2f0":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"197bbedf08450ade98a11f4a0001448059666bec":["42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["37e7502644cd23597431d66e301299b1ead2fb9b"],"3217321f3e1d7922898c6c633d17acfa840d6875":["37e7502644cd23597431d66e301299b1ead2fb9b","ac97ea104d893f16aab430d9904473bc1f233f3c"],"b7605579001505896d48b07160075a5c8b8e128e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9d22d0f5940f155267b250876fa797ff69e8e6e7"],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":["9d22d0f5940f155267b250876fa797ff69e8e6e7","3426e338f3c13b9647f5332ce8d1a747deb5ce01"],"f9043cd220362869f58e50f635c13c362f8377da":["3426e338f3c13b9647f5332ce8d1a747deb5ce01"],"3426e338f3c13b9647f5332ce8d1a747deb5ce01":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["43f5f8344e80b4bfb2069917069430266753d2f0"],"28288370235ed02234a64753cdbf0c6ec096304a":["3217321f3e1d7922898c6c633d17acfa840d6875","197bbedf08450ade98a11f4a0001448059666bec"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["37e7502644cd23597431d66e301299b1ead2fb9b","3217321f3e1d7922898c6c633d17acfa840d6875"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["37e7502644cd23597431d66e301299b1ead2fb9b","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["e9017cf144952056066919f1ebc7897ff9bd71b1","197bbedf08450ade98a11f4a0001448059666bec"],"37e7502644cd23597431d66e301299b1ead2fb9b":["f9043cd220362869f58e50f635c13c362f8377da"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["28288370235ed02234a64753cdbf0c6ec096304a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"43f5f8344e80b4bfb2069917069430266753d2f0":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"197bbedf08450ade98a11f4a0001448059666bec":["28288370235ed02234a64753cdbf0c6ec096304a","fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"ac97ea104d893f16aab430d9904473bc1f233f3c":["3217321f3e1d7922898c6c633d17acfa840d6875"],"3217321f3e1d7922898c6c633d17acfa840d6875":["28288370235ed02234a64753cdbf0c6ec096304a","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f"],"b7605579001505896d48b07160075a5c8b8e128e":[],"c6f080a2ab37c464dd98db173f6cbf10dc74f211":[],"3426e338f3c13b9647f5332ce8d1a747deb5ce01":["c6f080a2ab37c464dd98db173f6cbf10dc74f211","f9043cd220362869f58e50f635c13c362f8377da"],"f9043cd220362869f58e50f635c13c362f8377da":["37e7502644cd23597431d66e301299b1ead2fb9b"],"42dc7f2d60851668d9efa2d12baa1d4ebe54b12f":["197bbedf08450ade98a11f4a0001448059666bec","e9017cf144952056066919f1ebc7897ff9bd71b1"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"28288370235ed02234a64753cdbf0c6ec096304a":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["b7605579001505896d48b07160075a5c8b8e128e","c6f080a2ab37c464dd98db173f6cbf10dc74f211","3426e338f3c13b9647f5332ce8d1a747deb5ce01"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b7605579001505896d48b07160075a5c8b8e128e","9d22d0f5940f155267b250876fa797ff69e8e6e7"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":[],"37e7502644cd23597431d66e301299b1ead2fb9b":["ac97ea104d893f16aab430d9904473bc1f233f3c","3217321f3e1d7922898c6c633d17acfa840d6875","42dc7f2d60851668d9efa2d12baa1d4ebe54b12f","e9017cf144952056066919f1ebc7897ff9bd71b1"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["43f5f8344e80b4bfb2069917069430266753d2f0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7605579001505896d48b07160075a5c8b8e128e","c6f080a2ab37c464dd98db173f6cbf10dc74f211","fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}