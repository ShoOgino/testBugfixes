{"path":"lucene/core/src/java/org/apache/lucene/geo/ComponentTree#createTree(Component2D[],int,int,boolean).mjava","commits":[{"id":"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","date":1571074565,"type":1,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/ComponentTree#createTree(Component2D[],int,int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/geo/EdgeTree#createTree(EdgeTree[],int,int,boolean).mjava","sourceNew":"  /** Creates tree from sorted components (with range low and high inclusive) */\n  private static ComponentTree createTree(Component2D[] components, int low, int high, boolean splitX) {\n    if (low > high) {\n      return null;\n    }\n    final int mid = (low + high) >>> 1;\n    if (low < high) {\n      Comparator<Component2D> comparator;\n      if (splitX) {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.getMinX(), right.getMinX());\n          if (ret == 0) {\n            ret = Double.compare(left.getMaxX(), right.getMaxX());\n          }\n          return ret;\n        };\n      } else {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.getMinY(), right.getMinY());\n          if (ret == 0) {\n            ret = Double.compare(left.getMaxY(), right.getMaxY());\n          }\n          return ret;\n        };\n      }\n      ArrayUtil.select(components, low, high + 1, mid, comparator);\n    }\n    ComponentTree newNode = new ComponentTree(components[mid], splitX);\n    // find children\n    newNode.left = createTree(components, low, mid - 1, !splitX);\n    newNode.right = createTree(components, mid + 1, high, !splitX);\n\n    // pull up max values to this node\n    if (newNode.left != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.left.getMaxX());\n      newNode.maxY = Math.max(newNode.maxY, newNode.left.getMaxY());\n    }\n    if (newNode.right != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.right.getMaxX());\n      newNode.maxY = Math.max(newNode.maxY, newNode.right.getMaxY());\n    }\n    return newNode;\n  }\n\n","sourceOld":"  /** Creates tree from sorted components (with range low and high inclusive) */\n  protected static EdgeTree createTree(EdgeTree components[], int low, int high, boolean splitX) {\n    if (low > high) {\n      return null;\n    }\n    final int mid = (low + high) >>> 1;\n    if (low < high) {\n      Comparator<EdgeTree> comparator;\n      if (splitX) {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.minLon, right.minLon);\n          if (ret == 0) {\n            ret = Double.compare(left.maxX, right.maxX);\n          }\n          return ret;\n        };\n      } else {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.minLat, right.minLat);\n          if (ret == 0) {\n            ret = Double.compare(left.maxY, right.maxY);\n          }\n          return ret;\n        };\n      }\n      ArrayUtil.select(components, low, high + 1, mid, comparator);\n    }\n    // add midpoint\n    EdgeTree newNode = components[mid];\n    newNode.splitX = splitX;\n    // add children\n    newNode.left = createTree(components, low, mid - 1, !splitX);\n    newNode.right = createTree(components, mid + 1, high, !splitX);\n    // pull up max values to this node\n    if (newNode.left != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.left.maxX);\n      newNode.maxY = Math.max(newNode.maxY, newNode.left.maxY);\n    }\n    if (newNode.right != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.right.maxX);\n      newNode.maxY = Math.max(newNode.maxY, newNode.right.maxY);\n    }\n    return newNode;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":0,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/geo/ComponentTree#createTree(Component2D[],int,int,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Creates tree from sorted components (with range low and high inclusive) */\n  private static ComponentTree createTree(Component2D[] components, int low, int high, boolean splitX) {\n    if (low > high) {\n      return null;\n    }\n    final int mid = (low + high) >>> 1;\n    if (low < high) {\n      Comparator<Component2D> comparator;\n      if (splitX) {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.getMinX(), right.getMinX());\n          if (ret == 0) {\n            ret = Double.compare(left.getMaxX(), right.getMaxX());\n          }\n          return ret;\n        };\n      } else {\n        comparator = (left, right) -> {\n          int ret = Double.compare(left.getMinY(), right.getMinY());\n          if (ret == 0) {\n            ret = Double.compare(left.getMaxY(), right.getMaxY());\n          }\n          return ret;\n        };\n      }\n      ArrayUtil.select(components, low, high + 1, mid, comparator);\n    }\n    ComponentTree newNode = new ComponentTree(components[mid], splitX);\n    // find children\n    newNode.left = createTree(components, low, mid - 1, !splitX);\n    newNode.right = createTree(components, mid + 1, high, !splitX);\n\n    // pull up max values to this node\n    if (newNode.left != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.left.getMaxX());\n      newNode.maxY = Math.max(newNode.maxY, newNode.left.getMaxY());\n    }\n    if (newNode.right != null) {\n      newNode.maxX = Math.max(newNode.maxX, newNode.right.getMaxX());\n      newNode.maxY = Math.max(newNode.maxY, newNode.right.getMaxY());\n    }\n    return newNode;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b5e250f1fb163f190f5ec72b6eeb8271162d8ae1"]},"commit2Childs":{"b5e250f1fb163f190f5ec72b6eeb8271162d8ae1":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b5e250f1fb163f190f5ec72b6eeb8271162d8ae1","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}