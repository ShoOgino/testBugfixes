{"path":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","commits":[{"id":"99a533edf1b9ea2c1b85e012d6e826545389e9c8","date":1329256696,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"/dev/null","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    oneInstanceCollectionClients.put(oneInstanceCollection , collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n    assertEquals(oneDocs, threeDocs);\n    assertEquals(twoDocs, fourDocs);\n    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7ea7454b4afcb5dc9f7504f83d77b134df2b7c57","88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ea4018996a4853ecfb1c797beede737c90da6c3b","date":1329429759,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    oneInstanceCollectionClients.put(oneInstanceCollection , collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n    assertEquals(oneDocs, threeDocs);\n    assertEquals(twoDocs, fourDocs);\n    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"shard1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    oneInstanceCollectionClients.put(oneInstanceCollection , collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n    assertEquals(oneDocs, threeDocs);\n    assertEquals(twoDocs, fourDocs);\n    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8","date":1329853856,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"shard1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    oneInstanceCollectionClients.put(oneInstanceCollection , collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n    assertEquals(oneDocs, threeDocs);\n    assertEquals(twoDocs, fourDocs);\n    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"shard1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":["7ea7454b4afcb5dc9f7504f83d77b134df2b7c57","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5b606c730b37f5bfe8c7cc9b3d105519f0bdfbd1","date":1329909246,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"shard1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    oneInstanceCollectionClients.put(oneInstanceCollection , collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n    assertEquals(oneDocs, threeDocs);\n    assertEquals(twoDocs, fourDocs);\n    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"shard1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7321b77a7bc3edfebd637ef273e9dfaa9969eba6","date":1333023097,"type":3,"author":"Sami Siren","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((CommonsHttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"33d0ed80b7b47e34ad3ff033a77544563aba3085","date":1341244632,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsly get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateCloudState(true);\n    Map<String,Slice> slices = zkStateReader.getCloudState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fa64435b5902ce266c23755a4a00691a3285dab8","date":1347243290,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1... \n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getShards().values().iterator().next().get(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    String baseUrl = ((HttpSolrServer) client).getBaseURL();\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"bugIntro":["88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"88f39c3b3a16aebc5a91335341c7ad5b560e2277","date":1350066344,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":["99a533edf1b9ea2c1b85e012d6e826545389e9c8","e19067e820b148e8dc0b240da4f2771cf7b68252"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d82832af39f94dbb58a3130fd216ff1d49435589","date":1350147242,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"db4fdbf3d262768eabc027cd8321edca0cd11fa8","date":1350574784,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createCollection(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c215736a9e29403edd2132d9f0829a287b428df4","date":1354641965,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, solrj.getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, solrj.getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = solrj.query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = solrj.getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlices(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(solrj.getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9cc12873abcfb571113b5c48ffc3475fcf53769","date":1359915820,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(30000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3e4d4ec39bf5396230748ca859ff05ab024b6fc5","date":1360112310,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(30000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(30000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Request> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(30000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":["d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c3e46d3417c353d7be14509cfab11b315927fe","date":1382292560,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(30000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7ea7454b4afcb5dc9f7504f83d77b134df2b7c57","date":1391252295,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = collectionClients.get(0);\n    SolrServer client2 = collectionClients.get(1);\n    SolrServer client3 = collectionClients.get(2);\n    SolrServer client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    server.shutdown();\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    for (SolrServer aClient : collectionClients) {\n      aClient.shutdown();\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    otherCollectionClients.put(oneInstanceCollection2, collectionClients);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = createNewSolrServer(oneInstanceCollection2 + \"1\", baseUrl);\n    SolrServer client2 = createNewSolrServer(oneInstanceCollection2 + \"2\", baseUrl);\n    SolrServer client3 = createNewSolrServer(oneInstanceCollection2 + \"3\", baseUrl);\n    SolrServer client4 = createNewSolrServer(oneInstanceCollection2 + \"4\", baseUrl);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n  }\n\n","bugFix":["99a533edf1b9ea2c1b85e012d6e826545389e9c8","d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<>();\n    SolrServer client = clients.get(0);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = collectionClients.get(0);\n    SolrServer client2 = collectionClients.get(1);\n    SolrServer client3 = collectionClients.get(2);\n    SolrServer client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    server.shutdown();\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    for (SolrServer aClient : collectionClients) {\n      aClient.shutdown();\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<SolrServer>();\n    SolrServer client = clients.get(0);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = collectionClients.get(0);\n    SolrServer client2 = collectionClients.get(1);\n    SolrServer client3 = collectionClients.get(2);\n    SolrServer client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    server.shutdown();\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    for (SolrServer aClient : collectionClients) {\n      aClient.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrClient unloadClient = new HttpSolrClient(baseUrl);\n    unloadClient.setConnectionTimeout(15000);\n    unloadClient.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    unloadClient.request(unloadCmd);\n    unloadClient.shutdown();\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    for (SolrClient aClient : collectionClients) {\n      aClient.shutdown();\n    }\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrServer> collectionClients = new ArrayList<>();\n    SolrServer client = clients.get(0);\n    final String baseUrl = ((HttpSolrServer) client).getBaseURL().substring(\n        0,\n        ((HttpSolrServer) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrServer client1 = collectionClients.get(0);\n    SolrServer client2 = collectionClients.get(1);\n    SolrServer client3 = collectionClients.get(2);\n    SolrServer client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrServer().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrServer().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrServer().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrServer().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrServer server = new HttpSolrServer(baseUrl);\n    server.setConnectionTimeout(15000);\n    server.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    server.request(unloadCmd);\n    server.shutdown();\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    for (SolrServer aClient : collectionClients) {\n      aClient.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    HttpSolrClient unloadClient = new HttpSolrClient(baseUrl);\n    unloadClient.setConnectionTimeout(15000);\n    unloadClient.setSoTimeout(60000);\n    Unload unloadCmd = new Unload(true);\n    unloadCmd.setCoreName(props.getCoreName());\n    \n    String leader = props.getCoreUrl();\n    \n    unloadClient.request(unloadCmd);\n    unloadClient.shutdown();\n    \n    int tries = 50;\n    while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n      Thread.sleep(100);\n      if (tries-- == 0) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    for (SolrClient aClient : collectionClients) {\n      aClient.shutdown();\n    }\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"102da6baafc0f534a59f31729343dbab9d3b9e9a","date":1438410244,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.updateClusterState();\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.updateClusterState(true);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","date":1457343183,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.updateClusterState();\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = new HttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a9b4296bd51ca61b482138791478afdd0f7d3a3d","date":1498058739,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"197bbedf08450ade98a11f4a0001448059666bec","date":1498534625,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","date":1498540685,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    System.clearProperty(\"numShards\");\n    List<SolrClient> collectionClients = new ArrayList<>();\n    SolrClient client = clients.get(0);\n    final String baseUrl = ((HttpSolrClient) client).getBaseURL().substring(\n        0,\n        ((HttpSolrClient) client).getBaseURL().length()\n            - DEFAULT_COLLECTION.length() - 1);\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 1, \"slice1\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 2, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 3, \"slice2\");\n    createSolrCore(oneInstanceCollection2, collectionClients, baseUrl, 4, \"slice1\");\n    \n   while (pending != null && pending.size() > 0) {\n      \n      Future<Object> future = completionService.take();\n      pending.remove(future);\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    String roles = slices.get(\"slice1\").getReplicasMap().values().iterator().next().getStr(ZkStateReader.ROLES_PROP);\n    assertEquals(\"none\", roles);\n    \n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"slice1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(baseUrl)) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"slice1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43d1e498704edd2bba13548a189eed4dfccff11b","date":1499143458,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString())) {\n      unloadClient.setConnectionTimeout(15000);\n      unloadClient.setSoTimeout(60000);\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getCollection(oneInstanceCollection2).getSlicesMap();\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState()\n        .getCollection(oneInstanceCollection2).getLeader(\"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":["a9b4296bd51ca61b482138791478afdd0f7d3a3d","c5a558d54519c651068ddb202f03befefb1514a7"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getCollection(oneInstanceCollection2).getSlicesMap();\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState()\n        .getCollection(oneInstanceCollection2).getLeader(\"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getSlicesMap(oneInstanceCollection2);\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState().getLeader(oneInstanceCollection2, \"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n      \n      \n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getCollection(oneInstanceCollection2).getSlicesMap();\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState()\n        .getCollection(oneInstanceCollection2).getLeader(\"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n      \n      testExecutor.execute(new Runnable() {\n        \n        @Override\n        public void run() {\n          try {\n            unloadClient.request(unloadCmd);\n          } catch (SolrServerException e) {\n            throw new RuntimeException(e);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n\n      try {\n        getCommonCloudSolrClient().getZkStateReader().waitForState(oneInstanceCollection2, 20000, TimeUnit.MILLISECONDS, (n, c) -> {\n          \n \n          try {\n            if (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n              return false;\n            }\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n          return true;\n        });\n      } catch (TimeoutException | InterruptedException e) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getCollection(oneInstanceCollection2).getSlicesMap();\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState()\n        .getCollection(oneInstanceCollection2).getLeader(\"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n\n      unloadClient.request(unloadCmd);\n\n      int tries = 50;\n      while (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n        Thread.sleep(100);\n        if (tries-- == 0) {\n          fail(\"Leader never changed\");\n        }\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":["a9b4296bd51ca61b482138791478afdd0f7d3a3d","cc3b13b430571c2e169f98fe38e1e7666f88522d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/BasicDistributedZkTest#testANewCollectionInOneInstanceWithManualShardAssignement().mjava","sourceNew":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n      \n      \n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getCollection(oneInstanceCollection2).getSlicesMap();\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState()\n        .getCollection(oneInstanceCollection2).getLeader(\"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n      \n      testExecutor.execute(new Runnable() {\n        \n        @Override\n        public void run() {\n          try {\n            unloadClient.request(unloadCmd);\n          } catch (SolrServerException e) {\n            throw new RuntimeException(e);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n\n      try {\n        getCommonCloudSolrClient().getZkStateReader().waitForState(oneInstanceCollection2, 20000, TimeUnit.MILLISECONDS, (n, c) -> {\n          \n \n          try {\n            if (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n              return false;\n            }\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n          return true;\n        });\n      } catch (TimeoutException | InterruptedException e) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","sourceOld":"  private void testANewCollectionInOneInstanceWithManualShardAssignement() throws Exception {\n    log.info(\"### STARTING testANewCollectionInOneInstanceWithManualShardAssignement\");\n    assertEquals(0, CollectionAdminRequest.createCollection(oneInstanceCollection2, \"conf1\", 2, 2)\n        .setCreateNodeSet(\"\")\n        .setMaxShardsPerNode(4)\n        .process(cloudClient).getStatus());\n\n    List<SolrClient> collectionClients = new ArrayList<>();\n    for (int i = 0; i < 4; i++) {\n      CollectionAdminResponse resp = CollectionAdminRequest\n          .addReplicaToShard(oneInstanceCollection2, \"shard\" + ((i%2)+1))\n          .setNode(jettys.get(0).getNodeName())\n          .process(cloudClient);\n      for (String coreName : resp.getCollectionCoresStatus().keySet()) {\n        collectionClients.add(createNewSolrClient(coreName, jettys.get(0).getBaseUrl().toString()));\n      }\n      \n      \n    }\n    \n    SolrClient client1 = collectionClients.get(0);\n    SolrClient client2 = collectionClients.get(1);\n    SolrClient client3 = collectionClients.get(2);\n    SolrClient client4 = collectionClients.get(3);\n    \n\n    // no one should be recovering\n    waitForRecoveriesToFinish(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader(), false, true);\n    \n    assertAllActive(oneInstanceCollection2, getCommonCloudSolrClient().getZkStateReader());\n    \n    //printLayout();\n    \n   // TODO: enable when we don't falsely get slice1...\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice1\", 30000);\n   // solrj.getZkStateReader().getLeaderUrl(oneInstanceCollection2, \"slice2\", 30000);\n    client2.add(getDoc(id, \"1\")); \n    client3.add(getDoc(id, \"2\")); \n    client4.add(getDoc(id, \"3\")); \n    \n    client1.commit();\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"distrib\", false);\n    long oneDocs = client1.query(query).getResults().getNumFound();\n    long twoDocs = client2.query(query).getResults().getNumFound();\n    long threeDocs = client3.query(query).getResults().getNumFound();\n    long fourDocs = client4.query(query).getResults().getNumFound();\n    \n    query.set(\"collection\", oneInstanceCollection2);\n    query.set(\"distrib\", true);\n    long allDocs = getCommonCloudSolrClient().query(query).getResults().getNumFound();\n    \n//    System.out.println(\"1:\" + oneDocs);\n//    System.out.println(\"2:\" + twoDocs);\n//    System.out.println(\"3:\" + threeDocs);\n//    System.out.println(\"4:\" + fourDocs);\n//    System.out.println(\"All Docs:\" + allDocs);\n    \n//    assertEquals(oneDocs, threeDocs);\n//    assertEquals(twoDocs, fourDocs);\n//    assertNotSame(oneDocs, twoDocs);\n    assertEquals(3, allDocs);\n    \n    // we added a role of none on these creates - check for it\n    ZkStateReader zkStateReader = getCommonCloudSolrClient().getZkStateReader();\n    zkStateReader.forceUpdateCollection(oneInstanceCollection2);\n    Map<String,Slice> slices = zkStateReader.getClusterState().getCollection(oneInstanceCollection2).getSlicesMap();\n    assertNotNull(slices);\n    \n    ZkCoreNodeProps props = new ZkCoreNodeProps(getCommonCloudSolrClient().getZkStateReader().getClusterState()\n        .getCollection(oneInstanceCollection2).getLeader(\"shard1\"));\n    \n    // now test that unloading a core gets us a new leader\n    try (HttpSolrClient unloadClient = getHttpSolrClient(jettys.get(0).getBaseUrl().toString(), 15000, 60000)) {\n      Unload unloadCmd = new Unload(true);\n      unloadCmd.setCoreName(props.getCoreName());\n\n      String leader = props.getCoreUrl();\n      \n      testExecutor.execute(new Runnable() {\n        \n        @Override\n        public void run() {\n          try {\n            unloadClient.request(unloadCmd);\n          } catch (SolrServerException e) {\n            throw new RuntimeException(e);\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        }\n      });\n\n      try {\n        getCommonCloudSolrClient().getZkStateReader().waitForState(oneInstanceCollection2, 20000, TimeUnit.MILLISECONDS, (n, c) -> {\n          \n \n          try {\n            if (leader.equals(zkStateReader.getLeaderUrl(oneInstanceCollection2, \"shard1\", 10000))) {\n              return false;\n            }\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n          return true;\n        });\n      } catch (TimeoutException | InterruptedException e) {\n        fail(\"Leader never changed\");\n      }\n    }\n\n    IOUtils.close(collectionClients);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"197bbedf08450ade98a11f4a0001448059666bec":["a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["ea4018996a4853ecfb1c797beede737c90da6c3b","5b606c730b37f5bfe8c7cc9b3d105519f0bdfbd1"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["344b0840364d990b29b97467bfcc766ff8325d11"],"344b0840364d990b29b97467bfcc766ff8325d11":["43d1e498704edd2bba13548a189eed4dfccff11b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":["407687e67faf6e1f02a211ca078d8e3eed631027","a9cc12873abcfb571113b5c48ffc3475fcf53769"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["a9cc12873abcfb571113b5c48ffc3475fcf53769"],"bafca15d8e408346a67f4282ad1143b88023893b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"7ea7454b4afcb5dc9f7504f83d77b134df2b7c57":["a3c3e46d3417c353d7be14509cfab11b315927fe"],"43d1e498704edd2bba13548a189eed4dfccff11b":["28288370235ed02234a64753cdbf0c6ec096304a"],"ea4018996a4853ecfb1c797beede737c90da6c3b":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","43d1e498704edd2bba13548a189eed4dfccff11b"],"c215736a9e29403edd2132d9f0829a287b428df4":["c5a558d54519c651068ddb202f03befefb1514a7"],"d82832af39f94dbb58a3130fd216ff1d49435589":["e19067e820b148e8dc0b240da4f2771cf7b68252","88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","197bbedf08450ade98a11f4a0001448059666bec"],"88f39c3b3a16aebc5a91335341c7ad5b560e2277":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["7ea7454b4afcb5dc9f7504f83d77b134df2b7c57"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"fa64435b5902ce266c23755a4a00691a3285dab8":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"5b606c730b37f5bfe8c7cc9b3d105519f0bdfbd1":["d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"407687e67faf6e1f02a211ca078d8e3eed631027":["88f39c3b3a16aebc5a91335341c7ad5b560e2277","c215736a9e29403edd2132d9f0829a287b428df4"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["5b606c730b37f5bfe8c7cc9b3d105519f0bdfbd1"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":["e19067e820b148e8dc0b240da4f2771cf7b68252","88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"a9cc12873abcfb571113b5c48ffc3475fcf53769":["c215736a9e29403edd2132d9f0829a287b428df4"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["fa64435b5902ce266c23755a4a00691a3285dab8"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","3f767f8c99eaedb984df754fe61f21c5de260f94"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","a9b4296bd51ca61b482138791478afdd0f7d3a3d"],"a3c3e46d3417c353d7be14509cfab11b315927fe":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"28288370235ed02234a64753cdbf0c6ec096304a":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","197bbedf08450ade98a11f4a0001448059666bec"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["33d0ed80b7b47e34ad3ff033a77544563aba3085"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","344b0840364d990b29b97467bfcc766ff8325d11"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["7321b77a7bc3edfebd637ef273e9dfaa9969eba6","33d0ed80b7b47e34ad3ff033a77544563aba3085"],"c5a558d54519c651068ddb202f03befefb1514a7":["88f39c3b3a16aebc5a91335341c7ad5b560e2277"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["33d0ed80b7b47e34ad3ff033a77544563aba3085","3f767f8c99eaedb984df754fe61f21c5de260f94"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8":["ea4018996a4853ecfb1c797beede737c90da6c3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"197bbedf08450ade98a11f4a0001448059666bec":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4","28288370235ed02234a64753cdbf0c6ec096304a"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"344b0840364d990b29b97467bfcc766ff8325d11":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"3e4d4ec39bf5396230748ca859ff05ab024b6fc5":[],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["a3c3e46d3417c353d7be14509cfab11b315927fe"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7ea7454b4afcb5dc9f7504f83d77b134df2b7c57":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ea4018996a4853ecfb1c797beede737c90da6c3b":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8"],"43d1e498704edd2bba13548a189eed4dfccff11b":["344b0840364d990b29b97467bfcc766ff8325d11","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"c215736a9e29403edd2132d9f0829a287b428df4":["407687e67faf6e1f02a211ca078d8e3eed631027","a9cc12873abcfb571113b5c48ffc3475fcf53769"],"d82832af39f94dbb58a3130fd216ff1d49435589":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["99a533edf1b9ea2c1b85e012d6e826545389e9c8"],"fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"88f39c3b3a16aebc5a91335341c7ad5b560e2277":["d82832af39f94dbb58a3130fd216ff1d49435589","407687e67faf6e1f02a211ca078d8e3eed631027","db4fdbf3d262768eabc027cd8321edca0cd11fa8","c5a558d54519c651068ddb202f03befefb1514a7"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["102da6baafc0f534a59f31729343dbab9d3b9e9a"],"99a533edf1b9ea2c1b85e012d6e826545389e9c8":["ea4018996a4853ecfb1c797beede737c90da6c3b"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["bafca15d8e408346a67f4282ad1143b88023893b"],"33d0ed80b7b47e34ad3ff033a77544563aba3085":["3f767f8c99eaedb984df754fe61f21c5de260f94","fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a9b4296bd51ca61b482138791478afdd0f7d3a3d":["197bbedf08450ade98a11f4a0001448059666bec","b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"102da6baafc0f534a59f31729343dbab9d3b9e9a":["7c3f4fed97dabfe4bcddc3566fd190a7c909bc4f"],"fa64435b5902ce266c23755a4a00691a3285dab8":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"5b606c730b37f5bfe8c7cc9b3d105519f0bdfbd1":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","7321b77a7bc3edfebd637ef273e9dfaa9969eba6"],"407687e67faf6e1f02a211ca078d8e3eed631027":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5"],"7321b77a7bc3edfebd637ef273e9dfaa9969eba6":["33d0ed80b7b47e34ad3ff033a77544563aba3085","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"db4fdbf3d262768eabc027cd8321edca0cd11fa8":[],"a9cc12873abcfb571113b5c48ffc3475fcf53769":["3e4d4ec39bf5396230748ca859ff05ab024b6fc5","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["d82832af39f94dbb58a3130fd216ff1d49435589","88f39c3b3a16aebc5a91335341c7ad5b560e2277","db4fdbf3d262768eabc027cd8321edca0cd11fa8"],"8fd5be977c105554c6a7b68afcdbc511439723ab":[],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["fbedfa79ef95dc2b5b49f7d54d80e0b47867f9b4"],"a3c3e46d3417c353d7be14509cfab11b315927fe":["7ea7454b4afcb5dc9f7504f83d77b134df2b7c57"],"28288370235ed02234a64753cdbf0c6ec096304a":["43d1e498704edd2bba13548a189eed4dfccff11b"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["fa64435b5902ce266c23755a4a00691a3285dab8","8fd5be977c105554c6a7b68afcdbc511439723ab","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"c5a558d54519c651068ddb202f03befefb1514a7":["c215736a9e29403edd2132d9f0829a287b428df4"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["a9b4296bd51ca61b482138791478afdd0f7d3a3d","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"d90ea89f2d30bb2f567b801c0ba81e1c2f3dc9c8":["5b606c730b37f5bfe8c7cc9b3d105519f0bdfbd1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","3e4d4ec39bf5396230748ca859ff05ab024b6fc5","d82832af39f94dbb58a3130fd216ff1d49435589","db4fdbf3d262768eabc027cd8321edca0cd11fa8","8fd5be977c105554c6a7b68afcdbc511439723ab","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}