{"path":"lucene/demo/src/java/org/apache/lucene/demo/IndexFiles#indexDoc(IndexWriter,Path,long).mjava","commits":[{"id":"f4abec28b874149a7223e32cc7a01704c27790de","date":1410644789,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/demo/src/java/org/apache/lucene/demo/IndexFiles#indexDoc(IndexWriter,Path,long).mjava","pathOld":"/dev/null","sourceNew":"  /** Indexes a single document */\n  static void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {\n    try (InputStream stream = Files.newInputStream(file)) {\n      // make a new, empty document\n      Document doc = new Document();\n      \n      // Add the path of the file as a field named \"path\".  Use a\n      // field that is indexed (i.e. searchable), but don't tokenize \n      // the field into separate words and don't index term frequency\n      // or positional information:\n      Field pathField = new StringField(\"path\", file.toString(), Field.Store.YES);\n      doc.add(pathField);\n      \n      // Add the last modified date of the file a field named \"modified\".\n      // Use a LongField that is indexed (i.e. efficiently filterable with\n      // NumericRangeFilter).  This indexes to milli-second resolution, which\n      // is often too fine.  You could instead create a number based on\n      // year/month/day/hour/minutes/seconds, down the resolution you require.\n      // For example the long value 2011021714 would mean\n      // February 17, 2011, 2-3 PM.\n      doc.add(new LongField(\"modified\", lastModified, Field.Store.NO));\n      \n      // Add the contents of the file to a field named \"contents\".  Specify a Reader,\n      // so that the text of the file is tokenized and indexed, but not stored.\n      // Note that FileReader expects the file to be in UTF-8 encoding.\n      // If that's not the case searching for special characters will fail.\n      doc.add(new TextField(\"contents\", new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));\n      \n      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {\n        // New index, so we just add the document (no old document can be there):\n        System.out.println(\"adding \" + file);\n        writer.addDocument(doc);\n      } else {\n        // Existing index (an old copy of this document may have been indexed) so \n        // we use updateDocument instead to replace the old one matching the exact \n        // path, if present:\n        System.out.println(\"updating \" + file);\n        writer.updateDocument(new Term(\"path\", file.toString()), doc);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"770342641f7b505eaa8dccdc666158bff2419109","date":1449868421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/demo/src/java/org/apache/lucene/demo/IndexFiles#indexDoc(IndexWriter,Path,long).mjava","pathOld":"lucene/demo/src/java/org/apache/lucene/demo/IndexFiles#indexDoc(IndexWriter,Path,long).mjava","sourceNew":"  /** Indexes a single document */\n  static void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {\n    try (InputStream stream = Files.newInputStream(file)) {\n      // make a new, empty document\n      Document doc = new Document();\n      \n      // Add the path of the file as a field named \"path\".  Use a\n      // field that is indexed (i.e. searchable), but don't tokenize \n      // the field into separate words and don't index term frequency\n      // or positional information:\n      Field pathField = new StringField(\"path\", file.toString(), Field.Store.YES);\n      doc.add(pathField);\n      \n      // Add the last modified date of the file a field named \"modified\".\n      // Use a DimensionalLongField that is indexed (i.e. efficiently filterable with\n      // DimensionalRangeQuery).  This indexes to milli-second resolution, which\n      // is often too fine.  You could instead create a number based on\n      // year/month/day/hour/minutes/seconds, down the resolution you require.\n      // For example the long value 2011021714 would mean\n      // February 17, 2011, 2-3 PM.\n      doc.add(new DimensionalLongField(\"modified\", lastModified));\n      \n      // Add the contents of the file to a field named \"contents\".  Specify a Reader,\n      // so that the text of the file is tokenized and indexed, but not stored.\n      // Note that FileReader expects the file to be in UTF-8 encoding.\n      // If that's not the case searching for special characters will fail.\n      doc.add(new TextField(\"contents\", new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));\n      \n      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {\n        // New index, so we just add the document (no old document can be there):\n        System.out.println(\"adding \" + file);\n        writer.addDocument(doc);\n      } else {\n        // Existing index (an old copy of this document may have been indexed) so \n        // we use updateDocument instead to replace the old one matching the exact \n        // path, if present:\n        System.out.println(\"updating \" + file);\n        writer.updateDocument(new Term(\"path\", file.toString()), doc);\n      }\n    }\n  }\n\n","sourceOld":"  /** Indexes a single document */\n  static void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {\n    try (InputStream stream = Files.newInputStream(file)) {\n      // make a new, empty document\n      Document doc = new Document();\n      \n      // Add the path of the file as a field named \"path\".  Use a\n      // field that is indexed (i.e. searchable), but don't tokenize \n      // the field into separate words and don't index term frequency\n      // or positional information:\n      Field pathField = new StringField(\"path\", file.toString(), Field.Store.YES);\n      doc.add(pathField);\n      \n      // Add the last modified date of the file a field named \"modified\".\n      // Use a LongField that is indexed (i.e. efficiently filterable with\n      // NumericRangeFilter).  This indexes to milli-second resolution, which\n      // is often too fine.  You could instead create a number based on\n      // year/month/day/hour/minutes/seconds, down the resolution you require.\n      // For example the long value 2011021714 would mean\n      // February 17, 2011, 2-3 PM.\n      doc.add(new LongField(\"modified\", lastModified, Field.Store.NO));\n      \n      // Add the contents of the file to a field named \"contents\".  Specify a Reader,\n      // so that the text of the file is tokenized and indexed, but not stored.\n      // Note that FileReader expects the file to be in UTF-8 encoding.\n      // If that's not the case searching for special characters will fail.\n      doc.add(new TextField(\"contents\", new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));\n      \n      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {\n        // New index, so we just add the document (no old document can be there):\n        System.out.println(\"adding \" + file);\n        writer.addDocument(doc);\n      } else {\n        // Existing index (an old copy of this document may have been indexed) so \n        // we use updateDocument instead to replace the old one matching the exact \n        // path, if present:\n        System.out.println(\"updating \" + file);\n        writer.updateDocument(new Term(\"path\", file.toString()), doc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cab7a79353f33d1a94cd307bf33aa5148601ebe6","date":1453391888,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/demo/src/java/org/apache/lucene/demo/IndexFiles#indexDoc(IndexWriter,Path,long).mjava","pathOld":"lucene/demo/src/java/org/apache/lucene/demo/IndexFiles#indexDoc(IndexWriter,Path,long).mjava","sourceNew":"  /** Indexes a single document */\n  static void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {\n    try (InputStream stream = Files.newInputStream(file)) {\n      // make a new, empty document\n      Document doc = new Document();\n      \n      // Add the path of the file as a field named \"path\".  Use a\n      // field that is indexed (i.e. searchable), but don't tokenize \n      // the field into separate words and don't index term frequency\n      // or positional information:\n      Field pathField = new StringField(\"path\", file.toString(), Field.Store.YES);\n      doc.add(pathField);\n      \n      // Add the last modified date of the file a field named \"modified\".\n      // Use a LongPoint that is indexed (i.e. efficiently filterable with\n      // PointRangeQuery).  This indexes to milli-second resolution, which\n      // is often too fine.  You could instead create a number based on\n      // year/month/day/hour/minutes/seconds, down the resolution you require.\n      // For example the long value 2011021714 would mean\n      // February 17, 2011, 2-3 PM.\n      doc.add(new LongPoint(\"modified\", lastModified));\n      \n      // Add the contents of the file to a field named \"contents\".  Specify a Reader,\n      // so that the text of the file is tokenized and indexed, but not stored.\n      // Note that FileReader expects the file to be in UTF-8 encoding.\n      // If that's not the case searching for special characters will fail.\n      doc.add(new TextField(\"contents\", new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));\n      \n      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {\n        // New index, so we just add the document (no old document can be there):\n        System.out.println(\"adding \" + file);\n        writer.addDocument(doc);\n      } else {\n        // Existing index (an old copy of this document may have been indexed) so \n        // we use updateDocument instead to replace the old one matching the exact \n        // path, if present:\n        System.out.println(\"updating \" + file);\n        writer.updateDocument(new Term(\"path\", file.toString()), doc);\n      }\n    }\n  }\n\n","sourceOld":"  /** Indexes a single document */\n  static void indexDoc(IndexWriter writer, Path file, long lastModified) throws IOException {\n    try (InputStream stream = Files.newInputStream(file)) {\n      // make a new, empty document\n      Document doc = new Document();\n      \n      // Add the path of the file as a field named \"path\".  Use a\n      // field that is indexed (i.e. searchable), but don't tokenize \n      // the field into separate words and don't index term frequency\n      // or positional information:\n      Field pathField = new StringField(\"path\", file.toString(), Field.Store.YES);\n      doc.add(pathField);\n      \n      // Add the last modified date of the file a field named \"modified\".\n      // Use a DimensionalLongField that is indexed (i.e. efficiently filterable with\n      // DimensionalRangeQuery).  This indexes to milli-second resolution, which\n      // is often too fine.  You could instead create a number based on\n      // year/month/day/hour/minutes/seconds, down the resolution you require.\n      // For example the long value 2011021714 would mean\n      // February 17, 2011, 2-3 PM.\n      doc.add(new DimensionalLongField(\"modified\", lastModified));\n      \n      // Add the contents of the file to a field named \"contents\".  Specify a Reader,\n      // so that the text of the file is tokenized and indexed, but not stored.\n      // Note that FileReader expects the file to be in UTF-8 encoding.\n      // If that's not the case searching for special characters will fail.\n      doc.add(new TextField(\"contents\", new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8))));\n      \n      if (writer.getConfig().getOpenMode() == OpenMode.CREATE) {\n        // New index, so we just add the document (no old document can be there):\n        System.out.println(\"adding \" + file);\n        writer.addDocument(doc);\n      } else {\n        // Existing index (an old copy of this document may have been indexed) so \n        // we use updateDocument instead to replace the old one matching the exact \n        // path, if present:\n        System.out.println(\"updating \" + file);\n        writer.updateDocument(new Term(\"path\", file.toString()), doc);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["770342641f7b505eaa8dccdc666158bff2419109"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f4abec28b874149a7223e32cc7a01704c27790de":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"770342641f7b505eaa8dccdc666158bff2419109":["f4abec28b874149a7223e32cc7a01704c27790de"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"]},"commit2Childs":{"cab7a79353f33d1a94cd307bf33aa5148601ebe6":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f4abec28b874149a7223e32cc7a01704c27790de"],"f4abec28b874149a7223e32cc7a01704c27790de":["770342641f7b505eaa8dccdc666158bff2419109"],"770342641f7b505eaa8dccdc666158bff2419109":["cab7a79353f33d1a94cd307bf33aa5148601ebe6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}