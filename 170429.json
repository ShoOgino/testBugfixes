{"path":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","commits":[{"id":"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","date":1508899684,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"/dev/null","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && (term.totalTermFreq() == -1 || freq < term.totalTermFreq())) {\n        final long prevTotalTermFreq;\n        if (term.totalTermFreq() == -1) {\n          prevTotalTermFreq = -1;\n        } else {\n          prevTotalTermFreq = term.totalTermFreq() - 1;\n        }\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, prevTotalTermFreq);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"086ffe31d8fba0110227db122974163709ecc1b4","date":1509678141,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && (term.totalTermFreq() == -1 || freq < term.totalTermFreq())) {\n        final long prevTotalTermFreq;\n        if (term.totalTermFreq() == -1) {\n          prevTotalTermFreq = -1;\n        } else {\n          prevTotalTermFreq = term.totalTermFreq() - 1;\n        }\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, prevTotalTermFreq);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && (term.totalTermFreq() == -1 || freq < term.totalTermFreq())) {\n        final long prevTotalTermFreq;\n        if (term.totalTermFreq() == -1) {\n          prevTotalTermFreq = -1;\n        } else {\n          prevTotalTermFreq = term.totalTermFreq() - 1;\n        }\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, prevTotalTermFreq);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fc47cb7b4346802411bb432f501ed0673d7119e","date":1512640179,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf","date":1514891219,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68d6cb7f0f019661a784bd0e5a21e85b5f812af6","date":1515075216,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimScorer scorer = similarity.scorer(boost, corpus, term);\n    try {\n      float score = scorer.score(freq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(prevFreq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(Explanation.match(prevFreq, \"freq, occurrences of term within document\"), norm);\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        float prevNormScore = scorer.score(freq, norm - 1);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm - 1);\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimScorer prevTermScorer = similarity.scorer(boost, corpus, term);\n        float prevTermScore = prevTermScorer.score(freq, norm);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0c68bfb3354451a11c895b36484af94f27530b79","date":1515505336,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimScorer scorer = similarity.scorer(boost, corpus, term);\n    try {\n      float maxScore = scorer.score(Float.MAX_VALUE, 1);\n      assertFalse(\"maxScore is NaN\", Float.isNaN(maxScore));\n\n      float score = scorer.score(freq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      assertTrue(\"greater than maxScore: \" + score + \">\" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(prevFreq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(Explanation.match(prevFreq, \"freq, occurrences of term within document\"), norm);\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        float prevNormScore = scorer.score(freq, norm - 1);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm - 1);\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimScorer prevTermScorer = similarity.scorer(boost, corpus, term);\n        float prevTermScore = prevTermScorer.score(freq, norm);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimScorer scorer = similarity.scorer(boost, corpus, term);\n    try {\n      float score = scorer.score(freq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(prevFreq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(Explanation.match(prevFreq, \"freq, occurrences of term within document\"), norm);\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        float prevNormScore = scorer.score(freq, norm - 1);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm - 1);\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimScorer prevTermScorer = similarity.scorer(boost, corpus, term);\n        float prevTermScore = prevTermScorer.score(freq, norm);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimScorer scorer = similarity.scorer(boost, corpus, term);\n    try {\n      float maxScore = scorer.score(Float.MAX_VALUE, 1);\n      assertFalse(\"maxScore is NaN\", Float.isNaN(maxScore));\n\n      float score = scorer.score(freq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      assertTrue(\"greater than maxScore: \" + score + \">\" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(prevFreq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(Explanation.match(prevFreq, \"freq, occurrences of term within document\"), norm);\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        float prevNormScore = scorer.score(freq, norm - 1);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm - 1);\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimScorer prevTermScorer = similarity.scorer(boost, corpus, term);\n        float prevTermScore = prevTermScorer.score(freq, norm);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimWeight weight = similarity.computeWeight(boost, corpus, term);\n    SimScorer scorer = similarity.simScorer(weight, NORM_VALUES.get(norm).getContext());\n    try {\n      float score = scorer.score(0, freq);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      float maxScore = scorer.maxScore(freq);\n      assertTrue(\"score > maxScore: \" + score + \" > \" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(0, prevFreq);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(0, Explanation.match(prevFreq, \"freq, occurrences of term within document\"));\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        SimScorer prevNormScorer = similarity.simScorer(weight, NORM_VALUES.get(norm - 1).getContext());\n        float prevNormScore = prevNormScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = prevNormScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimWeight prevWeight = similarity.computeWeight(boost, corpus, term);\n        SimScorer prevTermScorer = similarity.simScorer(prevWeight, NORM_VALUES.get(norm).getContext());\n        float prevTermScore = prevTermScorer.score(0, freq);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(0, Explanation.match(freq, \"freq, occurrences of term within document\"));\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4208ed8e426ae5f75a41d8b4ae53f4587e413061","date":1580475454,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/search/similarities/BaseSimilarityTestCase#doTestScoring(Similarity,CollectionStatistics,TermStatistics,float,float,int).mjava","sourceNew":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimScorer scorer = similarity.scorer(boost, corpus, term);\n    try {\n      float maxScore = scorer.score(Float.MAX_VALUE, 1);\n      assertFalse(\"maxScore is NaN\", Float.isNaN(maxScore));\n\n      float score = scorer.score(freq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      assertTrue(\"greater than maxScore: \" + score + \">\" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      if (rarely()) {\n        CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      }\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(prevFreq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(Explanation.match(prevFreq, \"freq, occurrences of term within document\"), norm);\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      if (rarely()) {\n        CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n      }\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        float prevNormScore = scorer.score(freq, norm - 1);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm - 1);\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        if (rarely()) {\n          CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n        }\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimScorer prevTermScorer = similarity.scorer(boost, corpus, term);\n        float prevTermScore = prevTermScorer.score(freq, norm);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        if (rarely()) {\n          CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n        }\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","sourceOld":"  /** runs for a single test case, so that if you hit a test failure you can write a reproducer just for that scenario */\n  private static void doTestScoring(Similarity similarity, CollectionStatistics corpus, TermStatistics term, float boost, float freq, int norm) throws IOException {\n    boolean success = false;\n    SimScorer scorer = similarity.scorer(boost, corpus, term);\n    try {\n      float maxScore = scorer.score(Float.MAX_VALUE, 1);\n      assertFalse(\"maxScore is NaN\", Float.isNaN(maxScore));\n\n      float score = scorer.score(freq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(\"infinite/NaN score: \" + score, Float.isFinite(score));\n      assertTrue(\"negative score: \" + score, score >= 0);\n      assertTrue(\"greater than maxScore: \" + score + \">\" + maxScore, score <= maxScore);\n      // check explanation matches\n      Explanation explanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n      if (score != explanation.getValue().doubleValue()) {\n        fail(\"expected: \" + score + \", got: \" + explanation);\n      }\n      CheckHits.verifyExplanation(\"<test query>\", 0, score, true, explanation);\n      \n      // check score(freq-1), given the same norm it should be <= score(freq) [scores non-decreasing for more term occurrences]\n      final float prevFreq;\n      if (random().nextBoolean() && freq == (int)freq && freq > 1 && term.docFreq() > 1) {\n        // previous in integer space\n        prevFreq = freq - 1;\n      } else {\n        // previous in float space (e.g. for sloppyPhrase)\n        prevFreq = Math.nextDown(freq);\n      }\n      \n      float prevScore = scorer.score(prevFreq, norm);\n      // check that score isn't infinite or negative\n      assertTrue(Float.isFinite(prevScore));\n      assertTrue(prevScore >= 0);\n      // check explanation matches\n      Explanation prevExplanation = scorer.explain(Explanation.match(prevFreq, \"freq, occurrences of term within document\"), norm);\n      if (prevScore != prevExplanation.getValue().doubleValue()) {\n        fail(\"expected: \" + prevScore + \", got: \" + prevExplanation);\n      }\n      CheckHits.verifyExplanation(\"test query (prevFreq)\", 0, prevScore, true, prevExplanation);\n\n      if (prevScore > score) {\n        System.out.println(prevExplanation);\n        System.out.println(explanation);\n        fail(\"score(\" + prevFreq + \")=\" + prevScore + \" > score(\" + freq + \")=\" + score);\n      }\n      \n      // check score(norm-1), given the same freq it should be >= score(norm) [scores non-decreasing as docs get shorter]\n      if (norm > 1) {\n        float prevNormScore = scorer.score(freq, norm - 1);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevNormScore));\n        assertTrue(prevNormScore >= 0);\n        // check explanation matches\n        Explanation prevNormExplanation = scorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm - 1);\n        if (prevNormScore != prevNormExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevNormScore + \", got: \" + prevNormExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevNorm)\", 0, prevNormScore, true, prevNormExplanation);\n\n        if (prevNormScore < score) {\n          System.out.println(prevNormExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (norm-1) + \")=\" + prevNormScore + \" < score(\" + freq + \",\" + norm + \")=\" + score);\n        }\n      }\n      \n      // check score(term-1), given the same freq/norm it should be >= score(term) [scores non-decreasing as terms get rarer]\n      if (term.docFreq() > 1 && freq < term.totalTermFreq()) {\n        TermStatistics prevTerm = new TermStatistics(term.term(), term.docFreq() - 1, term.totalTermFreq() - 1);\n        SimScorer prevTermScorer = similarity.scorer(boost, corpus, term);\n        float prevTermScore = prevTermScorer.score(freq, norm);\n        // check that score isn't infinite or negative\n        assertTrue(Float.isFinite(prevTermScore));\n        assertTrue(prevTermScore >= 0);\n        // check explanation matches\n        Explanation prevTermExplanation = prevTermScorer.explain(Explanation.match(freq, \"freq, occurrences of term within document\"), norm);\n        if (prevTermScore != prevTermExplanation.getValue().doubleValue()) {\n          fail(\"expected: \" + prevTermScore + \", got: \" + prevTermExplanation);\n        }\n        CheckHits.verifyExplanation(\"test query (prevTerm)\", 0, prevTermScore, true, prevTermExplanation);\n\n        if (prevTermScore < score) {\n          System.out.println(prevTermExplanation);\n          System.out.println(explanation);\n          fail(\"score(\" + freq + \",\" + (prevTerm) + \")=\" + prevTermScore + \" < score(\" + freq + \",\" + term + \")=\" + score);\n        }\n      }\n      \n      success = true;\n    } finally {\n      if (!success) {\n        System.out.println(similarity);\n        System.out.println(corpus);\n        System.out.println(term);\n        if (norm == 0) {\n          System.out.println(\"norms=omitted\");\n        } else {\n          System.out.println(\"norm=\" + norm + \" (doc length ~ \" + SmallFloat.byte4ToInt((byte) norm) + \")\");\n        }\n        System.out.println(\"freq=\" + freq);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0c68bfb3354451a11c895b36484af94f27530b79":["68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"b94236357aaa22b76c10629851fe4e376e0cea82":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf","0c68bfb3354451a11c895b36484af94f27530b79"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"086ffe31d8fba0110227db122974163709ecc1b4":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46","086ffe31d8fba0110227db122974163709ecc1b4"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["417142ff08fda9cf0b72d5133e63097a166c6458"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["b94236357aaa22b76c10629851fe4e376e0cea82"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"417142ff08fda9cf0b72d5133e63097a166c6458":["d523b8189b211dd1630166aa77b8c88bb48b3fcc","9fc47cb7b4346802411bb432f501ed0673d7119e"]},"commit2Childs":{"0c68bfb3354451a11c895b36484af94f27530b79":["b94236357aaa22b76c10629851fe4e376e0cea82"],"68d6cb7f0f019661a784bd0e5a21e85b5f812af6":["0c68bfb3354451a11c895b36484af94f27530b79"],"b94236357aaa22b76c10629851fe4e376e0cea82":["4208ed8e426ae5f75a41d8b4ae53f4587e413061"],"ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46":["086ffe31d8fba0110227db122974163709ecc1b4","d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"086ffe31d8fba0110227db122974163709ecc1b4":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["9fc47cb7b4346802411bb432f501ed0673d7119e","417142ff08fda9cf0b72d5133e63097a166c6458"],"b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf":["b94236357aaa22b76c10629851fe4e376e0cea82","68d6cb7f0f019661a784bd0e5a21e85b5f812af6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ad1dc49b5314cfdb82a7ea40d2f92f07fe8cee46"],"4208ed8e426ae5f75a41d8b4ae53f4587e413061":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9fc47cb7b4346802411bb432f501ed0673d7119e":["417142ff08fda9cf0b72d5133e63097a166c6458"],"417142ff08fda9cf0b72d5133e63097a166c6458":["b8e3fe8a32614e52f7d9fd491b9faab852fbb4bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}