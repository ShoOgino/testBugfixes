{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","sourceNew":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copyBytes(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copyBytes(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copyBytes(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copyBytes(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copyBytes(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copyBytes(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene3x/Lucene3xFields.PreTermsEnum#seekCeil(BytesRef,boolean).mjava","sourceNew":null,"sourceOld":"    @Override\n    public SeekStatus seekCeil(BytesRef term, boolean useCache) throws IOException {\n      if (DEBUG_SURROGATES) {\n        System.out.println(\"TE.seek target=\" + UnicodeUtil.toHexString(term.utf8ToString()));\n      }\n      skipNext = false;\n      final TermInfosReader tis = getTermsDict();\n      final Term t0 = new Term(fieldInfo.name, term);\n\n      assert termEnum != null;\n\n      tis.seekEnum(termEnum, t0, useCache);\n\n      final Term t = termEnum.term();\n\n      if (t != null && t.field() == internedFieldName && term.bytesEquals(t.bytes())) {\n        // If we found an exact match, no need to do the\n        // surrogate dance\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek exact match\");\n        }\n        current = t.bytes();\n        return SeekStatus.FOUND;\n      } else if (t == null || t.field() != internedFieldName) {\n\n        // TODO: maybe we can handle this like the next()\n        // into null?  set term as prevTerm then dance?\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit EOF\");\n        }\n\n        // We hit EOF; try end-case surrogate dance: if we\n        // find an E, try swapping in S, backwards:\n        scratchTerm.copyBytes(term);\n\n        assert scratchTerm.offset == 0;\n\n        for(int i=scratchTerm.length-1;i>=0;i--) {\n          if (isHighBMPChar(scratchTerm.bytes, i)) {\n            if (DEBUG_SURROGATES) {\n              System.out.println(\"    found E pos=\" + i + \"; try seek\");\n            }\n\n            if (seekToNonBMP(seekTermEnum, scratchTerm, i)) {\n\n              scratchTerm.copyBytes(seekTermEnum.term().bytes());\n              getTermsDict().seekEnum(termEnum, seekTermEnum.term(), useCache);\n\n              newSuffixStart = 1+i;\n\n              doPushes();\n\n              // Found a match\n              // TODO: faster seek?\n              current = termEnum.term().bytes();\n              return SeekStatus.NOT_FOUND;\n            }\n          }\n        }\n        \n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek END\");\n        }\n\n        current = null;\n        return SeekStatus.END;\n      } else {\n\n        // We found a non-exact but non-null term; this one\n        // is fun -- just treat it like next, by pretending\n        // requested term was prev:\n        prevTerm.copyBytes(term);\n\n        if (DEBUG_SURROGATES) {\n          System.out.println(\"  seek hit non-exact term=\" + UnicodeUtil.toHexString(t.text()));\n        }\n\n        final BytesRef br = t.bytes();\n        assert br.offset == 0;\n\n        setNewSuffixStart(term, br);\n\n        surrogateDance();\n\n        final Term t2 = termEnum.term();\n        if (t2 == null || t2.field() != internedFieldName) {\n          // PreFlex codec interns field names; verify:\n          assert t2 == null || !t2.field().equals(internedFieldName);\n          current = null;\n          return SeekStatus.END;\n        } else {\n          current = t2.bytes();\n          assert !unicodeSortOrder || term.compareTo(current) < 0 : \"term=\" + UnicodeUtil.toHexString(term.utf8ToString()) + \" vs current=\" + UnicodeUtil.toHexString(current.utf8ToString());\n          return SeekStatus.NOT_FOUND;\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"]},"commit2Childs":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}